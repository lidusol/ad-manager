import { Component, ElementRef, Renderer2, Input, ViewChild, ContentChildren, forwardRef, HostBinding, HostListener, Directive, Optional, EventEmitter, Output, NgModule } from '@angular/core';
import { StyleCollection, shadowBuilder, Positioning, LyOverlayPosition, XPosition, YPosition, StyleRenderer, LyTheme2, LyOverlay, LyCommonModule, LyOverlayModule } from '@alyle/ui';
import { trigger, transition, group, style, animate } from '@angular/animations';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Subject, asapScheduler } from 'rxjs';
import { take, delay, debounceTime } from 'rxjs/operators';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alyle/ui';
import * as ɵngcc2 from '@angular/cdk/scrolling';

const _c0 = ["container"];
const _c1 = ["*"];
const STYLE_PRIORITY = -1;
const STYLES = (theme, ref) => {
    const menu = ref.selectorsOf(STYLES);
    const { after } = theme;
    return {
        $name: LyMenu.и,
        $priority: STYLE_PRIORITY,
        root: () => {
            var _a;
            return (((_a = theme.menu) === null || _a === void 0 ? void 0 : _a.root) && (theme.menu.root instanceof StyleCollection
                ? theme.menu.root.setTransformer(fn => fn(menu)).css
                : theme.menu.root(menu)));
        },
        container: (className) => `${className}{background:${theme.background.primary.default};border-radius:2px;box-shadow:${shadowBuilder(4)};display:block;padding-top:8px;padding-bottom:8px;transform-origin:inherit;pointer-events:all;overflow:auto;max-height:inherit;max-width:inherit;box-sizing:border-box;}`,
        item: (className) => `${className}{display:flex;min-height:48px;border-radius:0;width:100%;justify-content:flex-start;font-weight:400;}${className} ly-icon{margin-${after}:16px;}`,
        itemSubMenuTrigger: () => (className) => `${className}{padding-${after}:32px;}${className}::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;${after}:16px;transform:translateY(-50%);}`
    };
};
const ANIMATIONS = [
    trigger('transformMenu', [
        transition('void => enter', group([
            style({
                opacity: 0,
                transform: 'scale(0.8)'
            }),
            animate('100ms linear', style({
                opacity: 1
            })),
            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),
        ]))
    ]),
    trigger('transformMenuLeave', [
        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))
    ])
];
/** Menu container */
class LyMenu {
    constructor(_theme, _el, _renderer, _viewportRuler, sRenderer) {
        this._theme = _theme;
        this._el = _el;
        this._renderer = _renderer;
        this._viewportRuler = _viewportRuler;
        this.sRenderer = sRenderer;
        /**
         * styles
         * @docs-private
         */
        this.classes = this.sRenderer.renderSheet(STYLES, true);
        /** Emits whenever an animation on the menu completes. */
        this._animationDone = new Subject();
        this._hasBackdrop = true;
    }
    /** Menu Trigger */
    set ref(value) {
        this._ref = value;
        this._menuRef = value._menuRef;
    }
    get ref() {
        return this._ref;
    }
    /** Whether the menu has a backdrop. */
    get hasBackdrop() {
        return this._hasBackdrop;
    }
    set hasBackdrop(value) {
        this._hasBackdrop = coerceBooleanProperty(value);
    }
    ngOnChanges() {
        var _a;
        if (((_a = this.ref) === null || _a === void 0 ? void 0 : _a._menuRef) && this._container) {
            // Update backdrop
            this.ref._menuRef.updateBackdrop(this.ref._isItemSubMenuTrigger() ? false : this.hasBackdrop);
            this._updatePlacement();
            this._checkBackdropAndOpenOnHover();
        }
    }
    ngOnInit() {
        if (!this.ref) {
            throw new Error('LyMenu: require @Input() ref');
        }
    }
    ngAfterViewInit() {
        if (this.ref._menuRef) {
            this.ref._menuRef.onResizeScroll = this._updatePlacement.bind(this);
            this.ref._menuRef.updateBackdrop(this.ref._isItemSubMenuTrigger() ? false : this.hasBackdrop);
            this._checkBackdropAndOpenOnHover();
        }
        this._updatePlacement();
        this.ref.menuOpened.emit();
        Promise.resolve(null).then(() => {
            this.ref._setMenuOpenToTrue();
        });
        const hostTrigger = this._getHostMenuTrigger();
        hostTrigger._menuDetached
            .pipe(take(1))
            .subscribe(() => this._ref.closeMenu());
        this._addOpenOnHover();
    }
    ngOnDestroy() {
        this._removeOpenOnHoverListeners();
    }
    _checkBackdropAndOpenOnHover() {
        var _a;
        const hostTrigger = this._getHostMenuTrigger();
        if (this.hasBackdrop && ((_a = hostTrigger._menuOpenOnHoverRef) === null || _a === void 0 ? void 0 : _a.openOnHover)) {
            throw new Error(`${LyMenu.и}: Can't use [hasBackdrop] with [openOnHover] at the same time, set [hasBackdrop] to false to use [openOnHover]`);
        }
    }
    _getHostMenuTrigger() {
        var _a;
        let menuTrigger = this.ref;
        while ((_a = menuTrigger._menu) === null || _a === void 0 ? void 0 : _a.ref) {
            menuTrigger = menuTrigger._menu.ref;
        }
        return menuTrigger;
    }
    _addOpenOnHover() {
        var _a;
        const hostTrigger = this._getHostMenuTrigger();
        if (((_a = hostTrigger._menuOpenOnHoverRef) === null || _a === void 0 ? void 0 : _a.openOnHover) && !this._mouseenterListen && !this._mouseleaveListen) {
            hostTrigger._menuOpenOnHoverRef._handleMouseEnterOrLeave(true);
            this._mouseenterListen = this._renderer
                .listen(this._el.nativeElement, 'mouseenter', () => hostTrigger._menuOpenOnHoverRef._handleMouseEnterOrLeave(true));
            this._mouseleaveListen = this._renderer
                .listen(this._el.nativeElement, 'mouseleave', () => hostTrigger._menuOpenOnHoverRef._handleMouseEnterOrLeave(false));
        }
    }
    /** Remove listeners */
    _removeOpenOnHoverListeners() {
        if (this._mouseenterListen) {
            this._mouseenterListen();
        }
        if (this._mouseleaveListen) {
            this._mouseleaveListen();
        }
    }
    /** Update Menu Position */
    _updatePlacement() {
        var _a, _b;
        const el = (_a = this.ref._menuRef) === null || _a === void 0 ? void 0 : _a.containerElement;
        const container = (_b = this._container) === null || _b === void 0 ? void 0 : _b.nativeElement;
        // Do not update when not available
        if (!el || !container) {
            return;
        }
        // reset height & width
        this._renderer.setStyle(container, 'height', 'initial');
        this._renderer.setStyle(container, 'width', 'initial');
        const position = this.placement
            ? new Positioning(this.placement, this.xPosition, this.yPosition, this.ref._getHostElement(), el, this._theme.variables)
            : !this.ref._isItemSubMenuTrigger()
                ? new LyOverlayPosition(this._theme, this._viewportRuler, this.ref._getHostElement(), el)
                    .setXAnchor(this.xAnchor)
                    .setYAnchor(this.yAnchor)
                    .setXAxis(this.xAxis)
                    .setYAxis(this.yAxis)
                    .setFlip(true)
                    .build()
                : new LyOverlayPosition(this._theme, this._viewportRuler, this.ref._getHostElement(), el)
                    .setXAnchor(XPosition.after)
                    .setYAnchor(YPosition.above)
                    .setFlip(true)
                    .build();
        if (position instanceof Positioning) {
            // set position deprecated
            this._renderer.setStyle(el, 'transform', `translate3d(${position.x}px, ${position.y}px, 0)`);
            this._renderer.setStyle(this._el.nativeElement, 'transform-origin', `${position.ox} ${position.oy} 0`);
            // set height & width deprecated
            this._renderer.setStyle(container, 'height', position.height === 'initial' ? '100%' : position.height);
            this._renderer.setStyle(container, 'width', position.width === 'initial' ? '100%' : position.width);
        }
        else {
            // set position
            this._renderer.setStyle(el, 'left', `${position.x}px`);
            this._renderer.setStyle(el, 'top', `${position.y}px`);
            this._renderer.setStyle(container, 'width', position.width ? `${position.width}px` : '100%');
            this._renderer.setStyle(container, 'height', position.height ? `${position.height}px` : '100%');
            this._renderer.setStyle(this._el.nativeElement, 'transform-origin', `${position.xo}px ${position.yo}px 0`);
        }
    }
    _onAnimationStart(event) {
        this._isAnimating = true;
        if (event.triggerName === 'transformMenuLeave' && event.toState === 'void') {
            this._isDestroying = true;
        }
    }
    _onAnimationDone(event) {
        this._animationDone.next(event);
        this._isAnimating = false;
        if (event.toState === 'void' && event.triggerName === 'transformMenuLeave') {
            this.ref.destroy(this._menuRef);
        }
    }
}
LyMenu.ɵfac = function LyMenu_Factory(t) { return new (t || LyMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer)); };
LyMenu.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyMenu, selectors: [["ly-menu"]], contentQueries: function LyMenu_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LyMenuItem, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuItems = _t);
    } }, viewQuery: function LyMenu_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._container = _t.first);
    } }, hostVars: 1, hostBindings: function LyMenu_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵcomponentHostSyntheticListener("@transformMenuLeave.start", function LyMenu_animation_transformMenuLeave_start_HostBindingHandler($event) { return ctx._onAnimationStart($event); })("@transformMenuLeave.done", function LyMenu_animation_transformMenuLeave_done_HostBindingHandler($event) { return ctx._onAnimationDone($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@transformMenuLeave", ctx.transformMenuLeave);
    } }, inputs: { ref: "ref", hasBackdrop: "hasBackdrop", xAnchor: "xAnchor", yAnchor: "yAnchor", xAxis: "xAxis", yAxis: "yAxis", placement: "placement", xPosition: "xPosition", yPosition: "yPosition" }, exportAs: ["lyMenu"], features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 3, vars: 3, consts: [["container", ""]], template: function LyMenu_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵlistener("@transformMenu.start", function LyMenu_Template_div_animation_transformMenu_start_0_listener($event) { return ctx._onAnimationStart($event); })("@transformMenu.done", function LyMenu_Template_div_animation_transformMenu_done_0_listener($event) { return ctx._onAnimationDone($event); });
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.classes.container);
        ɵngcc0.ɵɵproperty("@transformMenu", "enter");
    } }, encapsulation: 2, data: { animation: [...ANIMATIONS] } });
/** @docs-private */
LyMenu.и = 'LyMenu';
LyMenu.ctorParameters = () => [
    { type: LyTheme2 },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewportRuler },
    { type: StyleRenderer }
];
LyMenu.propDecorators = {
    ref: [{ type: Input }],
    hasBackdrop: [{ type: Input }],
    _container: [{ type: ViewChild, args: ['container',] }],
    menuItems: [{ type: ContentChildren, args: [forwardRef(() => LyMenuItem),] }],
    xAnchor: [{ type: Input }],
    yAnchor: [{ type: Input }],
    xAxis: [{ type: Input }],
    yAxis: [{ type: Input }],
    placement: [{ type: Input }],
    xPosition: [{ type: Input }],
    yPosition: [{ type: Input }],
    transformMenuLeave: [{ type: HostBinding, args: ['@transformMenuLeave',] }],
    _onAnimationStart: [{ type: HostListener, args: ['@transformMenuLeave.start', ['$event'],] }],
    _onAnimationDone: [{ type: HostListener, args: ['@transformMenuLeave.done', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyMenu, [{
        type: Component,
        args: [{
                selector: 'ly-menu',
                animations: [...ANIMATIONS],
                template: "<div #container\n  [class]=\"classes.container\"\n  [@transformMenu]=\"'enter'\"\n  (@transformMenu.start)=\"_onAnimationStart($event)\"\n  (@transformMenu.done)=\"_onAnimationDone($event)\"\n>\n  <ng-content></ng-content>\n</div>",
                exportAs: 'lyMenu',
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.ViewportRuler }, { type: ɵngcc1.StyleRenderer }]; }, { ref: [{
            type: Input
        }], hasBackdrop: [{
            type: Input
        }], _onAnimationStart: [{
            type: HostListener,
            args: ['@transformMenuLeave.start', ['$event']]
        }], _onAnimationDone: [{
            type: HostListener,
            args: ['@transformMenuLeave.done', ['$event']]
        }], _container: [{
            type: ViewChild,
            args: ['container']
        }], menuItems: [{
            type: ContentChildren,
            args: [forwardRef(() => LyMenuItem)]
        }], xAnchor: [{
            type: Input
        }], yAnchor: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], placement: [{
            type: Input
        }], xPosition: [{
            type: Input
        }], yPosition: [{
            type: Input
        }], transformMenuLeave: [{
            type: HostBinding,
            args: ['@transformMenuLeave']
        }] }); })();
class LyMenuItem {
    constructor(_menu, el, renderer) {
        this._menu = _menu;
        renderer.addClass(el.nativeElement, _menu.classes.item);
    }
    _handleClick() {
        var _a;
        if (this._menu.ref && this._menu.ref._menuRef) {
            if (!this._getItemSubMenuTrigger()) {
                let currentTrigger = this._menu.ref;
                while (currentTrigger) {
                    currentTrigger.closeMenu();
                    currentTrigger = (_a = currentTrigger._menu) === null || _a === void 0 ? void 0 : _a.ref;
                }
            }
        }
    }
    _handleMouseEnter() {
        const itemSubMenuTrigger = this._getItemSubMenuTrigger();
        if (itemSubMenuTrigger && !this._menu._isDestroying) {
            if (this._menu._isAnimating) {
                this._menu._animationDone
                    .pipe(take(1), delay(0, asapScheduler))
                    .subscribe(() => {
                    itemSubMenuTrigger.openMenu();
                    this._closeOtherMenus();
                });
            }
            else {
                itemSubMenuTrigger.openMenu();
                this._closeOtherMenus();
            }
        }
        else {
            this._closeOtherMenus();
        }
    }
    /** Except for this, close all menus */
    _closeOtherMenus() {
        this._menu.menuItems.forEach(menuItem => {
            var _a;
            if (menuItem !== this) {
                (_a = menuItem._getItemSubMenuTrigger()) === null || _a === void 0 ? void 0 : _a.closeMenu();
            }
        });
    }
    _setItemSubMenuTrigger(menuTrigger) {
        this._itemSubMenuTrigger = menuTrigger;
    }
    _getItemSubMenuTrigger() {
        return this._itemSubMenuTrigger;
    }
}
LyMenuItem.ɵfac = function LyMenuItem_Factory(t) { return new (t || LyMenuItem)(ɵngcc0.ɵɵdirectiveInject(LyMenu, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
LyMenuItem.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LyMenuItem, selectors: [["", "ly-menu-item", ""]], hostBindings: function LyMenuItem_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function LyMenuItem_click_HostBindingHandler() { return ctx._handleClick(); })("mouseenter", function LyMenuItem_mouseenter_HostBindingHandler() { return ctx._handleMouseEnter(); });
    } } });
LyMenuItem.ctorParameters = () => [
    { type: LyMenu, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: Renderer2 }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyMenuItem, [{
        type: Directive,
        args: [{
                selector: '[ly-menu-item]',
                host: {
                    '(click)': '_handleClick()',
                    '(mouseenter)': '_handleMouseEnter()'
                }
            }]
    }], function () { return [{ type: LyMenu, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, null); })();
class LyMenuTriggerFor {
    constructor(elementRef, overlay, _menuItem, sRenderer, _menu) {
        this.elementRef = elementRef;
        this.overlay = overlay;
        this._menuItem = _menuItem;
        this.sRenderer = sRenderer;
        this._menu = _menu;
        this.classes = this.sRenderer.renderSheet(STYLES);
        this._menuOpen = false;
        this._menuDetached = new Subject();
        this.menuOpened = new EventEmitter();
        this.menuClosed = new EventEmitter();
        if (this._isItemSubMenuTrigger()) {
            _menuItem._setItemSubMenuTrigger(this);
            sRenderer.addClass(this.classes.itemSubMenuTrigger);
        }
    }
    /** Whether the menu is open. */
    get menuOpen() {
        return this._menuOpen;
    }
    ngOnDestroy() {
        // Not force destruction if it is already being destroyed
        if (!this._destroying) {
            this.closeMenu();
        }
        this._menuDetached.complete();
    }
    _handleClick() {
        if (!this._isItemSubMenuTrigger()) {
            this.toggleMenu();
        }
    }
    /** Opens the menu */
    openMenu() {
        if (!this._menuRef) {
            this._menuRef = this.overlay.create(this.lyMenuTriggerFor, {
                $implicit: this,
                data: this.menuData
            }, {
                styles: {
                    top: 0,
                    left: 0,
                    pointerEvents: null
                },
                fnDestroy: this.detach.bind(this),
                hasBackdrop: false
            });
        }
    }
    /** Closes the menu */
    closeMenu() {
        this.detach();
    }
    /** Toggle menu */
    toggleMenu() {
        if (this._menuRef) {
            this.closeMenu();
        }
        else {
            this.openMenu();
        }
    }
    /** @docs-private */
    detach() {
        if (this._menuRef) {
            this._menuRef.detach();
            this._menuRef = null;
            this._destroying = true;
            this._menuDetached.next();
        }
    }
    /** @docs-private */
    destroy(menuRef) {
        this.menuClosed.emit(null);
        menuRef.remove();
        this._destroying = false;
        Promise.resolve(null).then(() => this._menuOpen = false);
    }
    _getHostElement() {
        return this.elementRef.nativeElement;
    }
    _setMenuOpenToTrue() {
        this._menuOpen = true;
    }
    /**
     * @docs-private
     */
    _isItemSubMenuTrigger() {
        return !!this._menuItem;
    }
}
LyMenuTriggerFor.ɵfac = function LyMenuTriggerFor_Factory(t) { return new (t || LyMenuTriggerFor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyOverlay), ɵngcc0.ɵɵdirectiveInject(LyMenuItem, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(LyMenu, 8)); };
LyMenuTriggerFor.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LyMenuTriggerFor, selectors: [["", "lyMenuTriggerFor", ""]], hostBindings: function LyMenuTriggerFor_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function LyMenuTriggerFor_click_HostBindingHandler() { return ctx._handleClick(); });
    } }, inputs: { lyMenuTriggerFor: "lyMenuTriggerFor", menuData: ["lyMenuTriggerData", "menuData"] }, outputs: { menuOpened: "menuOpened", menuClosed: "menuClosed" }, exportAs: ["lyMenuTriggerFor"], features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ])] });
LyMenuTriggerFor.ctorParameters = () => [
    { type: ElementRef },
    { type: LyOverlay },
    { type: LyMenuItem, decorators: [{ type: Optional }] },
    { type: StyleRenderer },
    { type: LyMenu, decorators: [{ type: Optional }] }
];
LyMenuTriggerFor.propDecorators = {
    lyMenuTriggerFor: [{ type: Input }],
    menuData: [{ type: Input, args: ['lyMenuTriggerData',] }],
    menuOpened: [{ type: Output }],
    menuClosed: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyMenuTriggerFor, [{
        type: Directive,
        args: [{
                selector: '[lyMenuTriggerFor]',
                host: {
                    '(click)': '_handleClick()'
                },
                exportAs: 'lyMenuTriggerFor',
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.LyOverlay }, { type: LyMenuItem, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.StyleRenderer }, { type: LyMenu, decorators: [{
                type: Optional
            }] }]; }, { menuOpened: [{
            type: Output
        }], menuClosed: [{
            type: Output
        }], lyMenuTriggerFor: [{
            type: Input
        }], menuData: [{
            type: Input,
            args: ['lyMenuTriggerData']
        }] }); })();
class LyMenuOpenOnHover {
    constructor(_trigger) {
        this._trigger = _trigger;
        this._events = new Subject();
        this._openOnHover = true;
        _trigger._menuOpenOnHoverRef = this;
        this._events
            .pipe(debounceTime(200))
            .subscribe(enterOrLeave => {
            if (this.openOnHover) {
                if (enterOrLeave) {
                    _trigger.openMenu();
                }
                else {
                    _trigger.closeMenu();
                }
            }
        });
    }
    /** Whether menu should open on hover. */
    get openOnHover() {
        return this._openOnHover;
    }
    set openOnHover(value) {
        this._openOnHover = coerceBooleanProperty(value);
        Promise.resolve(null)
            .then(() => this._openOnHover
            ? this._trigger._menuOpenOnHoverRef = this
            : delete this._trigger._menuOpenOnHoverRef);
    }
    ngOnDestroy() {
        this._events.complete();
    }
    /** Handle mouseenter or mouseleave */
    _handleMouseEnterOrLeave(leaveOrEnter) {
        if (this.openOnHover) {
            if (leaveOrEnter) {
                this._trigger.openMenu();
            }
            this._events.next(leaveOrEnter);
        }
    }
}
LyMenuOpenOnHover.ɵfac = function LyMenuOpenOnHover_Factory(t) { return new (t || LyMenuOpenOnHover)(ɵngcc0.ɵɵdirectiveInject(LyMenuTriggerFor)); };
LyMenuOpenOnHover.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LyMenuOpenOnHover, selectors: [["", "lyMenuTriggerFor", "", "openOnHover", ""]], hostBindings: function LyMenuOpenOnHover_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LyMenuOpenOnHover_mouseenter_HostBindingHandler() { return ctx._handleMouseEnterOrLeave(true); })("mouseleave", function LyMenuOpenOnHover_mouseleave_HostBindingHandler() { return ctx._handleMouseEnterOrLeave(false); });
    } }, inputs: { openOnHover: "openOnHover" } });
LyMenuOpenOnHover.ctorParameters = () => [
    { type: LyMenuTriggerFor }
];
LyMenuOpenOnHover.propDecorators = {
    openOnHover: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyMenuOpenOnHover, [{
        type: Directive,
        args: [{
                selector: '[lyMenuTriggerFor][openOnHover]',
                host: {
                    '(mouseenter)': '_handleMouseEnterOrLeave(true)',
                    '(mouseleave)': '_handleMouseEnterOrLeave(false)'
                }
            }]
    }], function () { return [{ type: LyMenuTriggerFor }]; }, { openOnHover: [{
            type: Input
        }] }); })();

class LyMenuModule {
}
LyMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LyMenuModule });
LyMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LyMenuModule_Factory(t) { return new (t || LyMenuModule)(); }, imports: [[CommonModule, FormsModule, LyCommonModule, LyOverlayModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LyMenuModule, { declarations: function () { return [LyMenu,
        LyMenuItem,
        LyMenuTriggerFor,
        LyMenuOpenOnHover]; }, imports: function () { return [CommonModule, FormsModule, LyCommonModule, LyOverlayModule]; }, exports: function () { return [LyMenu,
        LyMenuItem,
        LyMenuTriggerFor,
        LyMenuOpenOnHover]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyMenuModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, LyCommonModule, LyOverlayModule],
                exports: [LyMenu, LyMenuItem, LyMenuTriggerFor, LyMenuOpenOnHover],
                declarations: [LyMenu, LyMenuItem, LyMenuTriggerFor, LyMenuOpenOnHover]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { LyMenu, LyMenuItem, LyMenuModule, LyMenuOpenOnHover, LyMenuTriggerFor, STYLES };

//# sourceMappingURL=alyle-ui-menu.js.map