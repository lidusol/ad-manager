import { forwardRef, EventEmitter, Component, ChangeDetectionStrategy, ElementRef, Renderer2, ChangeDetectorRef, Input, Output, ContentChildren, Optional, NgZone, ViewChild, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { st2c, StyleCollection, LY_COMMON_STYLES, LyTheme2, mixinDisableRipple, toBoolean, StyleRenderer, LyCoreStyles, LyFocusState, LyCommonModule } from '@alyle/ui';
import { Platform } from '@angular/cdk/platform';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alyle/ui';
import * as ɵngcc2 from '@angular/cdk/platform';

const _c0 = ["*"];
const _c1 = ["_input"];
const _c2 = ["_radioContainer"];
const _c3 = ["_labelContainer"];
const STYLE_PRIORITY = -2;
const DEFAULT_DISABLE_RIPPLE = false;
const DEFAULT_COLOR = 'accent';
const LY_RADIO_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => LyRadioGroup),
    multi: true
};
let idx = 0;
class UndefinedValue {
    constructor() { }
}
const STYLES = (theme, ref) => {
    const radio = ref.selectorsOf(STYLES);
    const { after, before } = theme;
    return {
        $priority: STYLE_PRIORITY,
        /** ly-radio-group */
        root: () => (className) => `${className}{display:inline-block;}${st2c(((theme.radio
            && theme.radio.root
            && (theme.radio.root instanceof StyleCollection
                ? theme.radio.root.setTransformer(fn => fn(radio))
                : theme.radio.root(radio)))), `${className}`)}`,
        radio: () => (className) => `${className}{display:inline-block;-webkit-tap-highlight-color:transparent;}${className}${radio.checked} ${radio.container} div:nth-child(1){transform:scale(1.25);}${className}${radio.checked} ${radio.container} div:nth-child(2){transform:scale(0.8);}${className}${radio.onFocusByKeyboard} ${radio.container}::after{box-shadow:0 0 0 12px;background:currentColor;opacity:.13;border-radius:50%;}`,
        label: (className) => `${className}{user-select:none;cursor:pointer;white-space:nowrap;position:relative;display:flex;align-items:baseline;}`,
        labelContent: null,
        container: (className) => `${className}{position:relative;margin-${before}:.125em;margin-${after}:.5em;margin-top:auto;margin-bottom:auto;width:16px;height:16px;}${className} div{margin:auto;border-radius:50%;width:1em;height:1em;box-sizing:border-box;}${className}::after{content:'';width:16px;height:16px;margin:auto;}${st2c((LY_COMMON_STYLES.fill), `${className}::after`)}${className} div:nth-child(2){background:currentColor;transform:scale(0);}${className} div:nth-child(1){transform:scale(1);border:solid .08em currentColor;color:${theme.text.disabled};}`,
        checked: null,
        _animations: () => (className) => `${className} ${radio.container} div{transition:transform cubic-bezier(.1, 1, 0.5, 1);transition-duration:250ms;}`,
        onFocusByKeyboard: null,
        disabled: () => (className) => `${className}{color:${theme.disabled.contrast};}${className} ${radio.container} div{color:${theme.disabled.contrast}!important;}`
    };
};
class LyRadioGroup {
    constructor(elementRef, renderer, _theme, _cd) {
        this._theme = _theme;
        this._cd = _cd;
        /** @docs-private */
        this.classes = this._theme.renderStyleSheet(STYLES);
        /** @docs-private */
        this.name = `ly-radio-name-${idx++}`;
        this.change = new EventEmitter();
        this.color = 'accent';
        /** The method to be called in order to update ngModel */
        this._controlValueAccessorChangeFn = () => { };
        /**
         * onTouch function registered via registerOnTouch (ControlValueAccessor).
         * @docs-private
         */
        this.onTouched = () => { };
        renderer.addClass(elementRef.nativeElement, this.classes.root);
    }
    set value(val) {
        if (this._value !== val) {
            if (this._radios) {
                this._updateCheckFromValue(val);
            }
        }
    }
    get value() {
        return this._value;
    }
    /**
     * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
     * radio buttons upon their blur.
     */
    _touch() {
        if (this.onTouched) {
            this.onTouched();
        }
    }
    /** @docs-private */
    writeValue(value) {
        if (!!this._radios) {
            this.value = value;
            this._markForCheck();
        }
    }
    /**
     * Registers a callback to be triggered when the model value changes.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     * @docs-private
     */
    registerOnChange(fn) {
        this._controlValueAccessorChangeFn = fn;
    }
    /**
     * Registers a callback to be triggered when the control is touched.
     * Implemented as part of ControlValueAccessor.
     * @param fn Callback to be registered.
     * @docs-private
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
     * @param _isDisabled Whether the control should be disabled.
     * @docs-private
     */
    setDisabledState(_isDisabled) {
        // this.disabled = isDisabled;
        this._markForCheck();
    }
    _updateCheckFromValue(val) {
        let newChecked;
        this._radios.forEach(radioButton => {
            if (val === radioButton.value) {
                this.updatevalue(val);
                newChecked = true;
                radioButton.checked = true;
            }
            else if (radioButton.checked) {
                radioButton.checked = false;
            }
        });
        if (!newChecked) {
            /** when val not exist in radio button !==  */
            this._controlValueAccessorChangeFn(null);
            if (this._value != null) {
                this._value = null;
            }
        }
    }
    /** @docs-private */
    updatevalue(value) {
        this._value = value;
        this._controlValueAccessorChangeFn(value);
        this.change.emit();
        this._markForCheck();
    }
    _markForCheck() {
        this._cd.markForCheck();
    }
    _radioResetChecked() {
        this._radios.forEach(_ => _._setCheckedToFalsy());
    }
}
LyRadioGroup.ɵfac = function LyRadioGroup_Factory(t) { return new (t || LyRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
LyRadioGroup.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyRadioGroup, selectors: [["ly-radio-group"]], contentQueries: function LyRadioGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LyRadio, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._radios = _t);
    } }, inputs: { color: "color", value: "value" }, outputs: { change: "change" }, exportAs: ["lyRadioGroup"], features: [ɵngcc0.ɵɵProvidersFeature([LY_RADIO_CONTROL_VALUE_ACCESSOR])], ngContentSelectors: _c0, decls: 1, vars: 0, template: function LyRadioGroup_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/** @docs-private */
LyRadioGroup.и = 'LyRadioGroup';
LyRadioGroup.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LyTheme2 },
    { type: ChangeDetectorRef }
];
LyRadioGroup.propDecorators = {
    value: [{ type: Input }],
    change: [{ type: Output }],
    color: [{ type: Input }],
    _radios: [{ type: ContentChildren, args: [forwardRef(() => LyRadio),] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyRadioGroup, [{
        type: Component,
        args: [{
                selector: 'ly-radio-group',
                template: `<ng-content></ng-content>`,
                providers: [LY_RADIO_CONTROL_VALUE_ACCESSOR],
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                exportAs: 'lyRadioGroup'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, { change: [{
            type: Output
        }], color: [{
            type: Input
        }], value: [{
            type: Input
        }], _radios: [{
            type: ContentChildren,
            args: [forwardRef(() => LyRadio)]
        }] }); })();
/** @docs-private */
class LyRadioBase {
    constructor(_theme, _ngZone, _platform) {
        this._theme = _theme;
        this._ngZone = _ngZone;
        this._platform = _platform;
    }
}
/** @docs-private */
const LyRadioMixinBase = mixinDisableRipple(LyRadioBase);
class LyRadio extends LyRadioMixinBase {
    constructor(
    /** @docs-private */
    radioGroup, _elementRef, _renderer, theme, changeDetectorRef, ngZone, _coreStyles, _focusState, _styleRenderer, platform) {
        super(theme, ngZone, platform);
        this.radioGroup = radioGroup;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.changeDetectorRef = changeDetectorRef;
        this._coreStyles = _coreStyles;
        this._focusState = _focusState;
        this._styleRenderer = _styleRenderer;
        /** @docs-private */
        this.classes = this.radioGroup.classes;
        /** @docs-private */
        this.id = `ly-radio-id-${idx++}`;
        /** @docs-private */
        this.name = '';
        this._value = null;
        this._checked = false;
        this.change = new EventEmitter();
        this._triggerElement = this._elementRef;
        this._rippleConfig = {
            centered: true,
            radius: 'containerSize',
            percentageToIncrease: 150
        };
        _renderer.addClass(_elementRef.nativeElement, radioGroup.classes.radio);
    }
    set value(val) {
        if (this._value !== val) {
            this._value = val;
        }
    }
    get value() { return this._value; }
    set color(val) {
        if (this._color !== val) {
            this._color = val;
            this[0x1] = this._styleRenderer.add(`${LyRadio.и}--color-${val}`, (theme, ref) => {
                const { checked, container } = ref.selectorsOf(STYLES);
                return (className) => `${className}${checked} ${container},${className}${checked} ${container} div:nth-child(1),${className} ${container} div:nth-child(2){color:${theme.colorOf(val)};}`;
            }, STYLE_PRIORITY, this[0x1]);
        }
    }
    get color() { return this._color; }
    set checked(val) {
        const newCheckedState = toBoolean(val);
        const before = this._checked;
        if (before !== newCheckedState) {
            this._checked = newCheckedState;
            if (!before && newCheckedState) {
                /** Add class checked */
                this._renderer.addClass(this._elementRef.nativeElement, this.classes.checked);
                if (this.value !== this.radioGroup.value) {
                    /** update Value */
                    this.radioGroup.updatevalue(this.value);
                }
            }
            else {
                /** Remove class checked */
                this._renderer.removeClass(this._elementRef.nativeElement, this.classes.checked);
            }
            this._markForCheck();
        }
    }
    get checked() {
        return this._checked;
    }
    /** @docs-private */
    get inputId() {
        return `${this.id}-input`;
    }
    get disabled() { return this._disabled; }
    set disabled(value) {
        const newVal = toBoolean(value);
        if (newVal) {
            this._renderer.addClass(this._elementRef.nativeElement, this.classes.disabled);
            this._disabledClass = this.classes.disabled;
        }
        else if (this._disabledClass) {
            this._renderer.removeClass(this._elementRef.nativeElement, this.classes.disabled);
            this._disabledClass = undefined;
        }
        this._disabled = toBoolean(value);
        this._markForCheck();
    }
    ngOnInit() {
        if (this.radioGroup) {
            // Copy name from parent radio group
            this.name = this.radioGroup.name;
        }
        if (!this.color) {
            this.color = this.radioGroup.color || DEFAULT_COLOR;
        }
    }
    ngAfterViewInit() {
        this._rippleContainer = this._radioContainer;
        // set default disable ripple
        if (this.disableRipple == null) {
            this.disableRipple = DEFAULT_DISABLE_RIPPLE;
        }
        const focusState = this._focusState.listen(this._input, this._elementRef);
        if (focusState) {
            focusState.subscribe((event) => {
                if (event === 'keyboard') {
                    this._renderer.addClass(this._elementRef.nativeElement, this.classes.onFocusByKeyboard);
                }
                else if (event == null) {
                    this._renderer.removeClass(this._elementRef.nativeElement, this.classes.onFocusByKeyboard);
                }
            });
        }
    }
    _markForCheck() {
        this.changeDetectorRef.markForCheck();
    }
    ngOnDestroy() {
        this._focusState.unlisten(this._elementRef);
        this._removeRippleEvents();
    }
    _onInputChange(event) {
        event.stopPropagation();
        this.radioGroup._updateCheckFromValue(this.value);
        this.radioGroup._touch();
        this._addAnim();
    }
    _addAnim() {
        if (!this._animClass) {
            this._renderer.addClass(this._elementRef.nativeElement, this.classes._animations);
            this._animClass = this.classes._animations;
        }
    }
    _onInputClick(event) { event.stopPropagation(); }
    _setCheckedToFalsy() {
        this.checked = false;
    }
}
LyRadio.ɵfac = function LyRadio_Factory(t) { return new (t || LyRadio)(ɵngcc0.ɵɵdirectiveInject(LyRadioGroup, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyCoreStyles), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyFocusState), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform)); };
LyRadio.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyRadio, selectors: [["ly-radio"]], viewQuery: function LyRadio_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(_c2, true);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._radioContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._labelContainer = _t.first);
    } }, inputs: { disableRipple: "disableRipple", value: "value", color: "color", checked: "checked", disabled: "disabled" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 10, vars: 11, consts: [[3, "className"], ["_labelContainer", ""], ["type", "radio", 3, "className", "id", "checked", "name", "disabled", "change", "click"], ["_input", ""], ["_radioContainer", ""]], template: function LyRadio_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "input", 2, 3);
        ɵngcc0.ɵɵlistener("change", function LyRadio_Template_input_change_2_listener($event) { return ctx._onInputChange($event); })("click", function LyRadio_Template_input_click_2_listener($event) { return ctx._onInputClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 0, 4);
        ɵngcc0.ɵɵelement(6, "div", 0);
        ɵngcc0.ɵɵelement(7, "div", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 0);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.classes.label);
        ɵngcc0.ɵɵattribute("for", ctx.inputId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("className", ctx._coreStyles.classes.visuallyHidden)("id", ctx.inputId)("checked", ctx.checked)("name", ctx.name)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("className", ctx.classes.container);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("className", ctx._coreStyles.classes.fill);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("className", ctx._coreStyles.classes.fill);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("className", ctx.classes.labelContent);
    } }, encapsulation: 2, changeDetection: 0 });
/** @docs-private */
LyRadio.и = 'LyRadio';
LyRadio.ctorParameters = () => [
    { type: LyRadioGroup, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: LyTheme2 },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: LyCoreStyles },
    { type: LyFocusState },
    { type: StyleRenderer },
    { type: Platform }
];
LyRadio.propDecorators = {
    _input: [{ type: ViewChild, args: ['_input',] }],
    _radioContainer: [{ type: ViewChild, args: ['_radioContainer',] }],
    _labelContainer: [{ type: ViewChild, args: ['_labelContainer',] }],
    change: [{ type: Output }],
    value: [{ type: Input }],
    color: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyRadio, [{
        type: Component,
        args: [{
                selector: 'ly-radio',
                template: "<label #_labelContainer [attr.for]=\"inputId\" [className]=\"classes.label\">\n  <input #_input\n    [className]=\"_coreStyles.classes.visuallyHidden\"\n    [id]=\"inputId\"\n    [checked]=\"checked\"\n    [name]=\"name\"\n    (change)=\"_onInputChange($event)\"\n    (click)=\"_onInputClick($event)\"\n    [disabled]=\"disabled\"\n    type=\"radio\"\n    >\n  <div #_radioContainer [className]=\"classes.container\">\n    <div [className]=\"_coreStyles.classes.fill\"></div>\n    <div [className]=\"_coreStyles.classes.fill\"></div>\n  </div>\n  <div\n  [className]=\"classes.labelContent\">\n    <ng-content></ng-content>\n  </div>\n</label>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                inputs: [
                    'disableRipple'
                ],
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: LyRadioGroup, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.LyCoreStyles }, { type: ɵngcc1.LyFocusState }, { type: ɵngcc1.StyleRenderer }, { type: ɵngcc2.Platform }]; }, { change: [{
            type: Output
        }], value: [{
            type: Input
        }], color: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], _input: [{
            type: ViewChild,
            args: ['_input']
        }], _radioContainer: [{
            type: ViewChild,
            args: ['_radioContainer']
        }], _labelContainer: [{
            type: ViewChild,
            args: ['_labelContainer']
        }] }); })();
class LyRadioModule {
}
LyRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LyRadioModule });
LyRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LyRadioModule_Factory(t) { return new (t || LyRadioModule)(); }, imports: [[CommonModule, FormsModule, LyCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LyRadioModule, { declarations: function () { return [LyRadioGroup,
        LyRadio]; }, imports: function () { return [CommonModule, FormsModule, LyCommonModule]; }, exports: function () { return [LyRadioGroup,
        LyRadio]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyRadioModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, LyCommonModule],
                exports: [LyRadioGroup, LyRadio],
                declarations: [LyRadioGroup, LyRadio]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { LY_RADIO_CONTROL_VALUE_ACCESSOR, LyRadio, LyRadioBase, LyRadioGroup, LyRadioMixinBase, LyRadioModule, STYLES, UndefinedValue };

//# sourceMappingURL=alyle-ui-radio.js.map