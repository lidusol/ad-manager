import { __decorate } from 'tslib';
import { Directive, TemplateRef, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Renderer2, ElementRef, ChangeDetectorRef, NgZone, ViewChild, Input, Output, ContentChildren, forwardRef, ViewChildren, ViewContainerRef, ContentChild, Optional, HostListener, NgModule } from '@angular/core';
import { st2c, StyleCollection, LY_COMMON_STYLES, mixinStyleUpdater, mixinBg, mixinElevation, mixinShadowColor, mixinColor, mixinRaised, mixinDisabled, mixinOutlined, mixinDisableRipple, toBoolean, XPosition, YPosition, AlignAlias, StyleRenderer, LyTheme2, Style, Dir, scrollWithAnimation, LyRippleService, LyFocusState, LyThemeModule, LyCommonModule, NgTranscludeModule } from '@alyle/ui';
import { LyButton } from '@alyle/ui/button';
import { Subscription, Subject } from 'rxjs';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Platform } from '@angular/cdk/platform';
import { TemplatePortal, PortalModule } from '@angular/cdk/portal';
import { switchMapTo, take, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alyle/ui';
import * as ɵngcc2 from '@angular/cdk/scrolling';
import * as ɵngcc3 from '@angular/cdk/platform';
import * as ɵngcc4 from '@angular/common';
import * as ɵngcc5 from '@angular/cdk/portal';

const _c0 = ["tabs"];
const _c1 = ["tabContents"];
const _c2 = ["tabsIndicator"];
const _c3 = ["tabContent"];
function LyTabs_div_9_ng_template_3_Template(rf, ctx) { }
function LyTabs_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 0, 5);
    ɵngcc0.ɵɵelementStart(2, "div", 0);
    ɵngcc0.ɵɵtemplate(3, LyTabs_div_9_ng_template_3_Template, 0, 0, "ng-template", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const x_r5 = ctx.index;
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("className", ctx_r3.classes.content);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("className", ctx_r3.classes.contentInner);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("cdkPortalOutlet", ctx_r3.loadTemplate(item_r4, x_r5));
} }
const _c4 = ["*"];
const _c5 = ["_templateNgContent"];
const _c6 = ["tabIndicator"];
function LyTab_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", null, 2);
} }
function LyTab_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3);
} }
const _c7 = [[["ly-tab-label"]], [["", "ly-tab-label", ""]], [["", "ly-tab-label-native", ""]], "*"];
const _c8 = ["ly-tab-label", "[ly-tab-label]", "[ly-tab-label-native]", "*"];
const _c9 = ["rippleContainer"];
const _c10 = ["ly-tab-label", ""];
function LyTabLabel_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 0, 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("className", ctx_r0._rippleService.classes.container);
} }
class LyTabContent {
    constructor(template) {
        this.template = template;
    }
}
LyTabContent.ɵfac = function LyTabContent_Factory(t) { return new (t || LyTabContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
LyTabContent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LyTabContent, selectors: [["", "ly-tab-content", ""]] });
LyTabContent.ctorParameters = () => [
    { type: TemplateRef }
];

const DEFAULT_DISABLE_RIPPLE = false;
const STYLE_PRIORITY = -2;
const DEFAULT_BG = 'primary';
const DEFAULT_INDICATOR_COLOR = 'accent';
const DEFAULT_ELEVATION = 4;
const DEFAULT_HEADER_PLACEMENT = 'above';
const STYLES = (theme, ref) => {
    const __ = ref.selectorsOf(STYLES);
    return {
        $name: LyTabs.и,
        $priority: STYLE_PRIORITY,
        root: () => (className) => `${className}{display:flex;}${st2c(((theme.tab
            && theme.tab.root
            && (theme.tab.root instanceof StyleCollection
                ? theme.tab.root.setTransformer(fn => fn(__)).css
                : theme.tab.root(__)))), `${className}`)}`,
        tab: (className) => `${className}{position:relative;display:inline-flex;}`,
        /** Tab container */
        contentContainer: (className) => `${className}{display:flex;overflow:hidden;flex-grow:1;width:100%;position:relative;}`,
        /** Tab header */
        labels: (className) => `${className}{display:flex;position:relative;height:100%;}`,
        labelsContainer: () => (className) => `${className}{overflow:hidden;flex-shrink:0;}@media (hover: none){${__.scrollable} ${className}{overflow:auto;}}`,
        label: (className) => `${className}{-webkit-tap-highlight-color:transparent;-webkit-appearance:none;background-color:transparent;user-select:none;border:0;min-width:72px;padding:0 24px;cursor:pointer;height:48px;display:inline-flex;justify-content:center;align-items:center;position:relative;overflow:hidden;font-family:${theme.typography.fontFamily};font-size:${theme.pxToRem(theme.typography.fontSize)};letter-spacing:0.02857em;color:currentColor;outline:none;width:100%;font-weight:500;opacity:.7;}@media ${theme.breakpoints['XSmall']}{${className}{padding:0 12px;}}`,
        labelActive: (className) => `${className}{opacity:1;}`,
        contents: (className) => `${className}{display:flex;width:100%;}`,
        content: (className) => `${st2c((LY_COMMON_STYLES.fill), `${className}`)}${className}{width:100%;height:100%;position:absolute;overflow:auto;}`,
        contentActive: (className) => `${className}{position:relative;z-index:1;}`,
        contentInner: null,
        indicator: (className) => `${className}{position:absolute;height:2px;transition:450ms cubic-bezier(.1, 1, 0.5, 1);background:currentColor;}`,
        indicatorForServer: (className) => `${className}{position:absolute;background:currentColor;}`,
        rippleContainer: (className) => `${st2c((LY_COMMON_STYLES.fill), `${className}`)}${className}{overflow:hidden;}`,
        scrollable: null,
        hiddenContent: () => (className) => `${className}{visibility:hidden;}`,
        column: null,
        row: null
    };
};
/** @docs-private */
class LyTabsBase {
    constructor(_theme) {
        this._theme = _theme;
    }
}
/** @docs-private */
const LyTabsMixinBase = mixinStyleUpdater(mixinBg(mixinElevation(mixinShadowColor(LyTabsBase))));
/** @docs-private */
class LyTabLabelBase {
    constructor(_theme, _ngZone, _platform) {
        this._theme = _theme;
        this._ngZone = _ngZone;
        this._platform = _platform;
    }
}
/** @docs-private */
const LyTabLabelMixinBase = mixinStyleUpdater(mixinBg(mixinColor(mixinRaised(mixinDisabled(mixinOutlined(mixinElevation(mixinShadowColor(mixinDisableRipple(LyTabLabelBase)))))))));
const ɵ0 = val => (theme, ref) => {
    const __ = ref.selectorsOf(STYLES);
    return (className) => `${className} ${__.indicator}{color:${theme.colorOf(val)};}`;
};
/**
 * @dynamic
 */
class LyTabs extends LyTabsMixinBase {
    constructor(theme, renderer, el, cd, _viewportRuler, sRenderer, _platform, _ngZone) {
        super(theme);
        this.theme = theme;
        this.renderer = renderer;
        this.el = el;
        this.cd = cd;
        this._viewportRuler = _viewportRuler;
        this.sRenderer = sRenderer;
        this._platform = _platform;
        this._ngZone = _ngZone;
        /** @docs-private */
        this.$priority = STYLE_PRIORITY;
        /** @docs-private */
        this.classes = this.sRenderer.renderSheet(STYLES, true);
        this._tabsSubscription = Subscription.EMPTY;
        this._timeoutIds = {};
        /** Emits whenever the component is destroyed. */
        this._destroy = new Subject();
        this.selectedIndexOnChange = 'auto';
        this.selectedIndexChange = new EventEmitter();
        this.setAutoContrast();
        this.animationDuration = 500;
    }
    /**
     * Keep the content.
     * By default, when changing a tab, the previous one is created and deleted.
     * With this, the content will only be hidden instead of deleting it.
     */
    set keepContent(val) {
        const newVal = toBoolean(val);
        this._keepContent = newVal;
    }
    get keepContent() {
        return this._keepContent;
    }
    /** Animation duration in milliseconds */
    set animationDuration(val) {
        this._animationDuration = val;
        Promise.resolve().then(() => {
            this.tabContents.nativeElement.style.transitionDuration = `${val}ms`;
        });
    }
    get animationDuration() {
        return this._animationDuration;
    }
    /**
     * Whether the tab group should grow to the size of the active tab.
     */
    set dynamicHeight(val) {
        const newVal = toBoolean(val);
        this._dynamicHeight = newVal;
    }
    get dynamicHeight() {
        return this._dynamicHeight;
    }
    set scrollable(val) {
        const newVal = toBoolean(val);
        if (newVal) {
            this.renderer.addClass(this.el.nativeElement, this.classes.scrollable);
        }
        else if (this._scrollable != null) {
            this.renderer.removeClass(this.el.nativeElement, this.classes.scrollable);
        }
        this._scrollable = newVal;
    }
    get scrollable() {
        return this._scrollable;
    }
    set headerPlacement(val) {
        if (val !== this.headerPlacement) {
            this._headerPlacement = val;
            this.sRenderer.toggleClass(this.classes.column, val === 'above' || val === 'below');
            this.sRenderer.toggleClass(this.classes.row, val === 'before' || val === 'after');
            this._headerPlacementClass = this.theme.addStyle(`lyTabs.headerPlacement:${val}`, () => {
                let flexDirectionContainer;
                let flexDirection = this._getFlexDirection(val);
                let position;
                let height = null;
                let width = null;
                let heightServer = null;
                let widthServer = null;
                switch (val) {
                    case YPosition.above:
                        flexDirectionContainer = 'column';
                        position = YPosition.below;
                        height = '2px';
                        widthServer = '100%';
                        break;
                    case YPosition.below:
                        flexDirectionContainer = 'column-reverse';
                        position = YPosition.above;
                        height = '2px';
                        widthServer = '100%';
                        break;
                    case XPosition.before:
                        flexDirectionContainer = 'row';
                        position = XPosition.after;
                        width = '2px';
                        heightServer = '100%';
                        break;
                    case XPosition.after:
                        flexDirectionContainer = 'row-reverse';
                        position = XPosition.before;
                        width = '2px';
                        heightServer = '100%';
                        break;
                    default:
                        throw new Error(`LyTabs: value:${val} do not is valid for \`headerPlacement\``);
                }
                if (val === YPosition.above || val === YPosition.below) {
                    flexDirection = 'row';
                }
                else {
                    flexDirection = 'column';
                }
                return {
                    [`&`]: {
                        flexDirection: flexDirectionContainer
                    },
                    [`& .${this.classes.indicator},& .${this.classes.indicatorForServer}`]: {
                        [position]: 0,
                        height,
                        width
                    },
                    [`.${this.classes.indicatorForServer}`]: {
                        width: widthServer,
                        height: heightServer
                    },
                    [`& .${this.classes.labels},& .${this.classes.contents}`]: { flexDirection },
                    [`.${this.classes.contents}`]: { flexDirection }
                };
            }, this.el.nativeElement, this._headerPlacementClass, STYLE_PRIORITY);
        }
    }
    get headerPlacement() {
        return this._headerPlacement;
    }
    set alignTabs(val) {
        this._alignTabs = val;
        this._alignTabsClass = this.theme.addStyle(`lyAlignTabs: ${val}`, (val === 'stretch' ? {
            [`& .${this.classes.labels} .${this.classes.tab}`]: {
                flexBasis: 0,
                flexGrow: 1
            }
        } : {
            [`& .${this.classes.labels}`]: {
                justifyContent: val in AlignAlias ? AlignAlias[val] : val
            }
        }), this.el.nativeElement, this._alignTabsClass, STYLE_PRIORITY);
    }
    get alignTabs() {
        return this._alignTabs;
    }
    set textColor(val) {
        this._textColor = val;
        this._textColorClass = this.theme.addStyle(`lyTabs.textColor:${val}`, (theme) => ({
            [`& .${this.classes.labelActive}`]: {
                color: theme.colorOf(val)
            }
        }), this.el.nativeElement, this._textColorClass, STYLE_PRIORITY);
    }
    get textColor() {
        return this._textColor;
    }
    set selectedIndex(val) {
        if (val !== this.selectedIndex) {
            this._selectedBeforeIndex = this._selectedIndex;
            this._selectedIndex = this._findIndex(val, 'auto');
            this._selectedBeforeTab = this._selectedTab;
            if (this._isViewInitLoaded) {
                this._updateTabs();
            }
            else {
                Promise.resolve(null).then(() => this._updateTabs());
            }
            this.selectedIndexChange.emit(this._selectedIndex);
            this._markForCheck();
        }
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    ngOnChanges() {
        if (this._isViewInitLoaded) {
            this.updateStyle(this.tabsRef.nativeElement);
        }
    }
    ngOnInit() {
        if (this.selectedIndex == null) {
            this.selectedIndex = 0;
        }
        this.renderer.addClass(this.el.nativeElement, this.classes.root);
        const tabsIndicatorEl = this.tabsIndicator.nativeElement;
        this.renderer.addClass(tabsIndicatorEl, this.classes.indicator);
        /** Set default Color */
        if (!this.indicatorColor && !this.bg && !this.textColor && !this.elevation) {
            this.indicatorColor = DEFAULT_INDICATOR_COLOR;
            this.bg = DEFAULT_BG;
            this.elevation = DEFAULT_ELEVATION;
        }
        if (!this.headerPlacement) {
            this.headerPlacement = DEFAULT_HEADER_PLACEMENT;
        }
    }
    ngAfterContentInit() {
        this._tabsSubscription = this.tabsList.changes.subscribe(() => {
            if (this._selectedIndex !== this.selectedIndexOnChange) {
                this.selectedIndex = this._findIndex(this.selectedIndex, this.selectedIndexOnChange);
            }
            this.cd.markForCheck();
        });
    }
    ngAfterViewInit() {
        this._isViewInitLoaded = true;
        this.tabsList.changes
            .pipe(switchMapTo(this._ngZone.onStable.asObservable().pipe(take(1))), takeUntil(this._destroy))
            .subscribe(() => {
            this._updateTabs();
        });
        this._updateTabs();
        this.updateStyle(this.tabsRef.nativeElement);
        if (this._platform.isBrowser) {
            this._tabResizeSub = this._viewportRuler.change().subscribe(() => {
                if (this._selectedTab) {
                    this._updateIndicator(this._selectedTab);
                    this._selectedTab._tabLabel._updateTabScroll();
                }
            });
        }
    }
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
        this._tabsSubscription.unsubscribe();
        if (this._tabResizeSub) {
            this._tabResizeSub.unsubscribe();
        }
        this._clearTimeouts();
    }
    _findIndex(selectedIndex, index) {
        if (!this.tabsList) {
            return selectedIndex;
        }
        const indexOfLastTab = this.tabsList.length - 1;
        const currentIndex = typeof index === 'number' ? index : selectedIndex;
        return currentIndex < 0 ? 0 : currentIndex > indexOfLastTab ? indexOfLastTab : currentIndex;
    }
    _updateIndicator(currentTab, beforeTab) {
        if (currentTab) {
            if (beforeTab) {
                beforeTab._renderer.removeAttribute(beforeTab._tabIndicator.nativeElement, 'class');
            }
            const el = currentTab._el.nativeElement;
            const rects = el.getBoundingClientRect();
            if (this.headerPlacement === XPosition.after || this.headerPlacement === XPosition.before) {
                this.renderer.setStyle(this.tabsIndicator.nativeElement, 'height', `${rects.height}px`);
                this.renderer.setStyle(this.tabsIndicator.nativeElement, 'top', `${el.offsetTop}px`);
                this.renderer.removeStyle(this.tabsIndicator.nativeElement, 'width');
                this.renderer.removeStyle(this.tabsIndicator.nativeElement, 'left');
            }
            else {
                this.renderer.setStyle(this.tabsIndicator.nativeElement, 'width', `${rects.width}px`);
                this.renderer.setStyle(this.tabsIndicator.nativeElement, 'left', `${el.offsetLeft}px`);
                this.renderer.removeStyle(this.tabsIndicator.nativeElement, 'height');
                this.renderer.removeStyle(this.tabsIndicator.nativeElement, 'top');
            }
        }
    }
    _markForCheck() {
        this.cd.markForCheck();
    }
    _updateTabs() {
        if (!this._isViewInitLoaded) {
            return;
        }
        const tabsContents = this.tabContentList.toArray();
        const tabsForUpdate = [];
        this.tabsList.forEach((tab, index) => {
            const tabContent = tabsContents[index].nativeElement;
            if (this.selectedIndex === index || this._selectedBeforeIndex === index) {
                tab._activeContent = true;
                tabsForUpdate.push([tab, tabContent, index]);
            }
            else {
                if (this.keepContent) {
                    this.renderer.addClass(tabContent, this.classes.hiddenContent);
                }
            }
        });
        this._ngZone.run(() => {
            this._markForCheck();
        });
        this._ngZone.onStable.asObservable()
            .pipe(take(1), takeUntil(this._destroy))
            .subscribe(() => tabsForUpdate.forEach(parms => this._updateContentStyle(...parms)));
    }
    loadTemplate(tab, index) {
        tab.index = index;
        if (this.selectedIndex === tab.index) {
            // set 0 if is null
            this._selectedTab = tab;
            Promise.resolve(null).then(() => {
                // this._updateDynamicHeight(tabContent, index);
                if (this._platform.isBrowser) {
                    this._updateIndicator(tab);
                }
                else {
                    // for server
                    const selectedBeforeTab = this._selectedBeforeTab;
                    if (selectedBeforeTab) {
                        this.renderer.removeClass(selectedBeforeTab._tabIndicator.nativeElement, this.classes.indicatorForServer);
                    }
                    this.renderer.addClass(this._selectedTab._tabIndicator.nativeElement, this.classes.indicatorForServer);
                }
            });
        }
        else if (this._selectedBeforeIndex === index) {
            // Promise.resolve(null).then(() => this._updateDynamicHeight(tabContent, index));
        }
        tab._tabLabel._updateTabState();
        if (this.keepContent) {
            return tab.content;
        }
        if (tab._activeContent) {
            return tab.content;
        }
        return null;
    }
    _getFlexDirection(val) {
        let flexDirection;
        if (val === YPosition.above || val === YPosition.below) {
            flexDirection = 'row';
        }
        else {
            flexDirection = 'column';
        }
        return flexDirection;
    }
    _updateContentStyle(tab, tabContent, index) {
        if (this.selectedIndex === index || this._selectedBeforeIndex === index) {
            const prevIndex = this._selectedBeforeIndex;
            const currentIndex = this.selectedIndex;
            const dynamicHeight = this.dynamicHeight && this._platform.isBrowser && prevIndex != null;
            const contentInner = tabContent.firstElementChild;
            const contentHeight = dynamicHeight ? contentInner.getBoundingClientRect().height : null;
            const contentHeightPrev = dynamicHeight
                ? this.tabContentList.toArray()[prevIndex].nativeElement.firstElementChild.getBoundingClientRect().height
                : null;
            if (currentIndex === index) {
                this.renderer.addClass(tabContent, this.classes.contentActive);
                if (this.keepContent) {
                    this.renderer.removeClass(tabContent, this.classes.hiddenContent);
                }
            }
            else {
                this.renderer.removeClass(tabContent, this.classes.contentActive);
            }
            if (prevIndex == null || !this._platform.isBrowser || prevIndex === currentIndex) {
                return;
            }
            this._clearTimeouts(index);
            const { before } = this._theme.variables;
            const isDirRow = this.headerPlacement === XPosition.after
                || this.headerPlacement === XPosition.before;
            const x = before === 'left'
                ? 100
                : isDirRow
                    ? 100
                    : -100;
            if (currentIndex === index) {
                const sign = prevIndex < index ? 1 : -1;
                const pos = isDirRow ? `0,${x * sign}%` : `${x * sign}%, 0`;
                tabContent.style.overflow = 'hidden';
                if (dynamicHeight) {
                    tabContent.style.height = `${contentHeightPrev}px`;
                }
                tabContent.style.transform = `translate3d(${pos}, 0)`;
                enforceStyleRecalculation(tabContent);
                tabContent.style.transition = `${this.animationDuration}ms cubic-bezier(0.35, 0, 0.25, 1)`;
                tabContent.style.transform = `translate3d(0%, 0, 0)`;
                if (dynamicHeight) {
                    tabContent.style.height = `${contentHeight}px`;
                }
            }
            else {
                const sign = currentIndex < index ? 1 : -1;
                const pos = isDirRow ? `0,${x * sign}%` : `${x * sign}%, 0`;
                tabContent.style.overflow = 'hidden';
                tabContent.style.transform = `translate3d(0%, 0, 0)`;
                enforceStyleRecalculation(tabContent);
                tabContent.style.transition = `${this.animationDuration}ms cubic-bezier(0.35, 0, 0.25, 1)`;
                tabContent.style.transform = `translate3d(${pos}, 0)`;
            }
            this._runTimeoutOutsideZone(index, () => {
                tabContent.style.transform = ``;
                tabContent.style.transition = ``;
                tabContent.style.overflow = ``;
                if (dynamicHeight) {
                    tabContent.style.height = ``;
                }
                if (currentIndex !== index) {
                    if (this.keepContent) {
                        this.renderer.addClass(tabContent, this.classes.hiddenContent);
                    }
                    tab._activeContent = false;
                    this._ngZone.run(() => this._markForCheck());
                }
            }, this.animationDuration);
        }
    }
    /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */
    _runTimeoutOutsideZone(index, fn, delay = 0) {
        this._ngZone.runOutsideAngular(() => this._timeoutIds[`_${index}`] = window.setTimeout(fn, delay));
    }
    _clearTimeouts(tabIndex) {
        if (tabIndex != null) {
            const key = `_${tabIndex}`;
            if (this._timeoutIds[key] != null) {
                window.clearTimeout(this._timeoutIds[key]);
                delete this._timeoutIds[key];
            }
        }
        else {
            Object.keys(this._timeoutIds)
                .forEach(key => window.clearTimeout(this._timeoutIds[`_${key}`]));
        }
    }
}
LyTabs.ɵfac = function LyTabs_Factory(t) { return new (t || LyTabs)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
LyTabs.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyTabs, selectors: [["ly-tabs"]], contentQueries: function LyTabs_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LyTab, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsList = _t);
    } }, viewQuery: function LyTabs_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵstaticViewQuery(_c1, true);
        ɵngcc0.ɵɵstaticViewQuery(_c2, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c3, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabContents = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabContentList = _t);
    } }, inputs: { bg: "bg", elevation: "elevation", shadowColor: "shadowColor", selectedIndexOnChange: "selectedIndexOnChange", animationDuration: "animationDuration", keepContent: "keepContent", dynamicHeight: "dynamicHeight", scrollable: "scrollable", headerPlacement: "headerPlacement", alignTabs: "alignTabs", textColor: "textColor", selectedIndex: "selectedIndex", indicatorColor: "indicatorColor" }, outputs: { selectedIndexChange: "selectedIndexChange" }, exportAs: ["lyTabs"], features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c4, decls: 10, vars: 5, consts: [[3, "className"], ["tabs", ""], ["tabsIndicator", ""], ["tabContents", ""], [3, "className", 4, "ngFor", "ngForOf"], ["tabContent", ""], [3, "cdkPortalOutlet"]], template: function LyTabs_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelement(4, "span", null, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 0);
        ɵngcc0.ɵɵelementStart(7, "div", 0, 3);
        ɵngcc0.ɵɵtemplate(9, LyTabs_div_9_Template, 4, 3, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.classes.labelsContainer);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("className", ctx.classes.labels);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("className", ctx.classes.contentContainer);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("className", ctx.classes.contents);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabsList);
    } }, directives: [ɵngcc4.NgForOf, ɵngcc5.CdkPortalOutlet], encapsulation: 2, changeDetection: 0 });
/** @docs-private */
LyTabs.и = 'LyTabs';
LyTabs.ctorParameters = () => [
    { type: LyTheme2 },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: ViewportRuler },
    { type: StyleRenderer },
    { type: Platform },
    { type: NgZone }
];
LyTabs.propDecorators = {
    tabsRef: [{ type: ViewChild, args: ['tabs', { static: true },] }],
    tabContents: [{ type: ViewChild, args: ['tabContents', { static: true },] }],
    tabsIndicator: [{ type: ViewChild, args: ['tabsIndicator', { static: true, read: ElementRef },] }],
    selectedIndexOnChange: [{ type: Input }],
    keepContent: [{ type: Input }],
    animationDuration: [{ type: Input }],
    dynamicHeight: [{ type: Input }],
    scrollable: [{ type: Input }],
    indicatorColor: [{ type: Input }],
    headerPlacement: [{ type: Input }],
    alignTabs: [{ type: Input }],
    textColor: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    selectedIndexChange: [{ type: Output }],
    tabsList: [{ type: ContentChildren, args: [forwardRef(() => LyTab),] }],
    tabContentList: [{ type: ViewChildren, args: ['tabContent',] }]
};
__decorate([
    Style(ɵ0)
], LyTabs.prototype, "indicatorColor", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTabContent, [{
        type: Directive,
        args: [{ selector: '[ly-tab-content]' }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTabs, [{
        type: Component,
        args: [{
                selector: 'ly-tabs',
                template: "<div #tabs [className]=\"classes.labelsContainer\">\n  <div [className]=\"classes.labels\">\n    <ng-content></ng-content>\n    <span #tabsIndicator></span>\n  </div>\n</div>\n<div [className]=\"classes.contentContainer\">\n  <div [className]=\"classes.contents\" #tabContents>\n    <div #tabContent *ngFor=\"let item of tabsList; index as x\" [className]=\"classes.content\">\n      <div [className]=\"classes.contentInner\">\n        <ng-template\n          [cdkPortalOutlet]=\"loadTemplate(item, x)\"\n        ></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                exportAs: 'lyTabs',
                inputs: [
                    'bg', 'elevation', 'shadowColor'
                ],
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.ViewportRuler }, { type: ɵngcc1.StyleRenderer }, { type: ɵngcc3.Platform }, { type: ɵngcc0.NgZone }]; }, { selectedIndexOnChange: [{
            type: Input
        }], selectedIndexChange: [{
            type: Output
        }], animationDuration: [{
            type: Input
        }], keepContent: [{
            type: Input
        }], dynamicHeight: [{
            type: Input
        }], scrollable: [{
            type: Input
        }], headerPlacement: [{
            type: Input
        }], alignTabs: [{
            type: Input
        }], textColor: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], indicatorColor: [{
            type: Input
        }], tabsRef: [{
            type: ViewChild,
            args: ['tabs', { static: true }]
        }], tabContents: [{
            type: ViewChild,
            args: ['tabContents', { static: true }]
        }], tabsIndicator: [{
            type: ViewChild,
            args: ['tabsIndicator', { static: true, read: ElementRef }]
        }], tabsList: [{
            type: ContentChildren,
            args: [forwardRef(() => LyTab)]
        }], tabContentList: [{
            type: ViewChildren,
            args: ['tabContent']
        }] }); })();
class LyTab {
    constructor(_tabs, _renderer, _el, sRenderer, _platform, _viewContainerRef) {
        this._tabs = _tabs;
        this._renderer = _renderer;
        this._el = _el;
        this.sRenderer = sRenderer;
        this._platform = _platform;
        this._viewContainerRef = _viewContainerRef;
        this._isBrowser = this._platform.isBrowser;
        /** Portal that will be the hosted content of the tab */
        this._contentPortal = null;
    }
    /** @docs-private */
    get content() {
        return this._contentPortal;
    }
    ngOnInit() {
        this._renderer.addClass(this._el.nativeElement, this._tabs.classes.tab);
        this._contentPortal = new TemplatePortal(this._templateRefLazy || this._templateRef, this._viewContainerRef);
    }
}
LyTab.ɵfac = function LyTab_Factory(t) { return new (t || LyTab)(ɵngcc0.ɵɵdirectiveInject(LyTabs), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
LyTab.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyTab, selectors: [["ly-tab"]], contentQueries: function LyTab_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, LyTabContent, true, TemplateRef);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, LyTabLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._templateRefLazy = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabLabel = _t.first);
    } }, viewQuery: function LyTab_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(_c6, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._templateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._tabIndicator = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ])], ngContentSelectors: _c8, decls: 7, vars: 1, consts: [[4, "ngIf"], ["_templateNgContent", ""], ["tabIndicator", ""]], template: function LyTab_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵprojection(2, 2);
        ɵngcc0.ɵɵelement(3, "div");
        ɵngcc0.ɵɵtemplate(4, LyTab_span_4_Template, 2, 0, "span", 0);
        ɵngcc0.ɵɵtemplate(5, LyTab_ng_template_5_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isBrowser);
    } }, directives: [ɵngcc4.NgIf], encapsulation: 2, changeDetection: 0 });
LyTab.ctorParameters = () => [
    { type: LyTabs },
    { type: Renderer2 },
    { type: ElementRef },
    { type: StyleRenderer },
    { type: Platform },
    { type: ViewContainerRef }
];
LyTab.propDecorators = {
    _templateRefLazy: [{ type: ContentChild, args: [LyTabContent, { read: TemplateRef, static: true },] }],
    _templateRef: [{ type: ViewChild, args: ['_templateNgContent', { static: true },] }],
    _tabIndicator: [{ type: ViewChild, args: ['tabIndicator',] }],
    _tabLabel: [{ type: ContentChild, args: [forwardRef(() => LyTabLabel), { static: true },] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTab, [{
        type: Component,
        args: [{
                selector: 'ly-tab',
                template: "<ng-content select=\"ly-tab-label\"></ng-content>\n<ng-content select=\"[ly-tab-label]\"></ng-content>\n<ng-content select=\"[ly-tab-label-native]\"></ng-content>\n<div></div>\n<span *ngIf=\"!_isBrowser\" #tabIndicator></span>\n<ng-template #_templateNgContent>\n  <ng-content></ng-content>\n</ng-template>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: LyTabs }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.StyleRenderer }, { type: ɵngcc3.Platform }, { type: ɵngcc0.ViewContainerRef }]; }, { _templateRefLazy: [{
            type: ContentChild,
            args: [LyTabContent, { read: TemplateRef, static: true }]
        }], _templateRef: [{
            type: ViewChild,
            args: ['_templateNgContent', { static: true }]
        }], _tabIndicator: [{
            type: ViewChild,
            args: ['tabIndicator']
        }], _tabLabel: [{
            type: ContentChild,
            args: [forwardRef(() => LyTabLabel), { static: true }]
        }] }); })();
class LyTabLabel extends LyButton {
    constructor(_el, _renderer, _theme, _ngZone, _rippleService, _focusState, sRenderer, _tab, _tabs, platform) {
        super(_el, _renderer, _theme, _ngZone, _rippleService, _focusState, sRenderer, platform, null);
        this.sRenderer = sRenderer;
        this._tab = _tab;
        this._tabs = _tabs;
        this._isBrowser = this._platform.isBrowser;
    }
    get active() {
        return this._active;
    }
    set active(val) {
        const newVal = toBoolean(val);
        if (newVal && val !== this.active) {
            Promise.resolve(null).then(() => this._tabs.selectedIndex = this._tab.index);
        }
    }
    _onClickTab() {
        if (!this.disabled) {
            this._tabs.selectedIndex = this._tab.index;
        }
    }
    ngOnInit() {
        this._renderer.addClass(this._el.nativeElement, this._tabs.classes.label);
        // set default disable ripple
        if (this.disableRipple == null) {
            this.disableRipple = DEFAULT_DISABLE_RIPPLE;
        }
    }
    _updateTabState() {
        // update styles for active tab
        if (this._tabs._selectedIndex === this._tab.index) {
            if (!this._activeTabStyle) {
                this._activeTabStyle = true;
                this._renderer.addClass(this._el.nativeElement, this._tabs.classes.labelActive);
                this._updateTabScroll();
            }
        }
        else if (this._activeTabStyle) {
            this._activeTabStyle = false;
            this._renderer.removeClass(this._el.nativeElement, this._tabs.classes.labelActive);
        }
    }
    _updateTabScroll() {
        if (this._platform.isBrowser && this._tabs.scrollable) {
            const tab = this._tab._el.nativeElement;
            const tabContainer = this._tabs.tabsRef.nativeElement;
            if (tabContainer.scrollWidth !== tabContainer.offsetWidth) {
                const dir = this._theme.variables.direction;
                const max = tabContainer.scrollWidth - tabContainer.offsetWidth;
                const offsetBefore = dir === Dir.rtl
                    ? max + tab.offsetLeft
                    : tab.offsetLeft;
                const l = offsetBefore + tab.offsetWidth / 2 - tabContainer.offsetWidth / 2;
                const newVal = l >= max ? max : l <= 0 ? 0 : l;
                scrollWithAnimation(this._tabs.tabsRef.nativeElement, newVal, 350, 'x');
            }
        }
    }
    ngAfterViewInit() { }
}
LyTabLabel.ɵfac = function LyTabLabel_Factory(t) { return new (t || LyTabLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyRippleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyFocusState), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(LyTab, 8), ɵngcc0.ɵɵdirectiveInject(LyTabs, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform)); };
LyTabLabel.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyTabLabel, selectors: [["button", "ly-tab-label", ""], ["a", "ly-tab-label", ""]], viewQuery: function LyTabLabel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rippleContainer = _t.first);
    } }, hostBindings: function LyTabLabel_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function LyTabLabel_click_HostBindingHandler() { return ctx._onClickTab(); });
    } }, inputs: { bg: "bg", color: "color", raised: "raised", disabled: "disabled", outlined: "outlined", elevation: "elevation", shadowColor: "shadowColor", disableRipple: "disableRipple", active: "active" }, features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c10, ngContentSelectors: _c4, decls: 3, vars: 2, consts: [[3, "className"], [3, "className", 4, "ngIf"], ["rippleContainer", ""]], template: function LyTabLabel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, LyTabLabel_div_2_Template, 2, 1, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.classes.content);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx._isBrowser);
    } }, directives: [ɵngcc4.NgIf], encapsulation: 2 });
LyTabLabel.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LyTheme2 },
    { type: NgZone },
    { type: LyRippleService },
    { type: LyFocusState },
    { type: StyleRenderer },
    { type: LyTab, decorators: [{ type: Optional }] },
    { type: LyTabs, decorators: [{ type: Optional }] },
    { type: Platform }
];
LyTabLabel.propDecorators = {
    active: [{ type: Input }],
    _rippleContainer: [{ type: ViewChild, args: ['rippleContainer',] }],
    _onClickTab: [{ type: HostListener, args: ['click',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTabLabel, [{
        type: Component,
        args: [{
                selector: 'button[ly-tab-label], a[ly-tab-label]',
                template: "<span [className]=\"classes.content\">\n  <ng-content></ng-content>\n</span>\n<div *ngIf=\"_isBrowser\" #rippleContainer [className]=\"_rippleService.classes.container\"></div>\n",
                inputs: [
                    'bg',
                    'color',
                    'raised',
                    'disabled',
                    'outlined',
                    'elevation',
                    'shadowColor',
                    'disableRipple'
                ],
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.NgZone }, { type: ɵngcc1.LyRippleService }, { type: ɵngcc1.LyFocusState }, { type: ɵngcc1.StyleRenderer }, { type: LyTab, decorators: [{
                type: Optional
            }] }, { type: LyTabs, decorators: [{
                type: Optional
            }] }, { type: ɵngcc3.Platform }]; }, { active: [{
            type: Input
        }], _onClickTab: [{
            type: HostListener,
            args: ['click']
        }], _rippleContainer: [{
            type: ViewChild,
            args: ['rippleContainer']
        }] }); })();
/** Enforces a style recalculation of a DOM element by computing its styles. */
function enforceStyleRecalculation(element) {
    window.getComputedStyle(element).getPropertyValue('opacity');
}

class LyTabsModule {
}
LyTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LyTabsModule });
LyTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LyTabsModule_Factory(t) { return new (t || LyTabsModule)(); }, imports: [[
            LyThemeModule,
            CommonModule,
            LyCommonModule,
            NgTranscludeModule,
            PortalModule
        ],
        LyCommonModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LyTabsModule, { declarations: function () { return [LyTabs,
        LyTab,
        LyTabLabel,
        LyTabContent]; }, imports: function () { return [LyThemeModule,
        CommonModule,
        LyCommonModule,
        NgTranscludeModule,
        PortalModule]; }, exports: function () { return [LyCommonModule,
        LyTabs,
        LyTab,
        LyTabLabel,
        LyTabContent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTabsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    LyThemeModule,
                    CommonModule,
                    LyCommonModule,
                    NgTranscludeModule,
                    PortalModule
                ],
                exports: [LyCommonModule, LyTabs, LyTab, LyTabLabel, LyTabContent],
                declarations: [LyTabs, LyTab, LyTabLabel, LyTabContent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { LyTab, LyTabLabel, LyTabLabelBase, LyTabLabelMixinBase, LyTabs, LyTabsBase, LyTabsMixinBase, LyTabsModule, STYLES, ɵ0, LyTabContent as ɵa };

//# sourceMappingURL=alyle-ui-tabs.js.map