{"version":3,"sources":["../../../lib/image-cropper/resize-canvas.ts","../../../lib/image-cropper/image-cropper.ts","../../../../node_modules/tslib/tslib.es6.js","../../../lib/image-cropper/image-cropper-area.ts","../../../lib/image-cropper/image-cropper.module.ts"],"names":["resizeCanvas","canvas","width","height","width_source","height_source","ratio_w","Math","round","ratio_h","ratio_w_half","ceil","ratio_h_half","ctx","getContext","img","getImageData","img2","createImageData","data","data2","j","i","x2","weight","weights","weights_alpha","gx_r","gx_g","gx_b","gx_a","center_y","xx_start","floor","xx_stop","yy_start","yy_stop","min","yy","dy","abs","center_x","w0","xx","dx","w","sqrt","pos_x","putImageData","ImgResolution","ImgCropperError","activeEventOptions","normalizePassiveListenerOptions","passive","STYLES","theme","ref","cropper","selectorsOf","after","$name","LyImageCropper","и","$priority","root","className","st2c","StyleCollection","setTransformer","fn","imgContainer","overlay","LY_COMMON_STYLES","area","resizer","defaultContent","this","minWidth","minHeight","antiAliased","output","Default","sRenderer","_renderer","_elementRef","cd","_ngZone","_document","viewPortRuler","_this","classes","renderSheet","_imgRect","_rotation","scaleChange","EventEmitter","minScaleChange","maxScaleChange","loaded","imageLoaded","ready","cropped","cleaned","error","_destroy","Subject","_pointerDown","event","_isSliding","isTouchEvent","button","run","offset","x","y","left","xc","top","yc","_lastPointerEvent","_startPointerEvent","getGesturePointFromEvent","preventDefault","_bindGlobalEvents","_pointerMove","_imgCanvas","nativeElement","scaleFix","_scal3Fix","config","startP","point","deltaX","deltaY","isMinScaleY","extraZoomOut","isMinScaleX","limitLeft","limitRight","limitTop","limitBottom","_setStylesForContImg","_pointerUp","_removeGlobalEvents","_cropIfAutoCrop","_windowBlur","change","pipe","takeUntil","subscribe","updateCropperPosition","Object","defineProperty","prototype","_config","val","mergeDeep","ImgCropperConfig","_configPrimary","_primaryAreaWidth","_primaryAreaHeight","Error","maxFileSize","_scale","setScale","_minScale","ngOnInit","runOutsideAngular","element","_imgContainer","addEventListener","ngOnDestroy","next","complete","removeEventListener","_imgLoaded","imgElement","_img","clearRect","drawImage","_updateMinScale","_updateMaxScale","values","newStyles","rootRect","_rootRect","key","transform","transformOrigin","hasOwnProperty","setStyle","isLoaded","updatePosition","_updateAreaIfNeeded","selectInputEvent","_currentInputElement","target","files","length","fileSize","size","fileName","value","replace","cropEvent","name","type","Size","clean","emit","Observable","observer","reader","FileReader","onerror","err","onabort","onload","ev","setTimeout","readAsDataURL","take","loadEvent","originalDataURL","result","loadImage","markForCheck","Other","errorMsg","noAutoCrop","newSize","minScale","changed","scale","_updateAbsoluteScale","originPosition","assign","_simulatePointerMove","_getCenterPoints","offsetWidth","offsetHeight","fitToScreen","container","_a","max","fit","clientX","clientY","_markForCheck","xOrigin","yOrigin","hostRect","areaRect","_areaCropperRect","areaWidth","areaHeight","_slideEnd","autoCrop","crop","zoomIn","_maxScale","undefined","_isLoadedImg","isCropped","_currentLoadConfig","zoomOut","center","src","Image","crossOrigin","createHtmlImg","dataURL","window","atob","dataUrl","startsWith","len","text","span","document","createElement","innerHTML","svg","querySelector","setAttribute","body","appendChild","parseFloat","getComputedStyle","btoa","removeChild","normalizeSVG","onStable","asObservable","_positionImg","Type","responsiveArea","areaWidthConf","areaWidthMax","minHost","currentScale","newScale","_absoluteScale","setImageUrl","loadConfig","rotate","rotation","degrees","validDegrees","_normalizeDegrees","newRotation","newCanvas","context","degreesRad","PI","canvasClon","style","webkitTransform","webkitTransformOrigin","getBoundingClientRect","canvasRect","removeAttribute","h","translate","maxScale","newConfig","_imgCrop","myConfig","canvasElement","_canvasRect","currentImageLoadConfig","fill","fillStyle","fillRect","newHeight","toDataURL","position","_areaRef","triggerEvent","isTouch","moveEventName","endEventName","_getWindow","defaultView","n","de","Component","args","changeDetection","ChangeDetectionStrategy","OnPush","preserveWhitespaces","selector","template","providers","StyleRenderer","Renderer2","ElementRef","ChangeDetectorRef","NgZone","Inject","DOCUMENT","ViewportRuler","ViewChild","static","read","Input","Output","touches","changedTouches","create","__read","o","m","Symbol","iterator","r","e","call","ar","done","push","__spread","arguments","concat","pos","LyCropperArea","_cropper","_startAreaRect","_startImgRect","_b","startAreaRect","startImgRect","keepAspectRatio","shiftKey","newWidth","originX","originY","pow","centerX","centerY","topOverflow","bottomOverflow","bottom","minHeightOnOverflow","leftOverflow","rightOverflow","right","minWidthOnOverflow","minOnOverflow","newNewWidth","newNewHeight","apply","_currentWidth","_currentHeight","_resizableArea","Promise","resolve","then","_removeResizableArea","_addResizableArea","_resizer","exportAs","decorators","desc","d","c","getOwnPropertyDescriptor","Reflect","decorate","__decorate","Style","_value","_","__","NgModule","imports","CommonModule","exports","declarations"],"mappings":"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","sourcesContent":["/*\n * Hermite resize - fast image resize/resample using Hermite filter.\n * https://github.com/viliusle/Hermite-resize\n */\nexport function resizeCanvas(canvas: HTMLCanvasElement, width: number, height: number) {\n  const width_source = canvas.width;\n  const height_source = canvas.height;\n  width = Math.round(width);\n  height = Math.round(height);\n\n  const ratio_w = width_source / width;\n  const ratio_h = height_source / height;\n  const ratio_w_half = Math.ceil(ratio_w / 2);\n  const ratio_h_half = Math.ceil(ratio_h / 2);\n\n  const ctx = canvas.getContext('2d');\n  const img = ctx!.getImageData(0, 0, width_source, height_source);\n  const img2 = ctx!.createImageData(width, height);\n  const data = img.data;\n  const data2 = img2.data;\n\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      const x2 = (i + j * width) * 4;\n      let weight = 0;\n      let weights = 0;\n      let weights_alpha = 0;\n      let gx_r = 0;\n      let gx_g = 0;\n      let gx_b = 0;\n      let gx_a = 0;\n      const center_y = j * ratio_h;\n\n      const xx_start = Math.floor(i * ratio_w);\n      let xx_stop = Math.ceil((i + 1) * ratio_w);\n      const yy_start = Math.floor(j * ratio_h);\n      let yy_stop = Math.ceil((j + 1) * ratio_h);\n      xx_stop = Math.min(xx_stop, width_source);\n      yy_stop = Math.min(yy_stop, height_source);\n\n      for (let yy = yy_start; yy < yy_stop; yy++) {\n        const dy = Math.abs(center_y - yy) / ratio_h_half;\n        const center_x = i * ratio_w;\n        const w0 = dy * dy; // pre-calc part of w\n        for (let xx = xx_start; xx < xx_stop; xx++) {\n          const dx = Math.abs(center_x - xx) / ratio_w_half;\n          const w = Math.sqrt(w0 + dx * dx);\n          if (w >= 1) {\n            // pixel too far\n            continue;\n          }\n          // hermite filter\n          weight = 2 * w * w * w - 3 * w * w + 1;\n          const pos_x = 4 * (xx + yy * width_source);\n          // alpha\n          gx_a += weight * data[pos_x + 3];\n          weights_alpha += weight;\n          // colors\n          if (data[pos_x + 3] < 255) {\n            weight = weight * data[pos_x + 3] / 250;\n          }\n          gx_r += weight * data[pos_x];\n          gx_g += weight * data[pos_x + 1];\n          gx_b += weight * data[pos_x + 2];\n          weights += weight;\n        }\n      }\n      data2[x2] = gx_r / weights;\n      data2[x2 + 1] = gx_g / weights;\n      data2[x2 + 2] = gx_b / weights;\n      data2[x2 + 3] = gx_a / weights_alpha;\n    }\n  }\n\n  // clear and resize canvas\n  canvas.width = width;\n  canvas.height = height;\n\n  // draw\n  ctx!.putImageData(img2, 0, 0);\n  return ctx;\n}\n","import {\n  Component,\n  ElementRef,\n  Input,\n  Output,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  ViewChild,\n  EventEmitter,\n  Renderer2,\n  OnDestroy,\n  NgZone,\n  Inject,\n  OnInit\n} from '@angular/core';\nimport {\n  mergeDeep,\n  LY_COMMON_STYLES,\n  ThemeVariables,\n  st2c,\n  ThemeRef,\n  StyleCollection,\n  LyClasses,\n  StyleTemplate,\n  StyleRenderer } from '@alyle/ui';\nimport { Subject, Observable } from 'rxjs';\nimport { take, takeUntil } from 'rxjs/operators';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport { resizeCanvas } from './resize-canvas';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\n\nexport interface LyImageCropperTheme {\n  /** Styles for Image Cropper Component */\n  root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)>\n    | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);\n}\n\nexport interface LyImageCropperVariables {\n  cropper?: LyImageCropperTheme;\n}\n\nconst activeEventOptions = normalizePassiveListenerOptions({passive: false});\nconst STYLE_PRIORITY = -2;\n\nexport const STYLES = (theme: ThemeVariables & LyImageCropperVariables, ref: ThemeRef) => {\n  const cropper = ref.selectorsOf(STYLES);\n  const { after } = theme;\n  return {\n    $name: LyImageCropper.и,\n    $priority: STYLE_PRIORITY,\n    root: ( ) => (className: string) => `${className}{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;overflow:hidden;position:relative;justify-content:center;align-items:center;}${st2c((\n          (theme.cropper\n            && theme.cropper.root\n            && (theme.cropper.root instanceof StyleCollection\n              ? theme.cropper.root.setTransformer(fn => fn(cropper))\n              : theme.cropper.root(cropper))\n          )), `${className}`)}`,\n    imgContainer: (className: string) => `${className}{cursor:move;position:absolute;top:0;left:0;display:flex;touch-action:none;}${className} > canvas{display:block;}`,\n    overlay: (className: string) => `${st2c((LY_COMMON_STYLES.fill), `${className}`)}`,\n    area: (className: string) => `${className}{pointer-events:none;box-shadow:0 0 0 20000px rgba(0, 0, 0, 0.4);margin:auto;}${st2c((LY_COMMON_STYLES.fill), `${className}`)}${st2c((LY_COMMON_STYLES.fill), `${className}:before,${className}:after`)}${className}:before,${className}:after{content:'';}${className}:before{width:0;height:0;margin:auto;border-radius:50%;background:#fff;border:solid 2px rgb(255, 255, 255);}${className}:after{border:solid 2px rgb(255, 255, 255);border-radius:inherit;}`,\n    resizer: (className: string) => `${className}{width:10px;height:10px;background:#fff;border-radius:3px;position:absolute;touch-action:none;bottom:0;${after}:0;pointer-events:all;cursor:${\n        after === 'right'\n          ? 'nwse-resize'\n          : 'nesw-resize'};}${st2c((LY_COMMON_STYLES.fill), `${className}:before`)}${className}:before{content:'';width:20px;height:20px;transform:translate(-25%, -25%);}`,\n    defaultContent: (className: string) => `${className}{display:flex;align-items:center;justify-content:center;}${st2c((LY_COMMON_STYLES.fill), `${className},${className} > input`)}${className} *:not(input){pointer-events:none;}${className} > input{background:transparent;opacity:0;width:100%;height:100%;}`\n  };\n};\n/** Image Cropper Config */\nexport class ImgCropperConfig {\n  /** Cropper area width */\n  width: number = 250;\n  /** Cropper area height */\n  height: number = 200;\n  minWidth?: number = 40;\n  minHeight?: number = 40;\n  /** If this is not defined, the new image will be automatically defined. */\n  type?: string;\n  /** Background color( default: null), if is null in png is transparent but not in jpg. */\n  fill?: string | null;\n  /**\n   * Set anti-aliased (default: true)\n   * @deprecated this is not necessary as the cropper will automatically resize the image\n   * to the best quality\n   */\n  antiAliased?: boolean = true;\n  autoCrop?: boolean;\n  output?: ImgOutput | ImgResolution = ImgResolution.Default;\n  /**\n   * Zoom out until the entire image fits into the cropping area.\n   * default: false\n   */\n  extraZoomOut?: boolean;\n  /**\n   * Emit event `error` if the file size in bytes for the limit.\n   * Note: It only works when the image is received from the `<input>` event.\n   */\n  maxFileSize?: number | null;\n  /**\n   * Whether the cropper area will be round.\n   * This implies that the cropper area will maintain its aspect ratio.\n   * default: false\n   */\n  round?: boolean;\n  /**\n   * Whether the cropper area is resizable.\n   * default: false\n   */\n  resizableArea?: boolean;\n  /**\n   * Keep the width and height of the growing area the same according\n   * to `ImgCropperConfig.width` and `ImgCropperConfig.height`\n   * default: false\n   */\n  keepAspectRatio?: boolean;\n  /**\n   * Whether the cropper area is responsive.\n   * By default, the width and height of the cropper area is fixed,\n   * so can use when the cropper area is larger than its container,\n   * otherwise this will bring problems when cropping.\n   */\n  responsiveArea?: boolean;\n}\n\n/**\n * The output image\n * With this option you can resize the output image.\n * If `width` or `height` are 0, this will be set automatically.\n * Both cannot be 0.\n */\nexport interface ImgOutput {\n  /**\n   * The cropped image will be resized to this `width`.\n   */\n  width: number;\n  /**\n   * Cropped image will be resized to this `height`.\n   */\n  height: number;\n}\n\n/** Image output */\nexport enum ImgResolution {\n  /**\n   * The output image will be equal to the initial size of the cropper area.\n   */\n  Default,\n  /** Just crop the image without resizing */\n  OriginalImage\n}\n\n/** Image output */\nexport enum ImgCropperError {\n  /** The loaded image exceeds the size limit set. */\n  Size,\n  /** The file loaded is not image. */\n  Type,\n  /** When the image has not been loaded. */\n  Other\n}\n\nexport interface ImgCropperEvent {\n  /** Cropped image data URL */\n  dataURL?: string;\n  name: string | null;\n  /** Filetype */\n  type?: string;\n  /** Cropped area width */\n  areaWidth: number;\n  /** Cropped area height */\n  areaHeight: number;\n  /** Cropped image width */\n  width: number;\n  /** Cropped image height */\n  height: number;\n  /** Original Image data URL */\n  originalDataURL?: string;\n  scale: number;\n  /** Current rotation in degrees */\n  rotation: number;\n  /** Size of the image in bytes */\n  size: number;\n  /** Scaled offset from the left edge of the image */\n  left: number;\n  /** Scaled offset from the top edge of the image */\n  top: number;\n  /**\n   * Scaled offset from the left edge of the image to center of area\n   * Can be used to set image position\n   */\n  xOrigin: number;\n  /**\n   * Scaled offset from the top edge of the image to center of area\n   * Can be used to set image position\n   */\n  yOrigin: number;\n  /** @deprecated Use `xOrigin & yOrigin` instead. */\n  position?: {\n    x: number\n    y: number\n  };\n}\n\nexport interface ImgCropperErrorEvent {\n  name?: string;\n  /** Size of the image in bytes */\n  size: number;\n  /** Filetype */\n  type: string;\n  /** Type of error */\n  error: ImgCropperError;\n  errorMsg?: string;\n}\n\ninterface ImgRect {\n  x: number;\n  y: number;\n  xc: number;\n  yc: number;\n  /** transform with */\n  wt: number;\n  ht: number;\n}\n\nexport interface ImgCropperLoaderConfig {\n  name?: string | null;\n  /** Filetype */\n  type?: string;\n  /** Cropped area width */\n  areaWidth?: number;\n  /** Cropped area height */\n  areaHeight?: number;\n  /** Cropped image width */\n  width?: number;\n  /** Cropped image height */\n  height?: number;\n  /** Original Image data URL */\n  originalDataURL: string;\n  scale?: number;\n  /** Current rotation in degrees */\n  rotation?: number;\n  /** Size of the image in bytes */\n  size?: number;\n  /** Offset from the left edge of the image to center of area */\n  xOrigin?: number;\n  /** Offset from the top edge of the image to center of area */\n  yOrigin?: number;\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  preserveWhitespaces: false,\n  selector: 'ly-img-cropper, ly-image-cropper',\n  templateUrl: 'image-cropper.html',\n  providers: [\n    StyleRenderer\n  ]\n})\nexport class LyImageCropper implements OnInit, OnDestroy {\n  static readonly и = 'LyImageCropper';\n  /**\n   * styles\n   * @docs-private\n   */\n  readonly classes = this.sRenderer.renderSheet(STYLES, true);\n  private _currentLoadConfig?: ImgCropperLoaderConfig;\n  // _originalImgBase64?: string;\n  // private _fileName: string | null;\n\n  /** Original image */\n  private _img: HTMLImageElement;\n  private offset?: {\n    x: number\n    y: number\n    left: number\n    top: number\n  };\n  private _scale?: number;\n  private _scal3Fix?: number;\n  private _minScale?: number;\n  private _maxScale?: number;\n  /** Initial config */\n  private _configPrimary: ImgCropperConfig;\n  private _config: ImgCropperConfig;\n  private _imgRect: ImgRect = {} as any;\n  private _rotation: number = 0;\n  // private _sizeInBytes: number | null;\n  private _isSliding: boolean;\n  /** Keeps track of the last pointer event that was captured by the crop area. */\n  private _lastPointerEvent: MouseEvent | TouchEvent | null;\n  private _startPointerEvent: {\n    x: number\n    y: number\n  } | null;\n  _primaryAreaWidth: number;\n  _primaryAreaHeight: number;\n\n  _absoluteScale: number;\n\n  /**\n   * When is loaded image\n   * @internal\n   */\n  _isLoadedImg: boolean;\n\n  /** When is loaded image & ready for crop */\n  isLoaded: boolean;\n  /** When the cropper is ready to be interacted  */\n  isReady: boolean;\n  isCropped: boolean;\n\n  @ViewChild('_imgContainer', { static: true }) _imgContainer: ElementRef;\n  @ViewChild('_area', {\n    read: ElementRef\n  }) _areaRef: ElementRef;\n  @ViewChild('_imgCanvas', { static: true }) _imgCanvas: ElementRef<HTMLCanvasElement>;\n  @Input()\n  get config(): ImgCropperConfig {\n    return this._config;\n  }\n  set config(val: ImgCropperConfig) {\n    this._config = mergeDeep({}, new ImgCropperConfig(), val);\n    this._configPrimary = mergeDeep({}, this._config);\n    this._primaryAreaWidth = this.config.width;\n    this._primaryAreaHeight = this.config.height;\n    if (\n      this._config.round\n      && this.config.width !== this.config.height\n    ) {\n      throw new Error(`${LyImageCropper.и}: Both width and height must be equal when using \\`ImgCropperConfig.round = true\\``);\n    }\n    const maxFileSize = this._config.maxFileSize;\n    if (maxFileSize) {\n      this.maxFileSize = maxFileSize;\n    }\n  }\n  /** Set scale */\n  @Input()\n  get scale(): number | undefined {\n    return this._scale;\n  }\n  set scale(val: number | undefined) {\n    this.setScale(val);\n  }\n\n  /**\n   * Emit event `error` if the file size for the limit.\n   * Note: It only works when the image is received from the `<input>` event.\n   */\n  @Input() maxFileSize: number;\n\n  /** Get min scale */\n  get minScale(): number | undefined {\n    return this._minScale;\n  }\n\n  @Output() readonly scaleChange = new EventEmitter<number>();\n\n  /** Emits minimum supported image scale */\n  @Output('minScale') readonly minScaleChange = new EventEmitter<number>();\n\n  /** Emits maximum supported image scale */\n  @Output('maxScale') readonly maxScaleChange = new EventEmitter<number>();\n\n  /** @deprecated Emits when the image is loaded, instead use `ready` */\n  @Output() readonly loaded = new EventEmitter<ImgCropperEvent>();\n\n  /** Emits when the image is loaded */\n  @Output() readonly imageLoaded = new EventEmitter<ImgCropperEvent>();\n\n  /** Emits when the cropper is ready to be interacted */\n  @Output() readonly ready = new EventEmitter<ImgCropperEvent>();\n\n  /** On crop new image */\n  @Output() readonly cropped = new EventEmitter<ImgCropperEvent>();\n\n  /** Emits when the cropper is cleaned */\n  @Output() readonly cleaned = new EventEmitter<void>();\n\n  /** Emit an error when the loaded image is not valid */\n  // tslint:disable-next-line: no-output-native\n  @Output() readonly error = new EventEmitter<ImgCropperErrorEvent>();\n\n  private _currentInputElement?: HTMLInputElement;\n\n  /** Emits whenever the component is destroyed. */\n  private readonly _destroy = new Subject<void>();\n\n  /** Used to subscribe to global move and end events */\n  protected _document: Document;\n\n  constructor(\n    readonly sRenderer: StyleRenderer,\n    private _renderer: Renderer2,\n    readonly _elementRef: ElementRef<HTMLElement>,\n    private cd: ChangeDetectorRef,\n    private _ngZone: NgZone,\n    @Inject(DOCUMENT) _document: any,\n    viewPortRuler: ViewportRuler\n  ) {\n    this._document = _document;\n    viewPortRuler.change()\n    .pipe(takeUntil(this._destroy))\n    .subscribe(() =>\n      this._ngZone.run(() => this.updateCropperPosition())\n    );\n  }\n\n  ngOnInit() {\n    this._ngZone.runOutsideAngular(() => {\n      const element = this._imgContainer.nativeElement;\n      element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\n      element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\n    });\n  }\n\n  ngOnDestroy() {\n    this._destroy.next();\n    this._destroy.complete();\n    const element = this._imgContainer.nativeElement;\n    this._lastPointerEvent = null;\n    this._removeGlobalEvents();\n    element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\n    element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\n  }\n\n  /** Load image with canvas */\n  private _imgLoaded(imgElement: HTMLImageElement) {\n    if (imgElement) {\n      this._img = imgElement;\n      const canvas = this._imgCanvas.nativeElement;\n      canvas.width = imgElement.width;\n      canvas.height = imgElement.height;\n      const ctx = canvas.getContext('2d')!;\n      ctx.clearRect(0, 0, imgElement.width, imgElement.height);\n      ctx.drawImage(imgElement, 0, 0);\n\n      /** set min scale */\n      this._updateMinScale(canvas);\n      this._updateMaxScale();\n    }\n  }\n\n  private _setStylesForContImg(values: {\n    x?: number\n    y?: number\n  }) {\n    const newStyles = { } as any;\n    if (values.x != null && values.y != null) {\n      const rootRect = this._rootRect();\n      const x = rootRect.width / 2 - (values.x);\n      const y = rootRect.height / 2 - (values.y);\n\n      this._imgRect.x = (values.x);\n      this._imgRect.y = (values.y);\n      this._imgRect.xc = (x);\n      this._imgRect.yc = (y);\n\n    }\n    newStyles.transform = `translate3d(${(this._imgRect.x)}px,${(this._imgRect.y)}px, 0)`;\n    newStyles.transform += `scale(${this._scal3Fix})`;\n    newStyles.transformOrigin = `${this._imgRect.xc}px ${this._imgRect.yc}px 0`;\n    newStyles['-webkit-transform'] = newStyles.transform;\n    newStyles['-webkit-transform-origin'] = newStyles.transformOrigin;\n    for (const key in newStyles) {\n      if (newStyles.hasOwnProperty(key)) {\n        this._renderer.setStyle(this._imgContainer.nativeElement, key, newStyles[key]);\n      }\n    }\n  }\n  /**\n   * Update area and image position only if needed,\n   * this is used when window resize\n   */\n  updateCropperPosition() {\n    if (this.isLoaded) {\n      this.updatePosition();\n      this._updateAreaIfNeeded();\n    }\n  }\n\n  /** Load Image from input event */\n  selectInputEvent(img: Event) {\n    this._currentInputElement = img.target as HTMLInputElement;\n    const _img = img.target as HTMLInputElement;\n    if (_img.files && _img.files.length !== 1) {\n      return;\n    }\n    const fileSize = _img.files![0].size;\n    const fileName = _img.value.replace(/.*(\\/|\\\\)/, '');\n\n    if (this.maxFileSize && fileSize > this.maxFileSize) {\n      const cropEvent: ImgCropperErrorEvent = {\n        name: fileName,\n        type: _img.files![0].type,\n        size: fileSize,\n        error: ImgCropperError.Size\n      };\n      this.clean();\n      this.error.emit(cropEvent as ImgCropperErrorEvent);\n      return;\n    }\n\n    new Observable<ProgressEvent>(observer => {\n\n      const reader = new FileReader();\n\n      reader.onerror = err => observer.error(err);\n      reader.onabort = err => observer.error(err);\n      reader.onload = (ev) => setTimeout(() => {\n        observer.next(ev);\n        observer.complete();\n      });\n\n      reader.readAsDataURL(_img.files![0]);\n    })\n      .pipe(take(1), takeUntil(this._destroy))\n      .subscribe(\n        (loadEvent) => {\n          const originalDataURL = (loadEvent.target as FileReader).result as string;\n\n          this.loadImage({\n            name: fileName,\n            size: _img.files![0].size, // size in bytes\n            type: this.config.type || _img.files![0].type,\n            originalDataURL\n          });\n\n          this.cd.markForCheck();\n        },\n        () => {\n          const cropEvent: ImgCropperErrorEvent = {\n            name: fileName,\n            size: fileSize,\n            error: ImgCropperError.Other,\n            errorMsg: 'The File could not be loaded.',\n            type: _img.files![0].type\n          };\n          this.clean();\n          this.error.emit(cropEvent as ImgCropperErrorEvent);\n        }\n      );\n\n  }\n\n  /** Set the size of the image, the values can be 0 between 1, where 1 is the original size */\n  setScale(size?: number, noAutoCrop?: boolean) {\n    // fix min scale\n    const newSize = size! >= this.minScale! && size! <= 1 ? size : this.minScale;\n\n    // check\n    const changed = size != null && size !== this.scale && newSize !== this.scale;\n    this._scale = size;\n    if (!changed) {\n      return;\n    }\n    this._scal3Fix = newSize;\n    this._updateAbsoluteScale();\n    if (this.isLoaded) {\n      if (changed) {\n        const originPosition = {...this._imgRect};\n        this.offset = {\n          x: originPosition.x,\n          y: originPosition.y,\n          left: originPosition.xc,\n          top: originPosition.yc\n        };\n        this._setStylesForContImg({});\n        this._simulatePointerMove();\n      } else {\n        return;\n      }\n    } else if (this.minScale) {\n      this._setStylesForContImg({\n        ...this._getCenterPoints()\n      });\n    } else {\n      return;\n    }\n\n    this.scaleChange.emit(size);\n    if (!noAutoCrop) {\n      this._cropIfAutoCrop();\n    }\n\n  }\n\n  private _getCenterPoints() {\n    const root = this._elementRef.nativeElement as HTMLElement;\n    const img = this._imgCanvas.nativeElement;\n    const x = (root.offsetWidth - (img.width)) / 2;\n    const y = (root.offsetHeight - (img.height)) / 2;\n    return {\n      x,\n      y\n    };\n  }\n\n  /**\n   * Fit to screen\n   */\n  fitToScreen() {\n    const container = this._elementRef.nativeElement as HTMLElement;\n    const min = {\n      width: container.offsetWidth,\n      height: container.offsetHeight\n    };\n    const { width, height } = this._img;\n    const minScale = {\n      width: min.width / width,\n      height: min.height / height\n    };\n    const result = Math.max(minScale.width, minScale.height);\n    this.setScale(result);\n  }\n\n  fit() {\n    this.setScale(this.minScale);\n  }\n\n  private _pointerDown = (event: TouchEvent | MouseEvent) => {\n    // Don't do anything if the\n    // user is using anything other than the main mouse button.\n    if (this._isSliding || (!isTouchEvent(event) && event.button !== 0)) {\n      return;\n    }\n\n    this._ngZone.run(() => {\n      this._isSliding = true;\n      this.offset = {\n        x: this._imgRect.x,\n        y: this._imgRect.y,\n        left: this._imgRect.xc,\n        top: this._imgRect.yc\n      };\n      this._lastPointerEvent = event;\n      this._startPointerEvent = getGesturePointFromEvent(event);\n      event.preventDefault();\n      this._bindGlobalEvents(event);\n    });\n\n  }\n\n  /**\n   * Simulate pointerMove with clientX = 0 and clientY = 0,\n   * this is used by `setScale` and `rotate`\n   */\n  private _simulatePointerMove() {\n    this._isSliding = true;\n    this._startPointerEvent = {\n      x: 0,\n      y: 0\n    };\n    this._pointerMove({\n      clientX: 0,\n      clientY: 0,\n      type: 'n',\n      preventDefault: () => {}\n    } as MouseEvent);\n    this._isSliding = false;\n    this._startPointerEvent = null;\n  }\n\n  _markForCheck() {\n    this.cd.markForCheck();\n  }\n\n  /**\n   * Called when the user has moved their pointer after\n   * starting to drag.\n   */\n  private _pointerMove = (event: TouchEvent | MouseEvent) => {\n    if (this._isSliding) {\n      event.preventDefault();\n      this._lastPointerEvent = event;\n      let x: number | undefined, y: number | undefined;\n      const canvas = this._imgCanvas.nativeElement;\n      const scaleFix = this._scal3Fix;\n      const config = this.config;\n      const startP = this.offset;\n      const point = getGesturePointFromEvent(event);\n      const deltaX = point.x - this._startPointerEvent!.x;\n      const deltaY = point.y - this._startPointerEvent!.y;\n      if (!scaleFix || !startP) {\n        return;\n      }\n\n      const isMinScaleY = canvas.height * scaleFix < config.height && config.extraZoomOut;\n      const isMinScaleX = canvas.width * scaleFix < config.width && config.extraZoomOut;\n\n      const limitLeft = (config.width / 2 / scaleFix) >= startP.left - (deltaX / scaleFix);\n      const limitRight = (config.width / 2 / scaleFix) + (canvas.width) - (startP.left - (deltaX / scaleFix)) <= config.width / scaleFix;\n      const limitTop = ((config.height / 2 / scaleFix) >= (startP.top - (deltaY / scaleFix)));\n      const limitBottom = (\n        ((config.height / 2 / scaleFix) + (canvas.height) - (startP.top - (deltaY / scaleFix))) <= (config.height / scaleFix)\n      );\n\n      // Limit for left\n      if ((limitLeft && !isMinScaleX) || (!limitLeft && isMinScaleX)) {\n        x = startP.x + (startP.left) - (config.width / 2 / scaleFix);\n      }\n\n      // Limit for right\n      if ((limitRight && !isMinScaleX) || (!limitRight && isMinScaleX)) {\n        x = startP.x + (startP.left) + (config.width / 2 / scaleFix) - canvas.width;\n      }\n\n      // Limit for top\n      if ((limitTop && !isMinScaleY) || (!limitTop && isMinScaleY)) {\n        y = startP.y + (startP.top) - (config.height / 2 / scaleFix);\n      }\n\n      // Limit for bottom\n      if ((limitBottom && !isMinScaleY) || (!limitBottom && isMinScaleY)) {\n        y = startP.y + (startP.top) + (config.height / 2 / scaleFix) - canvas.height;\n      }\n\n      // When press shiftKey, deprecated\n      // if (event.srcEvent && event.srcEvent.shiftKey) {\n      //   if (Math.abs(event.deltaX) === Math.max(Math.abs(event.deltaX), Math.abs(event.deltaY))) {\n      //     y = this.offset.top;\n      //   } else {\n      //     x = this.offset.left;\n      //   }\n      // }\n\n      if (x === void 0) { x = (deltaX / scaleFix) + (startP.x); }\n      if (y === void 0) { y = (deltaY / scaleFix) + (startP.y); }\n      this._setStylesForContImg({\n        x, y\n      });\n    }\n  }\n\n  updatePosition(): void;\n  updatePosition(xOrigin: number, yOrigin: number): void;\n  updatePosition(xOrigin?: number, yOrigin?: number) {\n    const hostRect = this._rootRect();\n    const areaRect = this._areaCropperRect();\n    const areaWidth = areaRect.width > hostRect.width\n      ? hostRect.width\n      : areaRect.width;\n    const areaHeight = areaRect.height > hostRect.height\n      ? hostRect.height\n      : areaRect.height;\n    let x: number, y: number;\n    if (xOrigin == null && yOrigin == null) {\n      xOrigin = this._imgRect.xc;\n      yOrigin = this._imgRect.yc;\n    }\n    x = (areaRect.left - hostRect.left);\n    y = (areaRect.top - hostRect.top);\n    x -= (xOrigin! - (areaWidth / 2));\n    y -= (yOrigin! - (areaHeight / 2));\n\n    this._setStylesForContImg({\n      x, y\n    });\n  }\n\n  _slideEnd() {\n    this._cropIfAutoCrop();\n  }\n\n  private _cropIfAutoCrop() {\n    if (this.config.autoCrop) {\n      this.crop();\n    }\n  }\n\n  /** + */\n  zoomIn() {\n    const scale = this._scal3Fix! + .05;\n    if (scale > this.minScale! && scale <= this._maxScale!) {\n      this.setScale(scale);\n    } else {\n      this.setScale(this._maxScale!);\n    }\n  }\n\n  /** Clean the img cropper */\n  clean() {\n    // fix choosing the same image does not load\n    if (this._currentInputElement) {\n      this._currentInputElement.value = '';\n      this._currentInputElement = null!;\n    }\n    if (this.isLoaded) {\n      this._imgRect = { } as any;\n      this.offset = undefined;\n      this.scale = undefined as any;\n      this._scal3Fix = undefined;\n      this._rotation = 0;\n      this._minScale = undefined;\n      this._isLoadedImg = false;\n      this.isLoaded = false;\n      this.isCropped = false;\n      this._currentLoadConfig = undefined;\n      this.config = this._configPrimary;\n      const canvas = this._imgCanvas.nativeElement;\n      canvas.width = 0;\n      canvas.height = 0;\n      this.cleaned.emit(null!);\n      this.cd.markForCheck();\n    }\n  }\n\n  /** - */\n  zoomOut() {\n    const scale = this._scal3Fix! - .05;\n    if (scale > this.minScale! && scale <= this._maxScale!) {\n      this.setScale(scale);\n    } else {\n      this.fit();\n    }\n  }\n  center() {\n    const newStyles = {\n      ...this._getCenterPoints()\n    };\n    this._setStylesForContImg(newStyles);\n    this._cropIfAutoCrop();\n  }\n  /**\n   * load an image from a given configuration,\n   * or from the result of a cropped image\n   */\n  loadImage(config: ImgCropperLoaderConfig | string, fn?: () => void) {\n    this.clean();\n    const _config = this._currentLoadConfig = typeof config === 'string'\n      ? { originalDataURL: config }\n      : { ...config };\n    let src = _config.originalDataURL;\n    this._primaryAreaWidth = this._configPrimary.width;\n    this._primaryAreaHeight = this._configPrimary.height;\n    if (_config.areaWidth && _config.areaHeight) {\n      this.config.width = _config.areaWidth;\n      this.config.height = _config.areaHeight;\n    }\n    src = normalizeSVG(src);\n\n    const img = createHtmlImg(src);\n\n    const cropEvent = { ..._config } as ImgCropperEvent;\n\n    new Observable<void>(observer => {\n\n      img.onerror = err => observer.error(err);\n      img.onabort = err => observer.error(err);\n      img.onload = () => observer.next(null!);\n    })\n    .pipe(take(1), takeUntil(this._destroy))\n    .subscribe(\n      () => {\n        this._imgLoaded(img);\n        this._isLoadedImg = true;\n        this.imageLoaded.emit(cropEvent);\n        this.cd.markForCheck();\n        this._ngZone.runOutsideAngular(() => {\n          this._ngZone\n            .onStable\n            .asObservable()\n            .pipe(take(1), takeUntil(this._destroy))\n            .subscribe(\n              () => setTimeout(() => this._ngZone.run(() => this._positionImg(cropEvent, fn)))\n            );\n        });\n      },\n      () => {\n        const error: ImgCropperErrorEvent = {\n          name: _config.name!,\n          error: ImgCropperError.Type,\n          type: _config.type!,\n          size: _config.size!\n        };\n        this.error.emit(error);\n      }\n    );\n  }\n\n  private _updateAreaIfNeeded() {\n    if (!this._config.responsiveArea) {\n      return;\n    }\n\n    const rootRect = this._rootRect();\n    const areaRect = this._areaCropperRect();\n    const minWidth = this.config.minWidth || 1;\n    const minHeight = this.config.minHeight || 1;\n    if (!(\n      areaRect.width > rootRect.width\n      || areaRect.height > rootRect.height\n      || areaRect.width < this._primaryAreaWidth\n      || areaRect.height < this._primaryAreaHeight\n    )) {\n      return;\n    }\n    const areaWidthConf = Math.max(this.config.width, minWidth);\n    const areaWidthMax = Math.max(rootRect.width, minWidth);\n    const minHost = Math.min(\n      Math.max(rootRect.width, minWidth), Math.max(rootRect.height, minHeight)\n    );\n    const currentScale = this._scal3Fix!;\n    let newScale = 0;\n    const roundConf = this.config.round;\n\n    if (roundConf) {\n      this.config.width = this.config.height = minHost;\n    } else {\n      if (areaWidthConf === areaRect.width) {\n        if (areaWidthMax > this._primaryAreaWidth) {\n          this.config.width = this._primaryAreaWidth;\n          this.config.height = (this._primaryAreaWidth * areaRect.height) / areaRect.width;\n          newScale = (currentScale * this._primaryAreaWidth) / areaRect.width;\n        } else {\n          this.config.width = areaWidthMax;\n          this.config.height = (areaWidthMax * areaRect.height) / areaRect.width;\n          newScale = (currentScale * areaWidthMax) / areaRect.width;\n        }\n        this._updateMinScale();\n        this._updateMaxScale();\n        this.setScale(newScale, true);\n        this._markForCheck();\n      }\n    }\n  }\n\n  private _updateAbsoluteScale() {\n    const scale = this._scal3Fix! / (this.config.width / this._primaryAreaWidth);\n    this._absoluteScale = scale;\n  }\n\n  /**\n   * Load Image from URL\n   * @deprecated Use `loadImage` instead of `setImageUrl`\n   * @param src URL\n   * @param fn function that will be called before emit the event loaded\n   */\n  setImageUrl(src: string, fn?: () => void) {\n    this.loadImage(src, fn);\n  }\n\n  private _positionImg(cropEvent: ImgCropperEvent, fn?: () => void) {\n    const loadConfig = this._currentLoadConfig!;\n    this._updateMinScale(this._imgCanvas.nativeElement);\n    this._updateMaxScale();\n    this.isLoaded = false;\n    if (fn) {\n      fn();\n    } else {\n      if (loadConfig.scale) {\n        this.setScale(loadConfig.scale, true);\n      } else {\n        this.setScale(this.minScale, true);\n      }\n      this.rotate(loadConfig.rotation || 0);\n      this._updateAreaIfNeeded();\n      this._markForCheck();\n      this._ngZone.runOutsideAngular(() => {\n        this._ngZone\n          .onStable\n          .asObservable()\n          .pipe(take(1), takeUntil(this._destroy))\n          .subscribe(() => {\n            if (loadConfig.xOrigin != null && loadConfig.yOrigin != null) {\n              this.updatePosition(loadConfig.xOrigin, loadConfig.yOrigin);\n            }\n            this._updateAreaIfNeeded();\n            this.isLoaded = true;\n            this._cropIfAutoCrop();\n            this._ngZone.run(() => {\n              this._markForCheck();\n              this.ready.emit(cropEvent);\n              // tslint:disable-next-line: deprecation\n              this.loaded.emit(cropEvent);\n            });\n          });\n      });\n    }\n  }\n\n  rotate(degrees: number) {\n    let validDegrees = _normalizeDegrees(degrees);\n    // If negative convert to positive\n    if (validDegrees < 0) {\n      validDegrees += 360;\n    }\n    const newRotation = _normalizeDegrees((this._rotation || 0) + validDegrees);\n    if (newRotation === this._rotation) {\n      return;\n    }\n    const degreesRad = validDegrees * Math.PI / 180;\n    const canvas = this._imgCanvas.nativeElement;\n    const canvasClon = createCanvasImg(canvas);\n    const ctx = canvas.getContext('2d')!;\n    this._rotation = newRotation;\n\n    // clear\n    ctx.clearRect(0, 0, canvasClon.width, canvasClon.height);\n\n    // rotate canvas image\n    const transform = `rotate(${validDegrees}deg) scale(${1 / this._scal3Fix!})`;\n    const transformOrigin = `${this._imgRect.xc}px ${this._imgRect.yc}px 0`;\n    canvas.style.transform = transform;\n    // tslint:disable-next-line: deprecation\n    canvas.style.webkitTransform = transform;\n    canvas.style.transformOrigin = transformOrigin;\n    // tslint:disable-next-line: deprecation\n    canvas.style.webkitTransformOrigin = transformOrigin;\n\n    const { left, top } = canvas.getBoundingClientRect() as DOMRect;\n\n    // save rect\n    const canvasRect = canvas.getBoundingClientRect();\n\n    // remove rotate styles\n    canvas.removeAttribute('style');\n\n    // set w & h\n    const w = canvasRect.width;\n    const h = canvasRect.height;\n    ctx.canvas.width = w;\n    ctx.canvas.height = h;\n\n    // clear\n    ctx.clearRect(0, 0, w, h);\n\n    // translate and rotate\n    ctx.translate(w / 2, h / 2);\n    ctx.rotate(degreesRad);\n    ctx.drawImage(canvasClon, -canvasClon.width / 2, -canvasClon.height / 2);\n\n    // Update min scale\n    this._updateMinScale(canvas);\n    this._updateMaxScale();\n\n    // set the minimum scale, only if necessary\n    if (this.scale! < this.minScale!) {\n      this.setScale(0, true);\n    } //                ↑ no AutoCrop\n\n    const rootRect = this._rootRect();\n\n    this._setStylesForContImg({\n      x: (left - rootRect.left),\n      y: (top - rootRect.top)\n    });\n\n    // keep image inside the frame\n    const originPosition = {...this._imgRect};\n    this.offset = {\n      x: originPosition.x,\n      y: originPosition.y,\n      left: originPosition.xc,\n      top: originPosition.yc\n    };\n    this._setStylesForContImg({});\n    this._simulatePointerMove();\n\n    this._cropIfAutoCrop();\n  }\n\n  _updateMinScale(canvas?: HTMLCanvasElement) {\n    if (!canvas) {\n      canvas = this._imgCanvas.nativeElement;\n    }\n    const config = this.config;\n    const minScale = (config.extraZoomOut ? Math.min : Math.max)(\n      config.width / canvas.width,\n      config.height / canvas.height);\n    this._minScale = minScale;\n    this.minScaleChange.emit(minScale!);\n  }\n\n  private _updateMaxScale() {\n    const maxScale = (this.config.width / this._primaryAreaWidth);\n    this._maxScale = maxScale;\n    this.maxScaleChange.emit(maxScale);\n  }\n\n  /**\n   * Resize & crop image\n   */\n  crop(config?: ImgCropperConfig): ImgCropperEvent {\n    const newConfig = config\n    ? mergeDeep({ }, this.config || new ImgCropperConfig(), config) : this.config;\n    const cropEvent = this._imgCrop(newConfig);\n    this.cd.markForCheck();\n    return cropEvent;\n  }\n\n  /**\n   * @docs-private\n   */\n  private _imgCrop(myConfig: ImgCropperConfig) {\n    const canvasElement: HTMLCanvasElement = document.createElement('canvas');\n    const areaRect = this._areaCropperRect();\n    const canvasRect = this._canvasRect();\n    const scaleFix = this._scal3Fix!;\n    const left = (areaRect.left - canvasRect.left) / scaleFix;\n    const top = (areaRect.top - canvasRect.top) / scaleFix;\n    const { output } = myConfig;\n    const currentImageLoadConfig = this._currentLoadConfig!;\n    const area = {\n      width: myConfig.width,\n      height: myConfig.height\n    };\n    canvasElement.width = area.width / scaleFix;\n    canvasElement.height = area.height / scaleFix;\n    const ctx = canvasElement.getContext('2d')!;\n    if (myConfig.fill) {\n      ctx.fillStyle = myConfig.fill;\n      ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n    }\n    ctx.drawImage(this._imgCanvas.nativeElement,\n      -(left), -(top),\n    );\n    const result = canvasElement;\n    if (myConfig.output === ImgResolution.Default) {\n      resizeCanvas(\n        result,\n        this._configPrimary.width,\n        this._configPrimary.height);\n    } else if (typeof output === 'object') {\n      if (output.width && output.height) {\n        resizeCanvas(result, output.width, output.height);\n      } else if (output.width) {\n        const newHeight = area.height * output.width / area.width;\n        resizeCanvas(result, output.width, newHeight);\n      } else if (output.height) {\n        const newWidth = area.width * output.height / area.height;\n        resizeCanvas(result, newWidth, output.height);\n      }\n    }\n    const type = currentImageLoadConfig.originalDataURL.startsWith('http')\n      ? currentImageLoadConfig.type || myConfig.type\n      : myConfig.type || currentImageLoadConfig.type!;\n    const dataURL = result.toDataURL(type);\n    const cropEvent: ImgCropperEvent = {\n      dataURL,\n      type,\n      name: currentImageLoadConfig.name!,\n      areaWidth: this._primaryAreaWidth,\n      areaHeight: this._primaryAreaHeight,\n      width: result.width,\n      height: result.height,\n      originalDataURL: currentImageLoadConfig.originalDataURL,\n      scale: this._absoluteScale!,\n      rotation: this._rotation,\n      left: (areaRect.left - canvasRect.left) / this._scal3Fix!,\n      top: (areaRect.top - canvasRect.top) / this._scal3Fix!,\n      size: currentImageLoadConfig.size!,\n      xOrigin: this._imgRect.xc,\n      yOrigin: this._imgRect.yc,\n      position: {\n        x: this._imgRect.xc,\n        y: this._imgRect.yc\n      }\n    };\n\n    this.isCropped = true;\n    this.cropped.emit(cropEvent);\n    return cropEvent;\n  }\n\n  _rootRect(): DOMRect {\n    return this._elementRef.nativeElement.getBoundingClientRect() as DOMRect;\n  }\n\n  _areaCropperRect(): DOMRect {\n    return this._areaRef.nativeElement.getBoundingClientRect() as DOMRect;\n  }\n\n  _canvasRect(): DOMRect {\n    return this._imgCanvas.nativeElement.getBoundingClientRect();\n  }\n\n\n  /** Called when the user has lifted their pointer. */\n  private _pointerUp = (event: TouchEvent | MouseEvent) => {\n    if (this._isSliding) {\n      event.preventDefault();\n      this._removeGlobalEvents();\n      this._isSliding = false;\n      this._startPointerEvent = null;\n      this._cropIfAutoCrop();\n    }\n  }\n\n  /** Called when the window has lost focus. */\n  private _windowBlur = () => {\n    // If the window is blurred while dragging we need to stop dragging because the\n    // browser won't dispatch the `mouseup` and `touchend` events anymore.\n    if (this._lastPointerEvent) {\n      this._pointerUp(this._lastPointerEvent);\n    }\n  }\n\n  private _bindGlobalEvents(triggerEvent: TouchEvent | MouseEvent) {\n    const element = this._document;\n    const isTouch = isTouchEvent(triggerEvent);\n    const moveEventName = isTouch ? 'touchmove' : 'mousemove';\n    const endEventName = isTouch ? 'touchend' : 'mouseup';\n    element.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\n    element.addEventListener(endEventName, this._pointerUp, activeEventOptions);\n\n    if (isTouch) {\n      element.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\n    }\n\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined' && window) {\n      window.addEventListener('blur', this._windowBlur);\n    }\n  }\n\n  /** Removes any global event listeners that we may have added. */\n  private _removeGlobalEvents() {\n    const element = this._document;\n    element.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\n    element.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\n    element.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\n    element.removeEventListener('touchend', this._pointerUp, activeEventOptions);\n    element.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\n\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined' && window) {\n      window.removeEventListener('blur', this._windowBlur);\n    }\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document.defaultView || window;\n  }\n\n}\n\n/**\n * Normalize degrees for cropper rotation\n * @docs-private\n */\nexport function _normalizeDegrees(n: number) {\n  const de = n % 360;\n  if (de % 90) {\n    throw new Error(`LyCropper: Invalid \\`${n}\\` degree, only accepted values: 0, 90, 180, 270 & 360.`);\n  }\n  return de;\n}\n\n/**\n * @docs-private\n */\nfunction createCanvasImg(img: HTMLCanvasElement | HTMLImageElement) {\n\n  // create a new canvas\n  const newCanvas = document.createElement('canvas');\n  const context = newCanvas.getContext('2d')!;\n\n  // set dimensions\n  newCanvas.width = img.width;\n  newCanvas.height = img.height;\n\n  // apply the old canvas to the new one\n  context.drawImage(img, 0, 0);\n\n  // return the new canvas\n  return newCanvas;\n}\n\n\nconst DATA_IMAGE_SVG_PREFIX = 'data:image/svg+xml;base64,';\n\nfunction normalizeSVG(dataURL: string) {\n  if (window.atob && isSvgImage(dataURL)) {\n    const len = dataURL.length / 5;\n    const text = window.atob(dataURL.replace(DATA_IMAGE_SVG_PREFIX, ''));\n    const span = document.createElement('span');\n    span.innerHTML = text;\n    const svg = span.querySelector('svg')!;\n    span.setAttribute('style', 'display:none');\n    document.body.appendChild(span);\n    const width = parseFloat(getComputedStyle(svg).width!) || 1;\n    const height = parseFloat(getComputedStyle(svg).height!) || 1;\n    const max = Math.max(width, height);\n\n    svg.setAttribute('width', `${len / (width / max)}px`);\n    svg.setAttribute('height', `${len / (height / max)}px`);\n    const result = DATA_IMAGE_SVG_PREFIX + window.btoa(span.innerHTML);\n    document.body.removeChild(span);\n    return result;\n  }\n  return dataURL;\n}\n\nfunction isSvgImage(dataUrl: string) {\n  return dataUrl.startsWith(DATA_IMAGE_SVG_PREFIX);\n}\n\nfunction createHtmlImg(src: string) {\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n  img.src = src;\n  return img;\n}\n\n\nfunction getGesturePointFromEvent(event: TouchEvent | MouseEvent) {\n\n  // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n  const point = isTouchEvent(event)\n    ? (event.touches[0] || event.changedTouches[0])\n    : event;\n\n  return {\n    x: point.clientX,\n    y: point.clientY\n  };\n}\n\n/** Returns whether an event is a touch event. */\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return event.type[0] === 't';\n}\n\nexport function round(n: number) {\n  return Math.round(n);\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Component, ElementRef, NgZone, Input, OnDestroy, ChangeDetectionStrategy, Inject, ViewChild } from '@angular/core';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport {\n  Style,\n  WithStyles,\n  StyleRenderer } from '@alyle/ui';\nimport { STYLES, LyImageCropper } from './image-cropper';\nimport { DOCUMENT } from '@angular/common';\n\nconst activeEventOptions = normalizePassiveListenerOptions({passive: false});\n\nconst pos = (100 * Math.sqrt(2) - 100) / 2 / Math.sqrt(2);\n\n/**\n * @dynamic\n */\n@Component({\n  selector: 'ly-cropper-area',\n  templateUrl: './image-cropper-area.html',\n  providers: [\n    StyleRenderer\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'lyCropperArea'\n})\nexport class LyCropperArea implements WithStyles, OnDestroy {\n  readonly classes = this.sRenderer.renderSheet(STYLES, 'area');\n\n  private _isSliding: boolean;\n  /** Keeps track of the last pointer event that was captured by the crop area. */\n  private _lastPointerEvent: MouseEvent | TouchEvent | null;\n  private _startPointerEvent: {\n    x: number\n    y: number\n  } | null;\n  private _currentWidth: number;\n  private _currentHeight: number;\n  private _startAreaRect: DOMRect;\n  private _startImgRect: DOMRect;\n\n  /** Used to subscribe to global move and end events */\n  protected _document: Document;\n\n  @ViewChild('resizer') readonly _resizer?: ElementRef;\n\n  @Input()\n  set resizableArea(val: boolean) {\n    if (val !== this._resizableArea) {\n      this._resizableArea = val;\n      Promise.resolve(null).then(() => {\n        if (val) {\n          this._removeResizableArea();\n          this._addResizableArea();\n        } else {\n          this._removeResizableArea();\n        }\n      });\n    }\n  }\n  get resizableArea() {\n    return this._resizableArea;\n  }\n  private _resizableArea: boolean;\n  @Input() keepAspectRatio: boolean;\n  @Input()\n  @Style<boolean, LyCropperArea>(\n    (_value, _, { classes: __ }) => ({ after }) => (className: string) => `${className}{border-radius:50%;}${className} .${__.resizer}{${after}:${pos}%;bottom:${pos}%;transform:translate(4px, 4px);}`\n  ) round: boolean;\n\n  constructor(\n    readonly sRenderer: StyleRenderer,\n    readonly _elementRef: ElementRef,\n    private _ngZone: NgZone,\n    readonly _cropper: LyImageCropper,\n    @Inject(DOCUMENT) _document: any,\n  ) {\n    this._document = _document;\n  }\n\n  ngOnDestroy() {\n    this._removeResizableArea();\n  }\n\n  private _addResizableArea() {\n    this._ngZone.runOutsideAngular(() => {\n      const element = this._resizer!.nativeElement;\n      element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\n      element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\n    });\n  }\n\n  private _removeResizableArea() {\n    const element = this._resizer?.nativeElement;\n    if (element) {\n      this._lastPointerEvent = null;\n      this._removeGlobalEvents();\n      element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\n      element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\n    }\n  }\n\n  private _pointerDown = (event: MouseEvent | TouchEvent) => {\n    // Don't do anything if the\n    // user is using anything other than the main mouse button.\n    if (this._isSliding || (!isTouchEvent(event) && event.button !== 0)) {\n      return;\n    }\n\n    event.preventDefault();\n\n    this._ngZone.run(() => {\n      this._isSliding = true;\n      this._lastPointerEvent = event;\n      this._startPointerEvent = getGesturePointFromEvent(event);\n      this._startAreaRect = this._cropper._areaCropperRect();\n      this._startImgRect = this._cropper._canvasRect();\n      event.preventDefault();\n      this._bindGlobalEvents(event);\n    });\n\n  }\n\n  private _pointerMove = (event: MouseEvent | TouchEvent) => {\n    if (this._isSliding) {\n      event.preventDefault();\n      this._lastPointerEvent = event;\n      const element: HTMLDivElement = this._elementRef.nativeElement;\n      const { width, height, minWidth, minHeight } = this._cropper.config;\n      const point = getGesturePointFromEvent(event);\n      const deltaX = point.x - this._startPointerEvent!.x;\n      const deltaY = point.y - this._startPointerEvent!.y;\n      const startAreaRect = this._startAreaRect;\n      const startImgRect = this._startImgRect;\n      const round = this.round;\n      const keepAspectRatio = this._cropper.config.keepAspectRatio || event.shiftKey;\n      let newWidth = 0;\n      let newHeight = 0;\n      const rootRect = this._cropper._rootRect();\n\n      if (round) {\n        // The distance from the center of the cropper area to the pointer\n        const originX = ((width / 2 / Math.sqrt(2)) + deltaX);\n        const originY = ((height / 2 / Math.sqrt(2)) + deltaY);\n\n        // Leg\n        const side = Math.sqrt(originX ** 2 + originY ** 2);\n        newWidth = newHeight = side * 2;\n\n      } else if (keepAspectRatio) {\n        newWidth = width + deltaX * 2;\n        newHeight = height + deltaY * 2;\n        if (width !== height) {\n          if (width > height) {\n            newHeight = height / (width / newWidth);\n          } else if (height > width) {\n            newWidth = width / (height / newHeight);\n          }\n        } else {\n          newWidth = newHeight = Math.max(newWidth, newHeight);\n        }\n      } else {\n        newWidth = width + deltaX * 2;\n        newHeight = height + deltaY * 2;\n      }\n\n      // To min width\n      if (newWidth < minWidth!) {\n        newWidth = minWidth!;\n      }\n      // To min height\n      if (newHeight < minHeight!) {\n        newHeight = minHeight!;\n      }\n\n      // Do not overflow the cropper area\n      const centerX = startAreaRect.x + startAreaRect.width / 2;\n      const centerY = startAreaRect.y + startAreaRect.height / 2;\n      const topOverflow = startImgRect.y > centerY - (newHeight / 2);\n      const bottomOverflow = centerY + (newHeight / 2) > startImgRect.bottom;\n      const minHeightOnOverflow = Math.min((centerY - startImgRect.y) * 2, (startImgRect.bottom - centerY) * 2);\n      const leftOverflow = startImgRect.x > centerX - (newWidth / 2);\n      const rightOverflow = centerX + (newWidth / 2) > startImgRect.right;\n      const minWidthOnOverflow = Math.min((centerX - startImgRect.x) * 2, (startImgRect.right - centerX) * 2);\n      const minOnOverflow = Math.min(minWidthOnOverflow, minHeightOnOverflow);\n      if (round) {\n        if (topOverflow || bottomOverflow || leftOverflow || rightOverflow) {\n          newHeight = newWidth = minOnOverflow;\n        }\n      } else if (keepAspectRatio) {\n        const newNewWidth: number[] = [];\n        const newNewHeight: number[] = [];\n        if ((topOverflow || bottomOverflow) && Math.min()) {\n          newHeight = minHeightOnOverflow;\n          newNewHeight.push(newHeight);\n          newWidth = width / (height / minHeightOnOverflow);\n          newNewWidth.push(newWidth);\n        }\n        if ((leftOverflow || rightOverflow)) {\n          newWidth = minWidthOnOverflow;\n          newNewWidth.push(newWidth);\n          newHeight = height / (width / minWidthOnOverflow);\n          newNewHeight.push(newHeight);\n        }\n        if (newNewWidth.length === 2) {\n          newWidth = Math.min(...newNewWidth);\n        }\n        if (newNewHeight.length === 2) {\n          newHeight = Math.min(...newNewHeight);\n        }\n      } else {\n        if (topOverflow || bottomOverflow) {\n          newHeight = minHeightOnOverflow;\n        }\n        if (leftOverflow || rightOverflow) {\n          newWidth = minWidthOnOverflow;\n        }\n      }\n\n      // Do not overflow the container\n      if (round) {\n        const min = Math.min(rootRect.width, rootRect.height);\n        if (newWidth > min) {\n          newWidth = newHeight = min;\n        } else if (newHeight > min) {\n          newWidth = newHeight = min;\n        }\n      } else if (keepAspectRatio) {\n        if (newWidth > rootRect.width) {\n          newWidth = rootRect.width;\n          newHeight = height / (width / rootRect.width);\n        } else if (newHeight > rootRect.height) {\n          newWidth = width / (height / rootRect.height);\n          newHeight = rootRect.height;\n        }\n      } else {\n        if (newWidth > rootRect.width) {\n          newWidth = rootRect.width;\n        } else if (newHeight > rootRect.height) {\n          newHeight = rootRect.height;\n        }\n      }\n\n\n      // round values\n      newWidth = Math.round(newWidth);\n      newHeight = Math.round(newHeight);\n\n      element.style.width = `${newWidth}px`;\n      element.style.height = `${newHeight}px`;\n      this._currentWidth = newWidth;\n      this._currentHeight = newHeight;\n    }\n  }\n\n  /** Called when the user has lifted their pointer. */\n  private _pointerUp = (event: TouchEvent | MouseEvent) => {\n    if (this._isSliding) {\n      event.preventDefault();\n      this._removeGlobalEvents();\n      this._cropper._primaryAreaWidth = this._cropper.config.width = this._currentWidth;\n      this._cropper._primaryAreaHeight = this._cropper.config.height = this._currentHeight;\n      this._cropper.config = this._cropper.config;\n      this._cropper._updateMinScale();\n      this._isSliding = false;\n      this._startPointerEvent = null;\n    }\n  }\n\n  /** Called when the window has lost focus. */\n  private _windowBlur = () => {\n    // If the window is blurred while dragging we need to stop dragging because the\n    // browser won't dispatch the `mouseup` and `touchend` events anymore.\n    if (this._lastPointerEvent) {\n      this._pointerUp(this._lastPointerEvent);\n    }\n  }\n\n  private _bindGlobalEvents(triggerEvent: TouchEvent | MouseEvent) {\n    const element = this._document;\n    const isTouch = isTouchEvent(triggerEvent);\n    const moveEventName = isTouch ? 'touchmove' : 'mousemove';\n    const endEventName = isTouch ? 'touchend' : 'mouseup';\n    element.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\n    element.addEventListener(endEventName, this._pointerUp, activeEventOptions);\n\n    if (isTouch) {\n      element.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\n    }\n\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined' && window) {\n      window.addEventListener('blur', this._windowBlur);\n    }\n  }\n\n  /** Removes any global event listeners that we may have added. */\n  private _removeGlobalEvents() {\n    const element = this._document;\n    element.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\n    element.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\n    element.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\n    element.removeEventListener('touchend', this._pointerUp, activeEventOptions);\n    element.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\n\n    const window = this._getWindow();\n\n    if (typeof window !== 'undefined' && window) {\n      window.removeEventListener('blur', this._windowBlur);\n    }\n  }\n\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  private _getWindow(): Window {\n    return this._document.defaultView || window;\n  }\n}\n\nfunction getGesturePointFromEvent(event: TouchEvent | MouseEvent) {\n\n  // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n  const point = isTouchEvent(event)\n    ? (event.touches[0] || event.changedTouches[0])\n    : event;\n\n  return {\n    x: point.clientX,\n    y: point.clientY\n  };\n}\n\n/** Returns whether an event is a touch event. */\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return event.type[0] === 't';\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n\nimport { LyImageCropper } from './image-cropper';\nimport { LyCropperArea } from './image-cropper-area';\n\n@NgModule({\n  imports: [CommonModule],\n  exports: [LyImageCropper],\n  declarations: [LyImageCropper, LyCropperArea]\n})\nexport class LyImageCropperModule { }\n"]}