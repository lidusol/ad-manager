(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@alyle/ui'),require('@alyle/ui/field'),require('@angular/forms'),require('@angular/common'),require('@angular/cdk/platform'),require('@alyle/ui/checkbox'),exports, require('@angular/animations'), require('@angular/core'), require('@angular/forms'), require('@alyle/ui/field'), require('@alyle/ui'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/platform'), require('@angular/cdk/a11y'), require('@angular/cdk/keycodes'), require('@angular/cdk/coercion'), require('@angular/cdk/collections'), require('@angular/common'), require('@alyle/ui/checkbox')) :
    typeof define === 'function' && define.amd ? define('@alyle/ui/select', ['@angular/core','@alyle/ui','@alyle/ui/field','@angular/forms','@angular/common','@angular/cdk/platform','@alyle/ui/checkbox','exports', '@angular/animations', '@angular/core', '@angular/forms', '@alyle/ui/field', '@alyle/ui', 'rxjs', 'rxjs/operators', '@angular/cdk/platform', '@angular/cdk/a11y', '@angular/cdk/keycodes', '@angular/cdk/coercion', '@angular/cdk/collections', '@angular/common', '@alyle/ui/checkbox'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.alyle.ui,global.alyle.ui.field,global.ng.forms,global.ng.common,global.ng.cdk.platform,global.alyle.ui.checkbox,(global.ly = global.ly || {}, global.ly.select = {}), global.ng.animations, global.ng.core, global.ng.forms, global.ly.field, global.ly.core, global.rxjs, global.rxjs.operators, global.ng.cdk.platform, global.ng.cdk.a11y, global.ng.cdk.keycodes, global.ng.cdk.coercion, global.ng.cdk.collections, global.ng.common, global.ly.checkbox));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3,ɵngcc4,ɵngcc5,ɵngcc6,exports, animations, core, forms, field, ui, rxjs, operators, platform, a11y, keycodes, coercion, collections, common, checkbox) { 
var _c0 = ["templateRef"];
var _c1 = ["valueText"];
function LySelect_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("className", ctx_r1.classes.valueText);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate("\u00A0");
} }
function LySelect_div_3_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r5.triggerValue || "\u00A0");
} }
function LySelect_div_3_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngSwitchCase", "true"]);
} }
function LySelect_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, LySelect_div_3_span_1_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵtemplate(2, LySelect_div_3_2_Template, 1, 0, undefined, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("className", ctx_r2.classes.valueText)("ngSwitch", !!ctx_r2.customTrigger);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngSwitchCase", true);
} }
function LySelect_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9, 10);
    ɵngcc0.ɵɵlistener("@selectEnter.done", function LySelect_ng_template_4_Template_div_animation_selectEnter_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8._panelDoneAnimatingStream.next($event.toState); })("keydown", function LySelect_ng_template_4_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10._handleKeydown($event); });
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("font-size", ctx_r4._triggerFontSize, "px");
    ɵngcc0.ɵɵproperty("className", ctx_r4.classes.container)("@selectEnter", "in");
} }
var _c2 = [[["ly-select-trigger"]], "*"];
var _c3 = ["ly-select-trigger", "*"];
var _c4 = ["rippleContainer"];
function LyOption_ly_checkbox_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ly-checkbox", 3);
    ɵngcc0.ɵɵlistener("click", function LyOption_ly_checkbox_1_Template_ly_checkbox_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); return $event.preventDefault(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("disabled", ctx_r0.disabled)("color", ctx_r0._color)("checked", ctx_r0.isSelected);
} }
var _c5 = ["*"];
'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * Returns an exception to be thrown when attempting to assign a non-array value to a select
     * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for
     * resetting the value.
     * @docs-private
     */
    function getLySelectNonArrayValueError() {
        return Error('Value must be an array in multiple-selection mode.');
    }
    /**
     * Returns an exception to be thrown when assigning a non-function value to the comparator
     * used to determine if a value corresponds to an option. Note that whether the function
     * actually takes two values and returns a boolean is not checked.
     */
    function getLySelectNonFunctionValueError() {
        return Error('`compareWith` must be a function.');
    }

    var DEFAULT_DISABLE_RIPPLE = false;
    var STYLE_PRIORITY = -2;
    var STYLES = function (theme, ref) {
        var select = ref.selectorsOf(STYLES);
        var after = theme.after;
        return {
            $priority: STYLE_PRIORITY,
            root: function () { return function (className) { return className + "{display:block;position:relative;padding-" + after + ":1em;min-height:1em;-webkit-tap-highlight-color:transparent;}" + ui.st2c(((theme.select
                && theme.select.root
                && (theme.select.root instanceof ui.StyleCollection
                    ? theme.select.root.setTransformer(function (fn) { return fn(select); })
                    : theme.select.root(select)))), "" + className); }; },
            container: {
                background: theme.background.primary.default,
                borderRadius: '2px',
                boxShadow: ui.shadowBuilder(4),
                display: 'block',
                transformOrigin: 'inherit',
                pointerEvents: 'all',
                overflow: 'auto',
                maxHeight: '256px'
            },
            valueText: {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
            },
            option: {
                display: 'flex',
                fontFamily: theme.typography.fontFamily,
                color: theme.text.default,
                '-webkit-tap-highlight-color': 'transparent',
                backgroundColor: "rgba(0, 0, 0, 0)",
                border: 0,
                padding: '0 1em',
                margin: 0,
                outline: 'none',
                boxSizing: 'border-box',
                position: 'relative',
                justifyContent: 'flex-start',
                alignItems: 'center',
                alignContent: 'center',
                '-webkit-user-select': 'none',
                '-moz-user-select': 'none',
                '-ms-user-select': 'none',
                userSelect: 'none',
                lineHeight: 1.125,
                height: '3em',
                cursor: 'pointer',
            },
            optionActive: function (className) { return className + "{background:" + theme.hover + ";}"; },
            optionText: {
                'ly-checkbox ~ &': {
                    display: 'flex',
                    alignItems: 'inherit',
                    alignContent: 'inherit'
                }
            },
            content: {
                padding: 0,
                display: 'flex',
                justifyContent: 'inherit',
                alignItems: 'inherit',
                alignContent: 'inherit',
                width: '100%',
                height: '100%',
                boxSizing: 'border-box'
            }
        };
    };
    /** Change event object that is emitted when the select value has changed. */
    var LySelectChange = /** @class */ (function () {
        function LySelectChange(
        /** Reference to the select that emitted the change event. */
        source, 
        /** Current value of the select that emitted the event. */
        value) {
            this.source = source;
            this.value = value;
        }
        return LySelectChange;
    }());
    /** @docs-private */
    var ANIMATIONS = [
        animations.trigger('selectEnter', [
            animations.transition('void => in', [
                animations.animate('125ms cubic-bezier(0, 0, 0.2, 1)', animations.keyframes([
                    animations.style({
                        opacity: 0,
                        transform: 'scaleY(0.9)'
                    }),
                    animations.style({
                        opacity: 1,
                        transform: 'scaleY(1)'
                    })
                ]))
            ]),
            animations.transition('* => void', animations.animate('100ms 25ms linear', animations.style({ opacity: 0 })))
        ]),
    ];
    /** @docs-private */
    var LySelectBase = /** @class */ (function () {
        function LySelectBase() {
        }
        return LySelectBase;
    }());
    /** @docs-private */
    var LySelectMixinBase = ui.mixinTabIndex(LySelectBase);
    /**
     * Allows the user to customize the trigger that is displayed when the select has a value.
     */
    var LySelectTrigger = /** @class */ (function () {
        function LySelectTrigger() {
        }
LySelectTrigger.ɵfac = function LySelectTrigger_Factory(t) { return new (t || LySelectTrigger)(); };
LySelectTrigger.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LySelectTrigger, selectors: [["ly-select-trigger"]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LySelectTrigger, [{
        type: core.Directive,
        args: [{
                selector: 'ly-select-trigger'
            }]
    }], function () { return []; }, null); })();
        return LySelectTrigger;
    }());
    var LySelect = /** @class */ (function (_super) {
        __extends(LySelect, _super);
        function LySelect(_theme, sRenderer, _renderer, _el, _overlay, 
        /** @internal */
        _field, 
        /** @internal */
        _cd, _ngZone, 
        /** @docs-private */
        ngControl, _parentForm, _parentFormGroup) {
            var _this = _super.call(this) || this;
            _this._theme = _theme;
            _this.sRenderer = sRenderer;
            _this._renderer = _renderer;
            _this._el = _el;
            _this._overlay = _overlay;
            _this._field = _field;
            _this._cd = _cd;
            _this._ngZone = _ngZone;
            _this.ngControl = ngControl;
            _this._parentForm = _parentForm;
            _this._parentFormGroup = _parentFormGroup;
            /** @docs-private */
            _this.classes = _this._theme.addStyleSheet(STYLES);
            /** The cached font-size of the trigger element. */
            _this._triggerFontSize = 0;
            _this._disabled = false;
            _this._required = false;
            _this.stateChanges = new rxjs.Subject();
            _this._form = _this._parentForm || _this._parentFormGroup;
            _this._valueKey = same;
            _this._focused = false;
            _this.errorState = false;
            /** Emits when the panel element is finished transforming in. */
            _this._panelDoneAnimatingStream = new rxjs.Subject();
            /** Comparison function to specify which option is displayed. Defaults to object equality. */
            _this._compareWith = function (o1, o2) { return o1 === o2; };
            /** Emits whenever the component is destroyed. */
            _this._destroy = new rxjs.Subject();
            /** Combined stream of all of the child options' change events. */
            _this.optionSelectionChanges = rxjs.defer(function () {
                var options = _this.options;
                if (options) {
                    return options.changes.pipe(operators.startWith(options), operators.switchMap(function () { return rxjs.merge.apply(void 0, __spread(options.map(function (option) { return option.onSelectionChange; }))); }));
                }
                return _this._ngZone.onStable
                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
            });
            /** Event emitted when the select panel has been toggled. */
            _this.openedChange = new core.EventEmitter();
            /** Event emitted when the select has been opened. */
            _this._openedStream = _this.openedChange.pipe(operators.filter(function (o) { return o; }), operators.mapTo(null));
            /** Event emitted when the select has been closed. */
            _this._closedStream = _this.openedChange.pipe(operators.filter(function (o) { return !o; }), operators.mapTo(null));
            /** Event emitted when the selected value has been changed by the user. */
            _this.selectionChange = new core.EventEmitter();
            /**
             * Event that emits whenever the raw value of the select changes. This is here primarily
             * to facilitate the two-way binding for the `value` input.
             * @docs-private
             */
            _this.valueChange = new core.EventEmitter();
            /**
             * The registered callback function called when a change event occurs on the input element.
             */
            _this.onChange = function (_) { };
            /**
             * The registered callback function called when a blur event occurs on the input element.
             */
            _this.onTouched = function () { };
            if (_this.ngControl) {
                // Note: we provide the value accessor through here, instead of
                // the `providers` to avoid running into a circular import.
                _this.ngControl.valueAccessor = _this;
            }
            _this._cursorClass = _this._theme.addStyle('lyField.select', {
                '& {container}': {
                    cursor: 'pointer'
                }
            }, _this._field._getHostElement(), null, STYLE_PRIORITY, field.STYLES);
            return _this;
        }
        LySelect.prototype._onFocus = function () {
            if (!this.disabled) {
                this._focused = true;
                this.stateChanges.next();
            }
        };
        LySelect.prototype._onBlur = function () {
            this._focused = false;
            if (!this.disabled && !this._opened) {
                this.onTouched();
                this._cd.markForCheck();
                this.stateChanges.next();
            }
        };
        Object.defineProperty(LySelect.prototype, "typeaheadDebounceInterval", {
            /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */
            get: function () { return this._typeaheadDebounceInterval; },
            set: function (value) {
                var newVal = coercion.coerceNumberProperty(value);
                if (this._typeaheadDebounceInterval !== newVal && this._keyManager) {
                    this._typeaheadDebounceInterval = newVal;
                    this._keyManager.withTypeAhead(newVal);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "value", {
            /** Value of the select control. */
            get: function () { return this._value; },
            set: function (newValue) {
                if (newValue !== this._value) {
                    if (this.options) {
                        this._setSelectionByValue(newValue);
                    }
                    this._value = newValue;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "disabled", {
            get: function () {
                if (this.ngControl && this.ngControl.disabled !== null) {
                    return this.ngControl.disabled;
                }
                return this._disabled;
            },
            /** Whether the input is disabled. */
            set: function (val) {
                if (val !== this._disabled) {
                    this._disabled = ui.toBoolean(val);
                    if (this._field) {
                        if (!val && this._hasDisabledClass) {
                            this._renderer.removeClass(this._field._getHostElement(), this._field.classes.disabled);
                            if (this._cursorClass) {
                                this._renderer.addClass(this._field._getHostElement(), this._cursorClass);
                            }
                            this._hasDisabledClass = undefined;
                        }
                        else if (val) {
                            this._renderer.addClass(this._field._getHostElement(), this._field.classes.disabled);
                            if (this._cursorClass) {
                                this._renderer.removeClass(this._field._getHostElement(), this._cursorClass);
                            }
                            this._hasDisabledClass = true;
                        }
                    }
                    this.stateChanges.next();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "required", {
            get: function () { return this._required; },
            set: function (value) {
                this._required = ui.toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "multiple", {
            get: function () { return this._multiple; },
            set: function (value) {
                this._multiple = ui.toBoolean(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "valueKey", {
            get: function () { return this._valueKey; },
            /**
             * @deprecated has been deprecated in favor of `compareWith`
             */
            set: function (fn) {
                this._valueKey = fn;
                console.warn('LySelect: `[valueKey]` has been deprecated in favor of `[compareWith]`');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "placeholder", {
            get: function () { return this._placeholder; },
            set: function (val) {
                this._placeholder = val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "compareWith", {
            /**
             * Function to compare the option values with the selected values. The first argument
             * is a value from an option. The second is a value from the selection. A boolean
             * should be returned.
             */
            get: function () { return this._compareWith; },
            set: function (fn) {
                if (typeof fn !== 'function' && core.isDevMode) {
                    throw getLySelectNonFunctionValueError();
                }
                this._compareWith = fn;
                if (this._selectionModel) {
                    // A different comparator means the selection could change.
                    this._initializeSelection();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "focused", {
            get: function () {
                return this._focused;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "empty", {
            get: function () {
                return !this._selectionModel || this._selectionModel.isEmpty();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "floatingLabel", {
            get: function () {
                return this._opened ? true : !this.empty;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "triggerValue", {
            /** The value displayed in the trigger. */
            get: function () {
                if (this._multiple) {
                    var selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });
                    if (this._theme.variables.direction === ui.Dir.rtl) {
                        selectedOptions.reverse();
                    }
                    return selectedOptions.join(', ');
                }
                return this._selectionModel.selected[0].viewValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LySelect.prototype, "selected", {
            /** Current selecteds */
            get: function () {
                var selected = this._selectionModel.selected;
                return this.multiple ? selected : selected[0];
            },
            enumerable: false,
            configurable: true
        });
        LySelect.prototype.ngOnInit = function () {
            var _this = this;
            this._selectionModel = new collections.SelectionModel(this.multiple);
            this.stateChanges.next();
            // We need `distinctUntilChanged` here, because some browsers will
            // fire the animation end event twice for the same animation. See:
            // https://github.com/angular/angular/issues/24084
            this._panelDoneAnimatingStream
                .pipe(operators.distinctUntilChanged(), operators.takeUntil(this._destroy))
                .subscribe(function () {
                if (_this._opened) {
                    _this.openedChange.emit(true);
                }
                else {
                    if (_this._overlayRef) {
                        _this._overlayRef.remove();
                        _this._overlayRef = null;
                    }
                    _this.openedChange.emit(false);
                    _this.stateChanges.next();
                    _this._cd.markForCheck();
                }
            });
            var ngControl = this.ngControl;
            // update styles on disabled
            if (ngControl && ngControl.statusChanges) {
                ngControl.statusChanges.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                    _this.disabled = !!ngControl.disabled;
                });
            }
            // apply class {selectArrow} to `<select>`
            this._renderer.addClass(this._field._getHostElement(), this._field.classes.selectArrow);
            // apply default styles
            this._renderer.addClass(this._el.nativeElement, this._field.classes.inputNative);
            this._renderer.addClass(this._el.nativeElement, this.classes.root);
        };
        LySelect.prototype.ngDoCheck = function () {
            var oldVal = this.errorState;
            var newVal = !!(this.ngControl && this.ngControl.invalid && (this.ngControl.touched || (this._form && this._form.submitted)));
            if (newVal !== oldVal) {
                this.errorState = newVal;
                if (this._field) {
                    var errorClass = this._field.classes.errorState;
                    if (newVal) {
                        this._renderer.addClass(this._field._getHostElement(), errorClass);
                        this._errorClass = errorClass;
                    }
                    else if (this._errorClass) {
                        this._renderer.removeClass(this._field._getHostElement(), errorClass);
                        this._errorClass = undefined;
                    }
                    this.stateChanges.next();
                }
            }
        };
        LySelect.prototype.ngAfterContentInit = function () {
            var _this = this;
            this._initKeyManager();
            this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                _this._resetOptions();
                _this._initializeSelection();
            });
            this._selectionModel.changed.pipe(operators.takeUntil(this._destroy)).subscribe(function (event) {
                event.added.forEach(function (option) { return option.select(); });
                event.removed.forEach(function (option) { return option.deselect(); });
            });
            Promise.resolve().then(function () {
                _this.value = _this.ngControl ? _this.ngControl.value : _this._value;
                _this.stateChanges.next();
                _this._cd.markForCheck();
            });
            this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                if (!_this._opened && !_this.multiple && _this._keyManager.activeItem) {
                    _this._keyManager.activeItem._selectViaInteraction();
                }
            });
        };
        LySelect.prototype.ngOnDestroy = function () {
            this._destroy.next();
            this._destroy.complete();
            this.stateChanges.complete();
            if (this._overlayRef) {
                this._overlayRef.destroy();
            }
        };
        LySelect.prototype.open = function () {
            var _this = this;
            if (this.disabled || !this.options || !this.options.length || this._opened) {
                return;
            }
            this._opened = true;
            if (this._overlayRef) {
                this._overlayRef.destroy();
            }
            this._overlayRef = this._overlay.create(this.templateRef, null, {
                styles: {
                    top: 0,
                    left: 0,
                    pointerEvents: null
                },
                fnDestroy: this.close.bind(this),
                onResizeScroll: this._updatePlacement.bind(this)
            });
            this._keyManager.withHorizontalOrientation(null);
            this._triggerFontSize = parseInt(getComputedStyle(this._getHostElement()).fontSize || '0');
            this._highlightCorrectOption();
            this._cd.markForCheck();
            this.stateChanges.next();
            this._ngZone.onStable.pipe(operators.take(1)).subscribe(function () { return _this._updatePlacement(true); });
        };
        LySelect.prototype.close = function () {
            var _a;
            if (this._opened) {
                this._opened = false;
                (_a = this._overlayRef) === null || _a === void 0 ? void 0 : _a.detach();
                this._keyManager.withHorizontalOrientation(this._theme.variables.direction);
                this._cd.markForCheck();
                this.onTouched();
            }
        };
        /** @docs-private */
        LySelect.prototype.onContainerClick = function () {
            this.focus();
            this.open();
        };
        /** Focuses the select element. */
        LySelect.prototype.focus = function (options) {
            this._getHostElement().focus(options);
        };
        LySelect.prototype._getHostElement = function () {
            return this._el.nativeElement;
        };
        /**
         * Sets the "value" property on the input element.
         *
         * @param value The checked value
         */
        LySelect.prototype.writeValue = function (value) {
            this.value = value;
        };
        /**
         * Registers a function called when the control value changes.
         *
         * @param fn The callback function
         */
        LySelect.prototype.registerOnChange = function (fn) {
            var _this = this;
            this.onChange = function (_valueString) {
                fn(_this.value);
            };
        };
        /**
         * Registers a function called when the control is touched.
         *
         * @param fn The callback function
         */
        LySelect.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
        /**
         * Disables the select. Part of the ControlValueAccessor interface required
         * to integrate with Angular's core forms API.
         *
         * @param isDisabled Sets whether the component is disabled.
         */
        LySelect.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
            this._cd.markForCheck();
            this.stateChanges.next();
        };
        /** Handles all keydown events on the select. */
        LySelect.prototype._handleKeydown = function (event) {
            if (!this.disabled) {
                this._opened ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
            }
        };
        /** Handles keyboard events while the select is closed. */
        LySelect.prototype._handleClosedKeydown = function (event) {
            var keyCode = event.keyCode;
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW ||
                keyCode === keycodes.LEFT_ARROW || keyCode === keycodes.RIGHT_ARROW;
            var isOpenKey = keyCode === keycodes.ENTER || keyCode === keycodes.SPACE;
            var manager = this._keyManager;
            // Open the select on ALT + arrow key to match the native <select>
            if (!manager.isTyping() && (isOpenKey && !keycodes.hasModifierKey(event)) ||
                ((this.multiple || event.altKey) && isArrowKey)) {
                event.preventDefault(); // prevents the page from scrolling down when pressing space
                this.open();
            }
            else if (!this.multiple) {
                manager.onKeydown(event);
            }
        };
        /** Handles keyboard events when the selected is open. */
        LySelect.prototype._handleOpenKeydown = function (event) {
            var manager = this._keyManager;
            var keyCode = event.keyCode;
            var isArrowKey = keyCode === keycodes.DOWN_ARROW || keyCode === keycodes.UP_ARROW;
            var isTyping = manager.isTyping();
            if (isArrowKey && event.altKey) {
                // Close the select on ALT + arrow key to match the native <select>
                event.preventDefault();
                this.close();
                // Don't do anything in this case if the user is typing,
                // because the typing sequence can include the space key.
            }
            else if (!isTyping && (keyCode === keycodes.ENTER || keyCode === keycodes.SPACE) && manager.activeItem &&
                !keycodes.hasModifierKey(event)) {
                event.preventDefault();
                manager.activeItem._selectViaInteraction();
            }
            else if (!isTyping && this._multiple && keyCode === keycodes.A && event.ctrlKey) {
                event.preventDefault();
                var hasDeselectedOptions_1 = this.options.some(function (opt) { return !opt.disabled && !opt.selected; });
                this.options.forEach(function (option) {
                    if (!option.disabled) {
                        hasDeselectedOptions_1 ? option.select() : option.deselect();
                    }
                });
            }
            else {
                var previouslyFocusedIndex = manager.activeItemIndex;
                manager.onKeydown(event);
                if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&
                    manager.activeItemIndex !== previouslyFocusedIndex) {
                    manager.activeItem._selectViaInteraction();
                }
            }
        };
        LySelect.prototype._initializeSelection = function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then(function () {
                _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
                _this.stateChanges.next();
            });
        };
        /**
         * Sets the selected option based on a value. If no option can be
         * found with the designated value, the select trigger is cleared.
         */
        LySelect.prototype._setSelectionByValue = function (value) {
            var _this = this;
            if (this.multiple && value) {
                if (!Array.isArray(value) && core.isDevMode()) {
                    throw getLySelectNonArrayValueError();
                }
                this._selectionModel.clear();
                value.forEach(function (currentValue) { return _this._selectValue(currentValue); });
                this._sortValues();
            }
            else {
                this._selectionModel.clear();
                var correspondingOption = this._selectValue(value);
                // Shift focus to the active item. Note that we shouldn't do this in multiple
                // mode, because we don't know what option the user interacted with last.
                if (correspondingOption) {
                    this._keyManager.updateActiveItem(correspondingOption);
                }
                else if (!this._opened) {
                    // Otherwise reset the highlighted option. Note that we only want to do this while
                    // closed, because doing it while open can shift the user's focus unnecessarily.
                    this._keyManager.updateActiveItem(-1);
                }
            }
            this._cd.markForCheck();
        };
        /**
         * Finds and selects and option based on its value.
         * @returns Option that has the corresponding value.
         */
        LySelect.prototype._selectValue = function (value) {
            var _this = this;
            var correspondingOption = this.options.find(function (option) {
                if (_this._valueKey !== same) {
                    return _this.valueKey(option.value) === _this.valueKey(value);
                }
                try {
                    // Treat null as a special reset value.
                    return option.value != null && _this._compareWith(option.value, value);
                }
                catch (error) {
                    if (core.isDevMode()) {
                        // Notify developers of errors in their comparator.
                        console.warn(error);
                    }
                    return false;
                }
            });
            if (correspondingOption) {
                this._selectionModel.select(correspondingOption);
            }
            return correspondingOption;
        };
        LySelect.prototype._updatePlacement = function (updateScroll) {
            var el = this._overlayRef.containerElement;
            var container = el.querySelector('div');
            var triggerFontSize = this._triggerFontSize;
            var nativeElement = this.valueTextDivRef.nativeElement;
            var panelWidth;
            if (this.multiple) {
                panelWidth = nativeElement.offsetWidth + triggerFontSize * 4;
            }
            else {
                panelWidth = nativeElement.offsetWidth + triggerFontSize * 2;
            }
            // reset height & width
            this._renderer.setStyle(container, 'height', 'initial');
            this._renderer.setStyle(container, 'width', panelWidth + "px");
            var selectedElement = this._selectionModel.isEmpty()
                ? el.querySelector('ly-option')
                : this._selectionModel.selected[0]._getHostElement();
            if (!selectedElement) {
                selectedElement = (el.firstElementChild.firstElementChild || el.firstElementChild);
            }
            var offset = {
                y: -(nativeElement.offsetHeight / 2 + selectedElement.offsetTop + selectedElement.offsetHeight / 2),
                x: -triggerFontSize
            };
            // scroll to selected option
            if (container.scrollHeight !== container.offsetHeight) {
                if (updateScroll) {
                    if (container.scrollTop === selectedElement.offsetTop) {
                        container.scrollTop = container.scrollTop - (container.offsetHeight / 2) + selectedElement.offsetHeight / 2;
                    }
                    else {
                        container.scrollTop = container.scrollTop
                            - (container.offsetHeight / 2 - (selectedElement.offsetTop - container.scrollTop)) + selectedElement.offsetHeight / 2;
                    }
                }
                offset.y = container.scrollTop + offset.y;
            }
            if (this.multiple) {
                offset.x -= 24;
            }
            var position = new ui.Positioning(ui.YPosition.below, ui.XPosition.after, null, nativeElement, el, this._theme.variables, offset, false);
            // set position
            this._renderer.setStyle(el, 'transform', "translate3d(" + position.x + "px, " + position.y + "px, 0)");
            this._renderer.setStyle(el, 'transform-origin', position.ox + " " + position.oy + " 0");
            // set height & width
            this._renderer.setStyle(container, 'height', position.height);
            var width = position.width === 'initial'
                ? panelWidth + "px"
                : position.width;
            this._renderer.setStyle(container, 'width', width);
        };
        /** Sets up a key manager to listen to keyboard events on the overlay panel. */
        LySelect.prototype._initKeyManager = function () {
            var _this = this;
            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options)
                .withTypeAhead(this._typeaheadDebounceInterval)
                .withVerticalOrientation()
                .withHorizontalOrientation(this._theme.variables.direction)
                .withHomeAndEnd()
                .withAllowedModifierKeys(['shiftKey']);
            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                if (_this._opened) {
                    // Select the active item when tabbing away. This is consistent with how the native
                    // select behaves. Note that we only want to do this in single selection mode.
                    if (!_this.multiple && _this._keyManager.activeItem) {
                        _this._keyManager.activeItem._selectViaInteraction();
                    }
                    // Restore focus to the trigger before closing. Ensures that the focus
                    // position won't be lost if the user got focus into the overlay.
                    _this.focus();
                    _this.close();
                }
            });
            this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                if (_this._opened) {
                    _this._scrollActiveOptionIntoView();
                }
                else if (!_this._opened && !_this.multiple && _this._keyManager.activeItem) {
                    _this._keyManager.activeItem._selectViaInteraction();
                }
            });
        };
        /** Sorts the selected values in the selected based on their order in the panel. */
        LySelect.prototype._sortValues = function () {
            var _this = this;
            if (this.multiple) {
                var options_1 = this.options.toArray();
                this._selectionModel.sort(function (a, b) {
                    return _this.sortComparator ? _this.sortComparator(a, b, options_1) :
                        options_1.indexOf(a) - options_1.indexOf(b);
                });
                this.stateChanges.next();
            }
        };
        LySelect.prototype._resetOptions = function () {
            var _this = this;
            var changedOrDestroyed = rxjs.merge(this.options.changes, this._destroy);
            this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
                _this._onSelect(event.source, event.isUserInput);
                if (event.isUserInput && !_this.multiple && _this._opened) {
                    _this.close();
                    _this.focus();
                }
            });
        };
        /** Invoked when an option is clicked. */
        LySelect.prototype._onSelect = function (option, isUserInput) {
            var wasSelected = this._selectionModel.isSelected(option);
            if (option.value == null && !this._multiple) {
                option.deselect();
                this._selectionModel.clear();
                if (this.value != null) {
                    this._propagateChanges(option.value);
                }
            }
            else {
                if (wasSelected !== option.selected) {
                    option.selected ? this._selectionModel.select(option) :
                        this._selectionModel.deselect(option);
                }
                if (isUserInput) {
                    this._keyManager.setActiveItem(option);
                }
                if (this.multiple) {
                    this._sortValues();
                    if (isUserInput) {
                        // In case the user selected the option with their mouse, we
                        // want to restore focus back to the trigger, in order to
                        // prevent the select keyboard controls from clashing with
                        // the ones from `ly-option`.
                        this.focus();
                    }
                }
            }
            if (wasSelected !== this._selectionModel.isSelected(option)) {
                this._propagateChanges();
            }
            this.stateChanges.next();
        };
        /** Emits change event to set the model value. */
        LySelect.prototype._propagateChanges = function (fallbackValue) {
            var valueToEmit = null;
            if (this.multiple) {
                valueToEmit = this.selected.map(function (option) { return option.value; });
            }
            else {
                valueToEmit = this.selected ? this.selected.value : fallbackValue;
            }
            this._value = valueToEmit;
            this.valueChange.emit(valueToEmit);
            this.onChange(valueToEmit);
            this.selectionChange.emit(new LySelectChange(this, valueToEmit));
            this._cd.markForCheck();
        };
        /**
         * Highlights the selected item. If no option is selected, it will highlight
         * the first item instead.
         */
        LySelect.prototype._highlightCorrectOption = function () {
            if (this._keyManager) {
                if (this.empty) {
                    this._keyManager.setFirstItemActive();
                }
                else {
                    this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                }
            }
        };
        /** Scrolls the active option into view. */
        LySelect.prototype._scrollActiveOptionIntoView = function () {
            var el = this._overlayRef.containerElement;
            var container = el.querySelector('div');
            var activeOption = this._keyManager.activeItem._getHostElement();
            // const containerRect = container.getBoundingClientRect();
            // const activeOptionRect = ;
            if (typeof activeOption.scrollIntoView === 'function') {
                if (container.scrollTop > activeOption.offsetTop) {
                    container.scrollTop = activeOption.offsetTop;
                }
                else if (container.scrollTop + container.offsetHeight < activeOption.offsetTop + activeOption.offsetHeight) {
                    container.scrollTop = activeOption.offsetTop - container.offsetHeight + activeOption.offsetHeight;
                }
            }
        };
LySelect.ɵfac = function LySelect_Factory(t) { return new (t || LySelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyOverlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LyField, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.FormGroupDirective, 8)); };
LySelect.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LySelect, selectors: [["ly-select"]], contentQueries: function LySelect_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LySelectTrigger, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, LyOption, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTrigger = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, viewQuery: function LySelect_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
        ɵngcc0.ɵɵviewQuery(LyOption, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextDivRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._options = _t.first);
    } }, hostVars: 1, hostBindings: function LySelect_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function LySelect_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })("focus", function LySelect_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function LySelect_blur_HostBindingHandler() { return ctx._onBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex);
    } }, inputs: { tabIndex: "tabIndex", typeaheadDebounceInterval: "typeaheadDebounceInterval", value: "value", disabled: "disabled", required: "required", multiple: "multiple", valueKey: "valueKey", placeholder: "placeholder", compareWith: "compareWith", sortComparator: "sortComparator" }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, exportAs: ["lySelect"], features: [ɵngcc0.ɵɵProvidersFeature([
            ui.StyleRenderer,
            { provide: field.LyFieldControlBase, useExisting: LySelect }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c3, decls: 6, vars: 2, consts: [[3, "ngSwitch"], ["valueText", ""], [3, "className", 4, "ngSwitchCase"], [3, "className", "ngSwitch", 4, "ngSwitchDefault"], ["templateRef", ""], [3, "className"], [3, "className", "ngSwitch"], [4, "ngSwitchDefault"], [4, "ngSwitchCase"], ["tabindex", "-1", "role", "listbox", 3, "className", "keydown"], ["container", ""]], template: function LySelect_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, LySelect_div_2_Template, 2, 2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, LySelect_div_3_Template, 3, 3, "div", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, LySelect_ng_template_4_Template, 3, 4, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.empty);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngSwitchCase", true);
    } }, directives: [ɵngcc4.NgSwitch, ɵngcc4.NgSwitchCase, ɵngcc4.NgSwitchDefault], encapsulation: 2, data: { animation: __spread(ANIMATIONS) }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LySelect, [{
        type: core.Component,
        args: [{
                selector: 'ly-select',
                template: "<div #valueText [ngSwitch]=\"empty\">\n  <div [className]=\"classes.valueText\" *ngSwitchCase=\"true\">{{ '\\u00A0' }}</div>\n  <div [className]=\"classes.valueText\" *ngSwitchDefault [ngSwitch]=\"!!customTrigger\">\n    <span *ngSwitchDefault>{{ triggerValue || '\\u00A0' }}</span>\n    <ng-content select=\"ly-select-trigger\" *ngSwitchCase=\"true\"></ng-content>\n  </div>\n</div>\n\n<ng-template #templateRef>\n  <div\n    #container\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [className]=\"classes.container\"\n    [@selectEnter]=\"'in'\"\n    (@selectEnter.done)=\"_panelDoneAnimatingStream.next($event.toState)\"\n    (keydown)=\"_handleKeydown($event)\"\n    [style.font-size.px]=\"_triggerFontSize\"\n  >\n    <ng-content></ng-content>\n  </div>\n</ng-template>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                exportAs: 'lySelect',
                host: {
                    '[attr.tabindex]': 'tabIndex',
                    '(keydown)': '_handleKeydown($event)',
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()'
                },
                animations: __spread(ANIMATIONS),
                inputs: ['tabIndex'],
                providers: [
                    ui.StyleRenderer,
                    { provide: field.LyFieldControlBase, useExisting: LySelect }
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LyTheme2 }, { type: ɵngcc1.StyleRenderer }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.LyOverlay }, { type: ɵngcc2.LyField, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc3.NgControl, decorators: [{
                type: core.Optional
            }, {
                type: core.Self
            }] }, { type: ɵngcc3.NgForm, decorators: [{
                type: core.Optional
            }] }, { type: ɵngcc3.FormGroupDirective, decorators: [{
                type: core.Optional
            }] }]; }, { typeaheadDebounceInterval: [{
            type: core.Input
        }], value: [{
            type: core.Input
        }], disabled: [{
            type: core.Input
        }], required: [{
            type: core.Input
        }], multiple: [{
            type: core.Input
        }], valueKey: [{
            type: core.Input
        }], placeholder: [{
            type: core.Input
        }], compareWith: [{
            type: core.Input
        }], templateRef: [{
            type: core.ViewChild,
            args: ['templateRef']
        }], valueTextDivRef: [{
            type: core.ViewChild,
            args: ['valueText']
        }], _options: [{
            type: core.ViewChild,
            args: [core.forwardRef(function () { return LyOption; })]
        }], options: [{
            type: core.ContentChildren,
            args: [core.forwardRef(function () { return LyOption; }), { descendants: true }]
        }], customTrigger: [{
            type: core.ContentChild,
            args: [LySelectTrigger]
        }], openedChange: [{
            type: core.Output
        }], _openedStream: [{
            type: core.Output,
            args: ['opened']
        }], _closedStream: [{
            type: core.Output,
            args: ['closed']
        }], selectionChange: [{
            type: core.Output
        }], valueChange: [{
            type: core.Output
        }], sortComparator: [{
            type: core.Input
        }] }); })();
        return LySelect;
    }(LySelectMixinBase));
    LySelect.ctorParameters = function () { return [
        { type: ui.LyTheme2 },
        { type: ui.StyleRenderer },
        { type: core.Renderer2 },
        { type: core.ElementRef },
        { type: ui.LyOverlay },
        { type: field.LyField, decorators: [{ type: core.Optional }] },
        { type: core.ChangeDetectorRef },
        { type: core.NgZone },
        { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
        { type: forms.NgForm, decorators: [{ type: core.Optional }] },
        { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
    ]; };
    LySelect.propDecorators = {
        templateRef: [{ type: core.ViewChild, args: ['templateRef',] }],
        valueTextDivRef: [{ type: core.ViewChild, args: ['valueText',] }],
        _options: [{ type: core.ViewChild, args: [core.forwardRef(function () { return LyOption; }),] }],
        options: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return LyOption; }), { descendants: true },] }],
        customTrigger: [{ type: core.ContentChild, args: [LySelectTrigger,] }],
        openedChange: [{ type: core.Output }],
        _openedStream: [{ type: core.Output, args: ['opened',] }],
        _closedStream: [{ type: core.Output, args: ['closed',] }],
        selectionChange: [{ type: core.Output }],
        valueChange: [{ type: core.Output }],
        typeaheadDebounceInterval: [{ type: core.Input }],
        value: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        required: [{ type: core.Input }],
        multiple: [{ type: core.Input }],
        valueKey: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        compareWith: [{ type: core.Input }],
        sortComparator: [{ type: core.Input }]
    };
    /** Event object emitted by LyOption when selected or deselected. */
    var LyOptionSelectionChange = /** @class */ (function () {
        function LyOptionSelectionChange(
        /** Reference to the option that emitted the event. */
        source, 
        /** Whether the change in the option's value was a result of a user action. */
        isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.source = source;
            this.isUserInput = isUserInput;
        }
        return LyOptionSelectionChange;
    }());
    /** @docs-private */
    var LyOptionBase = /** @class */ (function () {
        function LyOptionBase(_theme, _ngZone, _platform) {
            this._theme = _theme;
            this._ngZone = _ngZone;
            this._platform = _platform;
        }
        return LyOptionBase;
    }());
    /** @docs-private */
    var LyOptionMixinBase = ui.mixinDisableRipple(LyOptionBase);
    var ɵ0 = function (value) { return function (theme) { return function (className) { return className + "{color:" + theme.colorOf(value) + ";}"; }; }; };
    /**
     * @dynamic
     */
    var LyOption = /** @class */ (function (_super) {
        __extends(LyOption, _super);
        function LyOption(sRenderer, 
        /** @internal */
        _select, _el, 
        /** @internal */
        _rippleService, _renderer, _theme, 
        /** @internal */
        _cd, _ngZone, platform) {
            var _this = _super.call(this, _theme, _ngZone, platform) || this;
            _this.sRenderer = sRenderer;
            _this._select = _select;
            _this._el = _el;
            _this._rippleService = _rippleService;
            _this._cd = _cd;
            /** @docs-private */
            _this.classes = _this._theme.addStyleSheet(STYLES, STYLE_PRIORITY);
            _this._selected = false;
            _this._disabled = false;
            /** Event emitted when the option is selected or deselected. */
            // tslint:disable-next-line: no-output-on-prefix
            _this.onSelectionChange = new core.EventEmitter();
            _renderer.addClass(_el.nativeElement, _this.classes.option);
            _this._triggerElement = _el;
            return _this;
        }
        LyOption.prototype._onClick = function () {
            this._selectViaInteraction();
        };
        Object.defineProperty(LyOption.prototype, "selected", {
            /** Whether or not the option is currently selected. */
            get: function () { return this._selected; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "multiple", {
            /** Whether the wrapping component is in multiple selection mode. */
            get: function () { return this._select && this._select.multiple; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "value", {
            get: function () {
                return this._value;
            },
            /**
             * Tracks simple string values bound to the option element.
             */
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            /** Whether the option is disabled. */
            set: function (value) {
                this._disabled = coercion.coerceBooleanProperty(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "viewValue", {
            /** The displayed value of the option. */
            get: function () {
                return (this._getHostElement().textContent || '').trim();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "_color", {
            /** The color of Select option */
            get: function () {
                return this._selected ? this._select._field.color : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyOption.prototype, "isSelected", {
            /**
             * @deprecated use instead `selected`
             */
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        LyOption.prototype.ngOnInit = function () {
            if (this.disableRipple == null) {
                this.disableRipple = DEFAULT_DISABLE_RIPPLE;
            }
        };
        LyOption.prototype.ngOnChanges = function () { };
        /** Applies the styles for an active item to this item. */
        LyOption.prototype.setActiveStyles = function () {
            this.sRenderer.addClass(this.classes.optionActive);
        };
        /** Applies the styles for an inactive item to this item. */
        LyOption.prototype.setInactiveStyles = function () {
            this.sRenderer.removeClass(this.classes.optionActive);
        };
        /** Gets the label to be used when determining whether the option should be focused. */
        LyOption.prototype.getLabel = function () {
            return this.viewValue;
        };
        /** Selects the option. */
        LyOption.prototype.select = function () {
            if (!this._selected) {
                this._selected = true;
                this._selectedColor = this._color;
                this._cd.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** Deselects the option. */
        LyOption.prototype.deselect = function () {
            if (this._selected) {
                this._selected = false;
                this._selectedColor = null;
                this._cd.markForCheck();
                this._emitSelectionChangeEvent();
            }
        };
        /** Sets focus onto this option. */
        LyOption.prototype.focus = function (_origin, options) {
            var element = this._getHostElement();
            if (typeof element.focus === 'function') {
                element.focus(options);
            }
        };
        /** Ensures the option is selected when activated from the keyboard. */
        LyOption.prototype._handleKeydown = function (event) {
            // tslint:disable-next-line: deprecation
            if ((event.keyCode === keycodes.ENTER || event.keyCode === keycodes.SPACE) && !keycodes.hasModifierKey(event)) {
                this._selectViaInteraction();
                // Prevent the page from scrolling down and form submits.
                event.preventDefault();
            }
        };
        /**
         * `Selects the option while indicating the selection came from the user. Used to
         * determine if the select's view -> model callback should be invoked.`
         */
        LyOption.prototype._selectViaInteraction = function () {
            if (!this.disabled) {
                this._selected = this.multiple ? !this._selected : true;
                this._selectedColor = this._color;
                this._cd.markForCheck();
                this._emitSelectionChangeEvent(true);
            }
        };
        /** @internal */
        LyOption.prototype._getHostElement = function () {
            return this._el.nativeElement;
        };
        /** Returns the correct tabindex for the option depending on disabled state. */
        LyOption.prototype._getTabIndex = function () {
            return this.disabled ? '-1' : '0';
        };
        /** Emits the selection change event. */
        LyOption.prototype._emitSelectionChangeEvent = function (isUserInput) {
            if (isUserInput === void 0) { isUserInput = false; }
            this.onSelectionChange.emit(new LyOptionSelectionChange(this, isUserInput));
        };
LyOption.ɵfac = function LyOption_Factory(t) { return new (t || LyOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer), ɵngcc0.ɵɵdirectiveInject(LySelect), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyRippleService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Platform)); };
LyOption.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyOption, selectors: [["ly-option"]], viewQuery: function LyOption_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rippleContainer = _t.first);
    } }, hostAttrs: ["role", "option"], hostVars: 1, hostBindings: function LyOption_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function LyOption_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })("click", function LyOption_click_HostBindingHandler() { return ctx._onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx._getTabIndex());
    } }, inputs: { disableRipple: "disableRipple", value: "value", disabled: "disabled" }, outputs: { onSelectionChange: "onSelectionChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            ui.StyleRenderer
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c5, decls: 6, vars: 4, consts: [[3, "className"], [3, "disabled", "color", "checked", "click", 4, "ngIf"], ["rippleContainer", ""], [3, "disabled", "color", "checked", "click"]], template: function LyOption_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, LyOption_ly_checkbox_1_Template, 1, 3, "ly-checkbox", 1);
        ɵngcc0.ɵɵelementStart(2, "span", 0);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 0, 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.classes.content);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx._select.multiple);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("className", ctx.classes.optionText);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("className", ctx._rippleService.classes.container);
    } }, directives: [ɵngcc4.NgIf, ɵngcc6.LyCheckbox], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyOption, [{
        type: core.Component,
        args: [{
                selector: 'ly-option',
                template: "<span [className]=\"classes.content\">\n  <ly-checkbox [disabled]=\"disabled\"\n    [color]=\"_color\"\n    [checked]=\"isSelected\"\n    *ngIf=\"_select.multiple\"\n    (click)=\"$event.preventDefault()\"\n  ></ly-checkbox>\n  <span [className]=\"classes.optionText\"><ng-content></ng-content></span>\n</span>\n<div #rippleContainer [className]=\"_rippleService.classes.container\"></div>",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                host: {
                    'role': 'option',
                    '(keydown)': '_handleKeydown($event)',
                    '[attr.tabindex]': '_getTabIndex()'
                },
                inputs: [
                    'disableRipple'
                ],
                providers: [
                    ui.StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc1.StyleRenderer }, { type: LySelect }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.LyRippleService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc5.Platform }]; }, { _onClick: [{
            type: core.HostListener,
            args: ['click']
        }], value: [{
            type: core.Input,
            args: ['value']
        }], disabled: [{
            type: core.Input
        }], _rippleContainer: [{
            type: core.ViewChild,
            args: ['rippleContainer']
        }], onSelectionChange: [{
            type: core.Output
        }] }); })();
        return LyOption;
    }(LyOptionMixinBase));
    LyOption.ctorParameters = function () { return [
        { type: ui.StyleRenderer },
        { type: LySelect },
        { type: core.ElementRef },
        { type: ui.LyRippleService },
        { type: core.Renderer2 },
        { type: ui.LyTheme2 },
        { type: core.ChangeDetectorRef },
        { type: core.NgZone },
        { type: platform.Platform }
    ]; };
    LyOption.propDecorators = {
        _rippleContainer: [{ type: core.ViewChild, args: ['rippleContainer',] }],
        onSelectionChange: [{ type: core.Output }],
        _onClick: [{ type: core.HostListener, args: ['click',] }],
        value: [{ type: core.Input, args: ['value',] }],
        disabled: [{ type: core.Input }]
    };
    __decorate([
        ui.Style(ɵ0)
    ], LyOption.prototype, "_selectedColor", void 0);
    function same(o) {
        return o;
    }

    var LySelectModule = /** @class */ (function () {
        function LySelectModule() {
        }
LySelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LySelectModule });
LySelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LySelectModule_Factory(t) { return new (t || LySelectModule)(); }, imports: [[
            common.CommonModule,
            ui.LyCommonModule,
            checkbox.LyCheckboxModule,
            ui.LyOverlayModule
        ], ɵngcc1.LyCommonModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LySelectModule, { declarations: [LySelect,
        LyOption,
        LySelectTrigger], imports: [ɵngcc4.CommonModule, ɵngcc1.LyCommonModule, ɵngcc6.LyCheckboxModule, ɵngcc1.LyOverlayModule], exports: [LySelect,
        LyOption,
        LySelectTrigger, ɵngcc1.LyCommonModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LySelectModule, [{
        type: core.NgModule,
        args: [{
                declarations: [LySelect, LyOption, LySelectTrigger],
                imports: [
                    common.CommonModule,
                    ui.LyCommonModule,
                    checkbox.LyCheckboxModule,
                    ui.LyOverlayModule
                ],
                exports: [LySelect, LyOption, LySelectTrigger, ui.LyCommonModule]
            }]
    }], function () { return []; }, null); })();
        return LySelectModule;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.LyOption = LyOption;
    exports.LyOptionBase = LyOptionBase;
    exports.LyOptionMixinBase = LyOptionMixinBase;
    exports.LyOptionSelectionChange = LyOptionSelectionChange;
    exports.LySelect = LySelect;
    exports.LySelectBase = LySelectBase;
    exports.LySelectChange = LySelectChange;
    exports.LySelectMixinBase = LySelectMixinBase;
    exports.LySelectModule = LySelectModule;
    exports.LySelectTrigger = LySelectTrigger;
    exports.STYLES = STYLES;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=alyle-ui-select.umd.js.map