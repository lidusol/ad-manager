import { Component, ChangeDetectionStrategy, Input, ElementRef, Renderer2 } from '@angular/core';
import { LyTheme2 } from '../theme/theme2.service';
import { toBoolean } from '../minimal/is-boolean';
import * as ɵngcc0 from '@angular/core';
const STYLES = (theme) => ({
    root: {
        width: '1em',
        height: '1em',
        display: 'inline-block',
        position: 'relative',
        fontSize: '24px'
    },
    line: {
        top: 'calc(0.5em - 1px)',
        position: 'absolute',
        width: `${1 / 3}em`,
        height: '2px',
        backgroundColor: 'currentColor',
        display: 'inline-block',
        transition: `all ${theme.animations.durations.entering}ms ${theme.animations.curves.standard}`,
        '&:first-of-type': {
            left: '0.25em',
            '-webkit-transform': 'rotate(45deg)',
            transform: 'rotate(45deg)'
        },
        '&:last-of-type': {
            right: '0.25em',
            '-webkit-transform': 'rotate(-45deg)',
            transform: 'rotate(-45deg)'
        }
    },
    up: {
        '{line}:first-of-type': {
            '-webkit-transform': 'rotate(-45deg)',
            transform: 'rotate(-45deg)'
        },
        '{line}:last-of-type': {
            '-webkit-transform': 'rotate(45deg)',
            transform: 'rotate(45deg)'
        }
    }
});
const ɵ0 = STYLES;
export class LyExpansionIcon {
    constructor(_theme, _renderer, _el) {
        this._theme = _theme;
        this._renderer = _renderer;
        this._el = _el;
        this.classes = this._theme.addStyleSheet(STYLES);
        this._up = false;
        _renderer.addClass(_el.nativeElement, this.classes.root);
    }
    set color(val) {
        this._colorClass = this._theme.addStyle('LyExpansionIcon.color', (theme) => ({
            '{line}': {
                backgroundColor: theme.colorOf(val)
            }
        }), this._el.nativeElement, this._colorClass, null, STYLES);
    }
    get color() {
        return this._color;
    }
    set up(val) {
        const newVal = toBoolean(val);
        if (newVal !== this.up) {
            this._up = newVal;
            if (newVal) {
                this._renderer.addClass(this._el.nativeElement, this.classes.up);
            }
            else {
                this._renderer.removeClass(this._el.nativeElement, this.classes.up);
            }
        }
    }
    get up() {
        return this._up;
    }
    toggle() {
        this.up = !this.up;
    }
}
LyExpansionIcon.ɵfac = function LyExpansionIcon_Factory(t) { return new (t || LyExpansionIcon)(ɵngcc0.ɵɵdirectiveInject(LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
LyExpansionIcon.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LyExpansionIcon, selectors: [["ly-expansion-icon"]], inputs: { color: "color", up: "up" }, decls: 2, vars: 2, consts: [[3, "className"]], template: function LyExpansionIcon_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelement(1, "span", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("className", ctx.classes.line);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("className", ctx.classes.line);
    } }, encapsulation: 2, changeDetection: 0 });
LyExpansionIcon.ctorParameters = () => [
    { type: LyTheme2 },
    { type: Renderer2 },
    { type: ElementRef }
];
LyExpansionIcon.propDecorators = {
    color: [{ type: Input }],
    up: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyExpansionIcon, [{
        type: Component,
        args: [{
                selector: 'ly-expansion-icon',
                template: "<span [className]=\"classes.line\"></span>\n<span [className]=\"classes.line\"></span>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: LyTheme2 }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { color: [{
            type: Input
        }], up: [{
            type: Input
        }] }); })();
export { ɵ0 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5zaW9uLWljb24uanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYi9zcmMvZXhwYW5zaW9uLWljb24vZXhwYW5zaW9uLWljb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSx1QkFBdUIsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFbkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztBQUVsRCxNQUFNLE1BQU0sR0FBRyxDQUFDLEtBQXFCLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDM0MsSUFBRSxJQUFJLEVBQUU7QUFDUixRQUFJLEtBQUssRUFBRSxLQUFLO0FBQ2hCLFFBQUksTUFBTSxFQUFFLEtBQUs7QUFDakIsUUFBSSxPQUFPLEVBQUUsY0FBYztBQUMzQixRQUFJLFFBQVEsRUFBRSxVQUFVO0FBQ3hCLFFBQUksUUFBUSxFQUFFLE1BQU07QUFDcEIsS0FBRztBQUNILElBQUUsSUFBSSxFQUFFO0FBQ1IsUUFBSSxHQUFHLEVBQUUsbUJBQW1CO0FBQzVCLFFBQUksUUFBUSxFQUFFLFVBQVU7QUFDeEIsUUFBSSxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJO0FBQ3ZCLFFBQUksTUFBTSxFQUFFLEtBQUs7QUFDakIsUUFBSSxlQUFlLEVBQUUsY0FBYztBQUNuQyxRQUFJLE9BQU8sRUFBRSxjQUFjO0FBQzNCLFFBQUksVUFBVSxFQUFFLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsUUFBUSxNQUFNLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtBQUNsRyxRQUFJLGlCQUFpQixFQUFFO0FBQ3ZCLFlBQU0sSUFBSSxFQUFFLFFBQVE7QUFDcEIsWUFBTSxtQkFBbUIsRUFBRSxlQUFlO0FBQzFDLFlBQU0sU0FBUyxFQUFFLGVBQWU7QUFDaEMsU0FBSztBQUNMLFFBQUksZ0JBQWdCLEVBQUU7QUFDdEIsWUFBTSxLQUFLLEVBQUUsUUFBUTtBQUNyQixZQUFNLG1CQUFtQixFQUFFLGdCQUFnQjtBQUMzQyxZQUFNLFNBQVMsRUFBRSxnQkFBZ0I7QUFDakMsU0FBSztBQUNMLEtBQUc7QUFDSCxJQUFFLEVBQUUsRUFBRTtBQUNOLFFBQUksc0JBQXNCLEVBQUU7QUFDNUIsWUFBTSxtQkFBbUIsRUFBRSxnQkFBZ0I7QUFDM0MsWUFBTSxTQUFTLEVBQUUsZ0JBQWdCO0FBQ2pDLFNBQUs7QUFDTCxRQUFJLHFCQUFxQixFQUFFO0FBQzNCLFlBQU0sbUJBQW1CLEVBQUUsZUFBZTtBQUMxQyxZQUFNLFNBQVMsRUFBRSxlQUFlO0FBQ2hDLFNBQUs7QUFDTCxLQUFHO0FBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQU1BLE1BQU0sT0FBTyxlQUFlO0FBQzVCLElBbUNFLFlBQ1UsTUFBZ0IsRUFDaEIsU0FBb0IsRUFDcEIsR0FBZTtBQUN4QixRQUhTLFdBQU0sR0FBTixNQUFNLENBQVU7QUFBQyxRQUNqQixjQUFTLEdBQVQsU0FBUyxDQUFXO0FBQUMsUUFDckIsUUFBRyxHQUFILEdBQUcsQ0FBWTtBQUMzQixRQXZDVyxZQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdkQsUUFJVSxRQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ3RCLFFBa0NJLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdELElBQUUsQ0FBQztBQUNILElBbkNFLElBQ0ksS0FBSyxDQUFDLEdBQVc7QUFDdkIsUUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLHVCQUF1QixFQUFFLENBQUMsS0FBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqRyxZQUFNLFFBQVEsRUFBRTtBQUNoQixnQkFBUSxlQUFlLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDM0MsYUFBTztBQUNQLFNBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLElBQUUsQ0FBQztBQUNILElBQUUsSUFBSSxLQUFLO0FBQ1gsUUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDdkIsSUFBRSxDQUFDO0FBQ0gsSUFBRSxJQUNJLEVBQUUsQ0FBQyxHQUFpQjtBQUMxQixRQUFJLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQyxRQUNJLElBQUksTUFBTSxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUU7QUFDNUIsWUFBTSxJQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQztBQUN4QixZQUFNLElBQUksTUFBTSxFQUFFO0FBQ2xCLGdCQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekUsYUFBTztBQUFDLGlCQUFLO0FBQ2IsZ0JBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM1RSxhQUFPO0FBQ1AsU0FBSztBQUNMLElBQUUsQ0FBQztBQUNILElBQUUsSUFBSSxFQUFFO0FBQ1IsUUFBSSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDcEIsSUFBRSxDQUFDO0FBQ0gsSUFTRSxNQUFNO0FBQ1IsUUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUN2QixJQUFFLENBQUM7QUFDSDsyQ0FwREMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxtQkFBbUIsa0JBQzdCO0FBQW9DLGtCQUNwQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTSxjQUNoRDs7Ozs7OztpREFDSTtBQUFDO0FBQ1UsWUFqRFAsUUFBUTtBQUFJLFlBRDJDLFNBQVM7QUFBSSxZQUF6QixVQUFVO0FBQUc7QUFBRztBQUMvRCxvQkF3REYsS0FBSztBQUNOLGlCQVVDLEtBQUs7QUFDUDs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUM7QUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIElucHV0LCBFbGVtZW50UmVmLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEx5VGhlbWUyIH0gZnJvbSAnLi4vdGhlbWUvdGhlbWUyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGhlbWVWYXJpYWJsZXMgfSBmcm9tICcuLi90aGVtZS90aGVtZS1jb25maWcnO1xuaW1wb3J0IHsgdG9Cb29sZWFuIH0gZnJvbSAnLi4vbWluaW1hbC9pcy1ib29sZWFuJztcblxuY29uc3QgU1RZTEVTID0gKHRoZW1lOiBUaGVtZVZhcmlhYmxlcykgPT4gKHtcbiAgcm9vdDoge1xuICAgIHdpZHRoOiAnMWVtJyxcbiAgICBoZWlnaHQ6ICcxZW0nLFxuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIGZvbnRTaXplOiAnMjRweCdcbiAgfSxcbiAgbGluZToge1xuICAgIHRvcDogJ2NhbGMoMC41ZW0gLSAxcHgpJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogYCR7MSAvIDN9ZW1gLFxuICAgIGhlaWdodDogJzJweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICB0cmFuc2l0aW9uOiBgYWxsICR7dGhlbWUuYW5pbWF0aW9ucy5kdXJhdGlvbnMuZW50ZXJpbmd9bXMgJHt0aGVtZS5hbmltYXRpb25zLmN1cnZlcy5zdGFuZGFyZH1gLFxuICAgICcmOmZpcnN0LW9mLXR5cGUnOiB7XG4gICAgICBsZWZ0OiAnMC4yNWVtJyxcbiAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICdyb3RhdGUoNDVkZWcpJyxcbiAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg0NWRlZyknXG4gICAgfSxcbiAgICAnJjpsYXN0LW9mLXR5cGUnOiB7XG4gICAgICByaWdodDogJzAuMjVlbScsXG4gICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiAncm90YXRlKC00NWRlZyknLFxuICAgICAgdHJhbnNmb3JtOiAncm90YXRlKC00NWRlZyknXG4gICAgfVxuICB9LFxuICB1cDoge1xuICAgICd7bGluZX06Zmlyc3Qtb2YtdHlwZSc6IHtcbiAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICdyb3RhdGUoLTQ1ZGVnKScsXG4gICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTQ1ZGVnKSdcbiAgICB9LFxuICAgICd7bGluZX06bGFzdC1vZi10eXBlJzoge1xuICAgICAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3JvdGF0ZSg0NWRlZyknLFxuICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDQ1ZGVnKSdcbiAgICB9XG4gIH1cbn0pO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdseS1leHBhbnNpb24taWNvbicsXG4gIHRlbXBsYXRlVXJsOiAnLi9leHBhbnNpb24taWNvbi5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTHlFeHBhbnNpb25JY29uIHtcbiAgcmVhZG9ubHkgY2xhc3NlcyA9IHRoaXMuX3RoZW1lLmFkZFN0eWxlU2hlZXQoU1RZTEVTKTtcblxuICBwcml2YXRlIF9jb2xvcjogc3RyaW5nO1xuICBwcml2YXRlIF9jb2xvckNsYXNzOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdXAgPSBmYWxzZTtcblxuICBASW5wdXQoKVxuICBzZXQgY29sb3IodmFsOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9jb2xvckNsYXNzID0gdGhpcy5fdGhlbWUuYWRkU3R5bGUoJ0x5RXhwYW5zaW9uSWNvbi5jb2xvcicsICh0aGVtZTogVGhlbWVWYXJpYWJsZXMpID0+ICh7XG4gICAgICAne2xpbmV9Jzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLmNvbG9yT2YodmFsKVxuICAgICAgfVxuICAgIH0pLCB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCB0aGlzLl9jb2xvckNsYXNzLCBudWxsLCBTVFlMRVMpO1xuICB9XG4gIGdldCBjb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IHVwKHZhbDogYm9vbGVhbiB8ICcnKSB7XG4gICAgY29uc3QgbmV3VmFsID0gdG9Cb29sZWFuKHZhbCk7XG5cbiAgICBpZiAobmV3VmFsICE9PSB0aGlzLnVwKSB7XG4gICAgICB0aGlzLl91cCA9IG5ld1ZhbDtcbiAgICAgIGlmIChuZXdWYWwpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWwubmF0aXZlRWxlbWVudCwgdGhpcy5jbGFzc2VzLnVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsIHRoaXMuY2xhc3Nlcy51cCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCB1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF90aGVtZTogTHlUaGVtZTIsXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZlxuICApIHtcbiAgICBfcmVuZGVyZXIuYWRkQ2xhc3MoX2VsLm5hdGl2ZUVsZW1lbnQsIHRoaXMuY2xhc3Nlcy5yb290KTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnVwID0gIXRoaXMudXA7XG4gIH1cbn1cbiJdfQ==