import { Directive, ElementRef, Renderer2, Input } from '@angular/core';
import { LyTheme2, toBoolean, mixinStyleUpdater, mixinColor, StyleCollection, st2c, StyleRenderer } from '@alyle/ui';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alyle/ui';
const STYLE_PRIORITY = -1;
export const STYLES = (theme) => {
    return {
        $name: LyTypography.и,
        $priority: STYLE_PRIORITY,
        root: (className) => `${className}{margin:0;display:block;font-family:${theme.typography.fontFamily};}${st2c(((theme.typography
            && theme.typography.root
            && (theme.typography.root instanceof StyleCollection
                ? theme.typography.root.setTransformer(fn => fn()).css
                : theme.typography.root()))), `${className}`)}`,
        gutterTop: (className) => `${className}{margin-top:0.35em;}`,
        gutterBottom: (className) => `${className}{margin-bottom:0.35em;}`,
        gutter: (className) => `${className}{margin:0.35em 0;}`
    };
};
/** @docs-private */
export class LyTypographyBase {
    constructor(_theme) {
        this._theme = _theme;
    }
}
/** @docs-private */
export const LyTypographyMixinBase = mixinStyleUpdater(mixinColor((LyTypographyBase)));
export class LyTypography extends LyTypographyMixinBase {
    constructor(_theme, _el, renderer, sRenderer) {
        super(_theme);
        this._el = _el;
        this.renderer = renderer;
        this.sRenderer = sRenderer;
        /** @docs-private */
        this.classes = this._theme.renderStyleSheet(STYLES);
        this.renderer.addClass(this._el.nativeElement, this.classes.root);
    }
    set lyTyp(val) {
        if (val !== this.lyTyp) {
            if (val) {
                this._lyTypClass = this._createTypClass(val, this._lyTypClass);
            }
            else if (this._lyTypClass) {
                this.renderer.removeClass(this._el.nativeElement, this._lyTypClass);
                this._lyTypClass = null;
            }
        }
    }
    get lyTyp() {
        return this._lyTyp;
    }
    /** The text will truncate with an ellipsis. */
    set noWrap(val) {
        const newValue = toBoolean(val);
        if (newValue) {
            this._noWrapClass = this._theme.addSimpleStyle('lyTyp.noWrap', {
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis'
            });
            this.renderer.addClass(this._el.nativeElement, this._noWrapClass);
        }
        else if (this._noWrapClass) {
            this.renderer.removeClass(this._el.nativeElement, this._noWrapClass);
            this._noWrapClass = undefined;
        }
    }
    get noWrap() {
        return this._noWrap;
    }
    set gutter(val) {
        const newVal = toBoolean(val);
        if (newVal !== this.gutter) {
            this._gutter = newVal;
            this.sRenderer.toggleClass(this.classes.gutter, newVal);
        }
    }
    get gutter() {
        return this._gutter;
    }
    set gutterTop(val) {
        const newVal = toBoolean(val);
        if (newVal !== this.gutterTop) {
            this._gutterTop = newVal;
            this.sRenderer.toggleClass(this.classes.gutterTop, newVal);
        }
    }
    get gutterTop() {
        return this._gutterTop;
    }
    set gutterBottom(val) {
        const newVal = toBoolean(val);
        if (newVal !== this.gutterBottom) {
            this._gutterBottom = newVal;
            this.sRenderer.toggleClass(this.classes.gutterBottom, newVal);
        }
    }
    get gutterBottom() {
        return this._gutterBottom;
    }
    ngOnInit() {
        if ((this.gutterTop && this.gutterBottom)) {
            throw new Error(`use '<element lyTyp gutter>' instead of '<element lyTyp gutterTop gutterBottom>'`);
        }
    }
    ngOnChanges() {
        this.updateStyle(this._el.nativeElement);
    }
    _createTypClass(val, instance) {
        const newKey = `k-typ:${val}`;
        return this.sRenderer.add(newKey, (theme) => {
            if (theme.typography && theme.typography.lyTyp) {
                const lyTyp = theme.typography.lyTyp[val];
                if (lyTyp) {
                    return lyTyp instanceof StyleCollection
                        ? lyTyp.setTransformer((_) => _()).css
                        : lyTyp();
                }
            }
            throw new Error(`Value typography.lyTyp['${val}'] not found in ThemeVariables`);
        }, STYLE_PRIORITY, instance);
    }
}
LyTypography.ɵfac = function LyTypography_Factory(t) { return new (t || LyTypography)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LyTheme2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.StyleRenderer)); };
LyTypography.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LyTypography, selectors: [["", "lyTyp", ""]], inputs: { color: "color", lyTyp: "lyTyp", noWrap: "noWrap", gutter: "gutter", gutterTop: "gutterTop", gutterBottom: "gutterBottom" }, features: [ɵngcc0.ɵɵProvidersFeature([
            StyleRenderer
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
/** @docs-private */
LyTypography.и = 'LyTypography';
LyTypography.ctorParameters = () => [
    { type: LyTheme2 },
    { type: ElementRef },
    { type: Renderer2 },
    { type: StyleRenderer }
];
LyTypography.propDecorators = {
    lyTyp: [{ type: Input }],
    noWrap: [{ type: Input }],
    gutter: [{ type: Input }],
    gutterTop: [{ type: Input }],
    gutterBottom: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LyTypography, [{
        type: Directive,
        args: [{
                selector: `[lyTyp]`,
                inputs: [
                    'color'
                ],
                providers: [
                    StyleRenderer
                ]
            }]
    }], function () { return [{ type: ɵngcc1.LyTheme2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc1.StyleRenderer }]; }, { lyTyp: [{
            type: Input
        }], noWrap: [{
            type: Input
        }], gutter: [{
            type: Input
        }], gutterTop: [{
            type: Input
        }], gutterBottom: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwb2dyYXBoeS5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi90eXBvZ3JhcGh5L3R5cG9ncmFwaHkuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQXFCLE1BQU0sZUFBZSxDQUFDO0FBQzNGLE9BQU8sRUFDTCxRQUFRLEVBQ1IsU0FBUyxFQUVULGlCQUFpQixFQUNqQixVQUFVLEVBQ1YsZUFBZSxFQUVmLElBQUksRUFDSixhQUFhLEVBQUUsTUFBTSxXQUFXLENBQUM7OztBQWdCbkMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDMUIsTUFBTSxDQUFDLE1BQU0sTUFBTSxHQUFHLENBQUMsS0FBNkMsRUFBRSxFQUFFO0FBQ3hFLElBQUUsT0FBTztBQUNULFFBQUksS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQ3pCLFFBQUksU0FBUyxFQUFFLGNBQWM7QUFDN0IsUUFBSSxJQUFJLEVBQUUsQ0FBQyxTQUFpQixFQUFFLEVBQUUsQ0FBQyxHQUFHLFNBQVMsdUNBQXVDLEtBQUssQ0FBQyxVQUFVLENBQUMsVUFBVSxLQUFLLElBQUksQ0FBQyxDQUNqSCxDQUFDLEtBQUssQ0FBQyxVQUFVO0FBQ3pCLGVBQWEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJO0FBQ2xDLGVBQWEsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksWUFBWSxlQUFlO0FBQzlELGdCQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUc7QUFDbEUsZ0JBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FDN0IsQ0FBQyxFQUFFLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRTtB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LENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEQsZ0JBQVUsSUFBSSxLQUFLLEVBQUU7QUFDckIsb0JBQWMsT0FBTyxLQUFLLFlBQVksZUFBZTtBQUNyRCx3QkFBZ0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRztBQUN0RCx3QkFBZ0IsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQzFCLGlCQUFhO0FBQ2IsYUFBUztBQUNULFlBQVEsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ3hGLFFBQU0sQ0FBQyxFQUNELGNBQWMsRUFDZCxRQUFRLENBQ1QsQ0FBQztBQUNOLElBQUUsQ0FBQztBQUNIOzs7OytFQUNBO0FBOUhFLG9CQUFvQjtBQUNKLGNBQUMsR0FBRyxjQUFjLENBQUMsQUFGaEM7QUFBQztFQVRMLFNBQVMsU0FBQyxwQkFTaUMsWUEvRDFDLFFBQVE7Y0F1RFIsUUFBUSxFQUFFLHhCQXREVixZQUhrQixVQUFVO09BeURULFBBekRhLFlBQUYsU0FBUztBQTBEdkMsTUFBTSxFQUFFLFJBMURtQyxZQVUzQyxhQUFhO0VBaURYLEZBakRjO01BaURQLGtCQUNSLHhCQWxEa0I7VUFtRG5CLFNBQVMsRUFBRSxyQkFqREcsb0JBcUViLEtBQUs7YUFuQkosYUFBYSwxQkFvQmYscUJBZUMsS0FBSzthQWxDTCxjQUNGLDNCQWtDQyxxQkFrQkMsS0FBSztBQUNOLHdCQVdDLEtBQUs7QUFDTiwyQkFXQyxLQUFLO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBJbnB1dCwgT25Jbml0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEx5VGhlbWUyLFxuICB0b0Jvb2xlYW4sXG4gIFRoZW1lVmFyaWFibGVzLFxuICBtaXhpblN0eWxlVXBkYXRlcixcbiAgbWl4aW5Db2xvcixcbiAgU3R5bGVDb2xsZWN0aW9uLFxuICBTdHlsZVRlbXBsYXRlLFxuICBzdDJjLFxuICBTdHlsZVJlbmRlcmVyIH0gZnJvbSAnQGFseWxlL3VpJztcblxuZXhwb3J0IGludGVyZmFjZSBMeVR5cG9ncmFwaHlUaGVtZSB7XG4gIC8qKiBTdHlsZXMgZm9yIFR5cG9ncmFwaHkgQ29tcG9uZW50ICovXG4gIHJvb3Q/OiBTdHlsZUNvbGxlY3Rpb248KCgpID0+IFN0eWxlVGVtcGxhdGUpPlxuICAgIHwgKCgpID0+IFN0eWxlVGVtcGxhdGUpO1xuICBseVR5cD86IHtcbiAgICBbbmFtZTogc3RyaW5nXTogU3R5bGVDb2xsZWN0aW9uPCgoKSA9PiBTdHlsZVRlbXBsYXRlKT5cbiAgICAgIHwgKCgpID0+IFN0eWxlVGVtcGxhdGUpIHwgdW5kZWZpbmVkXG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTHlUeXBvZ3JhcGh5VmFyaWFibGVzIHtcbiAgdHlwb2dyYXBoeT86IEx5VHlwb2dyYXBoeVRoZW1lO1xufVxuXG5jb25zdCBTVFlMRV9QUklPUklUWSA9IC0xO1xuZXhwb3J0IGNvbnN0IFNUWUxFUyA9ICh0aGVtZTogVGhlbWVWYXJpYWJsZXMgJiBMeVR5cG9ncmFwaHlWYXJpYWJsZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAkbmFtZTogTHlUeXBvZ3JhcGh5LtC4LFxuICAgICRwcmlvcml0eTogU1RZTEVfUFJJT1JJVFksXG4gICAgcm9vdDogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBgJHtjbGFzc05hbWV9e21hcmdpbjowO2Rpc3BsYXk6YmxvY2s7Zm9udC1mYW1pbHk6JHt0aGVtZS50eXBvZ3JhcGh5LmZvbnRGYW1pbHl9O30ke3N0MmMoKFxuICAgICAgICAodGhlbWUudHlwb2dyYXBoeVxuICAgICAgICAgICYmIHRoZW1lLnR5cG9ncmFwaHkucm9vdFxuICAgICAgICAgICYmICh0aGVtZS50eXBvZ3JhcGh5LnJvb3QgaW5zdGFuY2VvZiBTdHlsZUNvbGxlY3Rpb25cbiAgICAgICAgICAgID8gdGhlbWUudHlwb2dyYXBoeS5yb290LnNldFRyYW5zZm9ybWVyKGZuID0+IGZuKCkpLmNzc1xuICAgICAgICAgICAgOiB0aGVtZS50eXBvZ3JhcGh5LnJvb3QoKSlcbiAgICAgICAgKSksIGAke2NsYXNzTmFtZX1gKX1gLFxuICAgIGd1dHRlclRvcDogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBgJHtjbGFzc05hbWV9e21hcmdpbi10b3A6MC4zNWVtO31gLFxuICAgIGd1dHRlckJvdHRvbTogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBgJHtjbGFzc05hbWV9e21hcmdpbi1ib3R0b206MC4zNWVtO31gLFxuICAgIGd1dHRlcjogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBgJHtjbGFzc05hbWV9e21hcmdpbjowLjM1ZW0gMDt9YFxuICB9O1xufTtcblxuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNsYXNzIEx5VHlwb2dyYXBoeUJhc2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgX3RoZW1lOiBMeVRoZW1lMlxuICApIHsgfVxufVxuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNvbnN0IEx5VHlwb2dyYXBoeU1peGluQmFzZSA9IG1peGluU3R5bGVVcGRhdGVyKFxuICAgIG1peGluQ29sb3IoKEx5VHlwb2dyYXBoeUJhc2UpKSk7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogYFtseVR5cF1gLFxuICBpbnB1dHM6IFtcbiAgICAnY29sb3InXG4gIF0sXG4gIHByb3ZpZGVyczogW1xuICAgIFN0eWxlUmVuZGVyZXJcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBMeVR5cG9ncmFwaHkgZXh0ZW5kcyBMeVR5cG9ncmFwaHlNaXhpbkJhc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIHN0YXRpYyByZWFkb25seSDQuCA9ICdMeVR5cG9ncmFwaHknO1xuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICByZWFkb25seSBjbGFzc2VzID0gdGhpcy5fdGhlbWUucmVuZGVyU3R5bGVTaGVldChTVFlMRVMpO1xuICBwcml2YXRlIF9seVR5cDogc3RyaW5nO1xuICBwcml2YXRlIF9seVR5cENsYXNzOiBzdHJpbmcgfCBudWxsO1xuXG4gIHByaXZhdGUgX2d1dHRlcjogYm9vbGVhbjtcblxuICBwcml2YXRlIF9ndXR0ZXJUb3A6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfZ3V0dGVyQm90dG9tOiBib29sZWFuO1xuICBwcml2YXRlIF9ub1dyYXA6IGJvb2xlYW47XG4gIHByaXZhdGUgX25vV3JhcENsYXNzPzogc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBseVR5cCh2YWw6IHN0cmluZykge1xuICAgIGlmICh2YWwgIT09IHRoaXMubHlUeXApIHtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5fbHlUeXBDbGFzcyA9IHRoaXMuX2NyZWF0ZVR5cENsYXNzKHZhbCwgdGhpcy5fbHlUeXBDbGFzcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2x5VHlwQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCB0aGlzLl9seVR5cENsYXNzKTtcbiAgICAgICAgdGhpcy5fbHlUeXBDbGFzcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBseVR5cCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9seVR5cDtcbiAgfVxuXG4gIC8qKiBUaGUgdGV4dCB3aWxsIHRydW5jYXRlIHdpdGggYW4gZWxsaXBzaXMuICovXG4gIEBJbnB1dCgpXG4gIHNldCBub1dyYXAodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0b0Jvb2xlYW4odmFsKTtcbiAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgIHRoaXMuX25vV3JhcENsYXNzID0gdGhpcy5fdGhlbWUuYWRkU2ltcGxlU3R5bGUoJ2x5VHlwLm5vV3JhcCcsIHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWwubmF0aXZlRWxlbWVudCwgdGhpcy5fbm9XcmFwQ2xhc3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbm9XcmFwQ2xhc3MpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWwubmF0aXZlRWxlbWVudCwgdGhpcy5fbm9XcmFwQ2xhc3MpO1xuICAgICAgdGhpcy5fbm9XcmFwQ2xhc3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGdldCBub1dyYXAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25vV3JhcDtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBndXR0ZXIodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsID0gdG9Cb29sZWFuKHZhbCk7XG4gICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy5ndXR0ZXIpIHtcbiAgICAgIHRoaXMuX2d1dHRlciA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuc1JlbmRlcmVyLnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3Nlcy5ndXR0ZXIsIG5ld1ZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBndXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1dHRlcjtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBndXR0ZXJUb3AodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsID0gdG9Cb29sZWFuKHZhbCk7XG4gICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy5ndXR0ZXJUb3ApIHtcbiAgICAgIHRoaXMuX2d1dHRlclRvcCA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuc1JlbmRlcmVyLnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3Nlcy5ndXR0ZXJUb3AsIG5ld1ZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBndXR0ZXJUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1dHRlclRvcDtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCBndXR0ZXJCb3R0b20odmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgbmV3VmFsID0gdG9Cb29sZWFuKHZhbCk7XG4gICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy5ndXR0ZXJCb3R0b20pIHtcbiAgICAgIHRoaXMuX2d1dHRlckJvdHRvbSA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuc1JlbmRlcmVyLnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3Nlcy5ndXR0ZXJCb3R0b20sIG5ld1ZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBndXR0ZXJCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1dHRlckJvdHRvbTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIF90aGVtZTogTHlUaGVtZTIsXG4gICAgcHJpdmF0ZSBfZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHJlYWRvbmx5IHNSZW5kZXJlcjogU3R5bGVSZW5kZXJlclxuICApIHtcbiAgICBzdXBlcihfdGhlbWUpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWwubmF0aXZlRWxlbWVudCwgdGhpcy5jbGFzc2VzLnJvb3QpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCh0aGlzLmd1dHRlclRvcCAmJiB0aGlzLmd1dHRlckJvdHRvbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlICc8ZWxlbWVudCBseVR5cCBndXR0ZXI+JyBpbnN0ZWFkIG9mICc8ZWxlbWVudCBseVR5cCBndXR0ZXJUb3AgZ3V0dGVyQm90dG9tPidgKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICB0aGlzLnVwZGF0ZVN0eWxlKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlVHlwQ2xhc3ModmFsOiBzdHJpbmcsIGluc3RhbmNlOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgY29uc3QgbmV3S2V5ID0gYGstdHlwOiR7dmFsfWA7XG5cbiAgICByZXR1cm4gdGhpcy5zUmVuZGVyZXIuYWRkKG5ld0tleSxcbiAgICAgICh0aGVtZTogTHlUeXBvZ3JhcGh5VmFyaWFibGVzKSA9PiB7XG4gICAgICAgIGlmICh0aGVtZS50eXBvZ3JhcGh5ICYmIHRoZW1lLnR5cG9ncmFwaHkubHlUeXApIHtcbiAgICAgICAgICBjb25zdCBseVR5cCA9IHRoZW1lLnR5cG9ncmFwaHkubHlUeXBbdmFsXTtcbiAgICAgICAgICBpZiAobHlUeXApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGx5VHlwIGluc3RhbmNlb2YgU3R5bGVDb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgPyBseVR5cC5zZXRUcmFuc2Zvcm1lcigoXykgPT4gXygpKS5jc3NcbiAgICAgICAgICAgICAgICA6IGx5VHlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSB0eXBvZ3JhcGh5Lmx5VHlwWycke3ZhbH0nXSBub3QgZm91bmQgaW4gVGhlbWVWYXJpYWJsZXNgKTtcbiAgICAgIH0sXG4gICAgICBTVFlMRV9QUklPUklUWSxcbiAgICAgIGluc3RhbmNlLFxuICAgICk7XG4gIH1cblxufVxuIl19