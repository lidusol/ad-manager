import { ElementRef, ChangeDetectorRef, EventEmitter, Renderer2, OnDestroy, NgZone, OnInit } from '@angular/core';
import { ThemeVariables, ThemeRef, StyleCollection, LyClasses, StyleTemplate, StyleRenderer } from '@alyle/ui';
import { ViewportRuler } from '@angular/cdk/scrolling';
import * as ɵngcc0 from '@angular/core';
export interface LyImageCropperTheme {
    /** Styles for Image Cropper Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
}
export interface LyImageCropperVariables {
    cropper?: LyImageCropperTheme;
}
export declare const STYLES: (theme: ThemeVariables & LyImageCropperVariables, ref: ThemeRef) => {
    $name: string;
    $priority: number;
    root: () => (className: string) => string;
    imgContainer: (className: string) => string;
    overlay: (className: string) => string;
    area: (className: string) => string;
    resizer: (className: string) => string;
    defaultContent: (className: string) => string;
};
/** Image Cropper Config */
export declare class ImgCropperConfig {
    /** Cropper area width */
    width: number;
    /** Cropper area height */
    height: number;
    minWidth?: number;
    minHeight?: number;
    /** If this is not defined, the new image will be automatically defined. */
    type?: string;
    /** Background color( default: null), if is null in png is transparent but not in jpg. */
    fill?: string | null;
    /**
     * Set anti-aliased (default: true)
     * @deprecated this is not necessary as the cropper will automatically resize the image
     * to the best quality
     */
    antiAliased?: boolean;
    autoCrop?: boolean;
    output?: ImgOutput | ImgResolution;
    /**
     * Zoom out until the entire image fits into the cropping area.
     * default: false
     */
    extraZoomOut?: boolean;
    /**
     * Emit event `error` if the file size in bytes for the limit.
     * Note: It only works when the image is received from the `<input>` event.
     */
    maxFileSize?: number | null;
    /**
     * Whether the cropper area will be round.
     * This implies that the cropper area will maintain its aspect ratio.
     * default: false
     */
    round?: boolean;
    /**
     * Whether the cropper area is resizable.
     * default: false
     */
    resizableArea?: boolean;
    /**
     * Keep the width and height of the growing area the same according
     * to `ImgCropperConfig.width` and `ImgCropperConfig.height`
     * default: false
     */
    keepAspectRatio?: boolean;
    /**
     * Whether the cropper area is responsive.
     * By default, the width and height of the cropper area is fixed,
     * so can use when the cropper area is larger than its container,
     * otherwise this will bring problems when cropping.
     */
    responsiveArea?: boolean;
}
/**
 * The output image
 * With this option you can resize the output image.
 * If `width` or `height` are 0, this will be set automatically.
 * Both cannot be 0.
 */
export interface ImgOutput {
    /**
     * The cropped image will be resized to this `width`.
     */
    width: number;
    /**
     * Cropped image will be resized to this `height`.
     */
    height: number;
}
/** Image output */
export declare enum ImgResolution {
    /**
     * The output image will be equal to the initial size of the cropper area.
     */
    Default = 0,
    /** Just crop the image without resizing */
    OriginalImage = 1
}
/** Image output */
export declare enum ImgCropperError {
    /** The loaded image exceeds the size limit set. */
    Size = 0,
    /** The file loaded is not image. */
    Type = 1,
    /** When the image has not been loaded. */
    Other = 2
}
export interface ImgCropperEvent {
    /** Cropped image data URL */
    dataURL?: string;
    name: string | null;
    /** Filetype */
    type?: string;
    /** Cropped area width */
    areaWidth: number;
    /** Cropped area height */
    areaHeight: number;
    /** Cropped image width */
    width: number;
    /** Cropped image height */
    height: number;
    /** Original Image data URL */
    originalDataURL?: string;
    scale: number;
    /** Current rotation in degrees */
    rotation: number;
    /** Size of the image in bytes */
    size: number;
    /** Scaled offset from the left edge of the image */
    left: number;
    /** Scaled offset from the top edge of the image */
    top: number;
    /**
     * Scaled offset from the left edge of the image to center of area
     * Can be used to set image position
     */
    xOrigin: number;
    /**
     * Scaled offset from the top edge of the image to center of area
     * Can be used to set image position
     */
    yOrigin: number;
    /** @deprecated Use `xOrigin & yOrigin` instead. */
    position?: {
        x: number;
        y: number;
    };
}
export interface ImgCropperErrorEvent {
    name?: string;
    /** Size of the image in bytes */
    size: number;
    /** Filetype */
    type: string;
    /** Type of error */
    error: ImgCropperError;
    errorMsg?: string;
}
export interface ImgCropperLoaderConfig {
    name?: string | null;
    /** Filetype */
    type?: string;
    /** Cropped area width */
    areaWidth?: number;
    /** Cropped area height */
    areaHeight?: number;
    /** Cropped image width */
    width?: number;
    /** Cropped image height */
    height?: number;
    /** Original Image data URL */
    originalDataURL: string;
    scale?: number;
    /** Current rotation in degrees */
    rotation?: number;
    /** Size of the image in bytes */
    size?: number;
    /** Offset from the left edge of the image to center of area */
    xOrigin?: number;
    /** Offset from the top edge of the image to center of area */
    yOrigin?: number;
}
export declare class LyImageCropper implements OnInit, OnDestroy {
    readonly sRenderer: StyleRenderer;
    private _renderer;
    readonly _elementRef: ElementRef<HTMLElement>;
    private cd;
    private _ngZone;
    static readonly и = "LyImageCropper";
    /**
     * styles
     * @docs-private
     */
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        imgContainer: string;
        overlay: string;
        area: string;
        resizer: string;
        defaultContent: string;
    }, "root" | "imgContainer" | "overlay" | "area" | "resizer" | "defaultContent">;
    private _currentLoadConfig?;
    /** Original image */
    private _img;
    private offset?;
    private _scale?;
    private _scal3Fix?;
    private _minScale?;
    private _maxScale?;
    /** Initial config */
    private _configPrimary;
    private _config;
    private _imgRect;
    private _rotation;
    private _isSliding;
    /** Keeps track of the last pointer event that was captured by the crop area. */
    private _lastPointerEvent;
    private _startPointerEvent;
    _primaryAreaWidth: number;
    _primaryAreaHeight: number;
    _absoluteScale: number;
    /**
     * When is loaded image
     * @internal
     */
    _isLoadedImg: boolean;
    /** When is loaded image & ready for crop */
    isLoaded: boolean;
    /** When the cropper is ready to be interacted  */
    isReady: boolean;
    isCropped: boolean;
    _imgContainer: ElementRef;
    _areaRef: ElementRef;
    _imgCanvas: ElementRef<HTMLCanvasElement>;
    get config(): ImgCropperConfig;
    set config(val: ImgCropperConfig);
    /** Set scale */
    get scale(): number | undefined;
    set scale(val: number | undefined);
    /**
     * Emit event `error` if the file size for the limit.
     * Note: It only works when the image is received from the `<input>` event.
     */
    maxFileSize: number;
    /** Get min scale */
    get minScale(): number | undefined;
    readonly scaleChange: EventEmitter<number>;
    /** Emits minimum supported image scale */
    readonly minScaleChange: EventEmitter<number>;
    /** Emits maximum supported image scale */
    readonly maxScaleChange: EventEmitter<number>;
    /** @deprecated Emits when the image is loaded, instead use `ready` */
    readonly loaded: EventEmitter<ImgCropperEvent>;
    /** Emits when the image is loaded */
    readonly imageLoaded: EventEmitter<ImgCropperEvent>;
    /** Emits when the cropper is ready to be interacted */
    readonly ready: EventEmitter<ImgCropperEvent>;
    /** On crop new image */
    readonly cropped: EventEmitter<ImgCropperEvent>;
    /** Emits when the cropper is cleaned */
    readonly cleaned: EventEmitter<void>;
    /** Emit an error when the loaded image is not valid */
    readonly error: EventEmitter<ImgCropperErrorEvent>;
    private _currentInputElement?;
    /** Emits whenever the component is destroyed. */
    private readonly _destroy;
    /** Used to subscribe to global move and end events */
    protected _document: Document;
    constructor(sRenderer: StyleRenderer, _renderer: Renderer2, _elementRef: ElementRef<HTMLElement>, cd: ChangeDetectorRef, _ngZone: NgZone, _document: any, viewPortRuler: ViewportRuler);
    ngOnInit(): void;
    ngOnDestroy(): void;
    /** Load image with canvas */
    private _imgLoaded;
    private _setStylesForContImg;
    /**
     * Update area and image position only if needed,
     * this is used when window resize
     */
    updateCropperPosition(): void;
    /** Load Image from input event */
    selectInputEvent(img: Event): void;
    /** Set the size of the image, the values can be 0 between 1, where 1 is the original size */
    setScale(size?: number, noAutoCrop?: boolean): void;
    private _getCenterPoints;
    /**
     * Fit to screen
     */
    fitToScreen(): void;
    fit(): void;
    private _pointerDown;
    /**
     * Simulate pointerMove with clientX = 0 and clientY = 0,
     * this is used by `setScale` and `rotate`
     */
    private _simulatePointerMove;
    _markForCheck(): void;
    /**
     * Called when the user has moved their pointer after
     * starting to drag.
     */
    private _pointerMove;
    updatePosition(): void;
    updatePosition(xOrigin: number, yOrigin: number): void;
    _slideEnd(): void;
    private _cropIfAutoCrop;
    /** + */
    zoomIn(): void;
    /** Clean the img cropper */
    clean(): void;
    /** - */
    zoomOut(): void;
    center(): void;
    /**
     * load an image from a given configuration,
     * or from the result of a cropped image
     */
    loadImage(config: ImgCropperLoaderConfig | string, fn?: () => void): void;
    private _updateAreaIfNeeded;
    private _updateAbsoluteScale;
    /**
     * Load Image from URL
     * @deprecated Use `loadImage` instead of `setImageUrl`
     * @param src URL
     * @param fn function that will be called before emit the event loaded
     */
    setImageUrl(src: string, fn?: () => void): void;
    private _positionImg;
    rotate(degrees: number): void;
    _updateMinScale(canvas?: HTMLCanvasElement): void;
    private _updateMaxScale;
    /**
     * Resize & crop image
     */
    crop(config?: ImgCropperConfig): ImgCropperEvent;
    /**
     * @docs-private
     */
    private _imgCrop;
    _rootRect(): DOMRect;
    _areaCropperRect(): DOMRect;
    _canvasRect(): DOMRect;
    /** Called when the user has lifted their pointer. */
    private _pointerUp;
    /** Called when the window has lost focus. */
    private _windowBlur;
    private _bindGlobalEvents;
    /** Removes any global event listeners that we may have added. */
    private _removeGlobalEvents;
    /** Use defaultView of injected document if available or fallback to global window reference */
    private _getWindow;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyImageCropper, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<LyImageCropper, "ly-img-cropper, ly-image-cropper", never, { "config": "config"; "maxFileSize": "maxFileSize"; "scale": "scale"; }, { "scaleChange": "scaleChange"; "minScaleChange": "minScale"; "maxScaleChange": "maxScale"; "loaded": "loaded"; "imageLoaded": "imageLoaded"; "ready": "ready"; "cropped": "cropped"; "cleaned": "cleaned"; "error": "error"; }, never, ["*"]>;
}
/**
 * Normalize degrees for cropper rotation
 * @docs-private
 */
export declare function _normalizeDegrees(n: number): number;
export declare function round(n: number): number;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hZ2UtY3JvcHBlci5kLnRzIiwic291cmNlcyI6WyJpbWFnZS1jcm9wcGVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgRXZlbnRFbWl0dGVyLCBSZW5kZXJlcjIsIE9uRGVzdHJveSwgTmdab25lLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRoZW1lVmFyaWFibGVzLCBUaGVtZVJlZiwgU3R5bGVDb2xsZWN0aW9uLCBMeUNsYXNzZXMsIFN0eWxlVGVtcGxhdGUsIFN0eWxlUmVuZGVyZXIgfSBmcm9tICdAYWx5bGUvdWknO1xuaW1wb3J0IHsgVmlld3BvcnRSdWxlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zY3JvbGxpbmcnO1xuZXhwb3J0IGludGVyZmFjZSBMeUltYWdlQ3JvcHBlclRoZW1lIHtcbiAgICAvKiogU3R5bGVzIGZvciBJbWFnZSBDcm9wcGVyIENvbXBvbmVudCAqL1xuICAgIHJvb3Q/OiBTdHlsZUNvbGxlY3Rpb248KChjbGFzc2VzOiBMeUNsYXNzZXM8dHlwZW9mIFNUWUxFUz4pID0+IFN0eWxlVGVtcGxhdGUpPiB8ICgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+KSA9PiBTdHlsZVRlbXBsYXRlKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTHlJbWFnZUNyb3BwZXJWYXJpYWJsZXMge1xuICAgIGNyb3BwZXI/OiBMeUltYWdlQ3JvcHBlclRoZW1lO1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgU1RZTEVTOiAodGhlbWU6IFRoZW1lVmFyaWFibGVzICYgTHlJbWFnZUNyb3BwZXJWYXJpYWJsZXMsIHJlZjogVGhlbWVSZWYpID0+IHtcbiAgICAkbmFtZTogc3RyaW5nO1xuICAgICRwcmlvcml0eTogbnVtYmVyO1xuICAgIHJvb3Q6ICgpID0+IChjbGFzc05hbWU6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgIGltZ0NvbnRhaW5lcjogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgb3ZlcmxheTogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgYXJlYTogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgcmVzaXplcjogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgZGVmYXVsdENvbnRlbnQ6IChjbGFzc05hbWU6IHN0cmluZykgPT4gc3RyaW5nO1xufTtcbi8qKiBJbWFnZSBDcm9wcGVyIENvbmZpZyAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSW1nQ3JvcHBlckNvbmZpZyB7XG4gICAgLyoqIENyb3BwZXIgYXJlYSB3aWR0aCAqL1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgLyoqIENyb3BwZXIgYXJlYSBoZWlnaHQgKi9cbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gICAgLyoqIElmIHRoaXMgaXMgbm90IGRlZmluZWQsIHRoZSBuZXcgaW1hZ2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRlZmluZWQuICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgICAvKiogQmFja2dyb3VuZCBjb2xvciggZGVmYXVsdDogbnVsbCksIGlmIGlzIG51bGwgaW4gcG5nIGlzIHRyYW5zcGFyZW50IGJ1dCBub3QgaW4ganBnLiAqL1xuICAgIGZpbGw/OiBzdHJpbmcgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFNldCBhbnRpLWFsaWFzZWQgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBpcyBub3QgbmVjZXNzYXJ5IGFzIHRoZSBjcm9wcGVyIHdpbGwgYXV0b21hdGljYWxseSByZXNpemUgdGhlIGltYWdlXG4gICAgICogdG8gdGhlIGJlc3QgcXVhbGl0eVxuICAgICAqL1xuICAgIGFudGlBbGlhc2VkPzogYm9vbGVhbjtcbiAgICBhdXRvQ3JvcD86IGJvb2xlYW47XG4gICAgb3V0cHV0PzogSW1nT3V0cHV0IHwgSW1nUmVzb2x1dGlvbjtcbiAgICAvKipcbiAgICAgKiBab29tIG91dCB1bnRpbCB0aGUgZW50aXJlIGltYWdlIGZpdHMgaW50byB0aGUgY3JvcHBpbmcgYXJlYS5cbiAgICAgKiBkZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIGV4dHJhWm9vbU91dD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW1pdCBldmVudCBgZXJyb3JgIGlmIHRoZSBmaWxlIHNpemUgaW4gYnl0ZXMgZm9yIHRoZSBsaW1pdC5cbiAgICAgKiBOb3RlOiBJdCBvbmx5IHdvcmtzIHdoZW4gdGhlIGltYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIGA8aW5wdXQ+YCBldmVudC5cbiAgICAgKi9cbiAgICBtYXhGaWxlU2l6ZT86IG51bWJlciB8IG51bGw7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY3JvcHBlciBhcmVhIHdpbGwgYmUgcm91bmQuXG4gICAgICogVGhpcyBpbXBsaWVzIHRoYXQgdGhlIGNyb3BwZXIgYXJlYSB3aWxsIG1haW50YWluIGl0cyBhc3BlY3QgcmF0aW8uXG4gICAgICogZGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgICByb3VuZD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY3JvcHBlciBhcmVhIGlzIHJlc2l6YWJsZS5cbiAgICAgKiBkZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIHJlc2l6YWJsZUFyZWE/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEtlZXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGdyb3dpbmcgYXJlYSB0aGUgc2FtZSBhY2NvcmRpbmdcbiAgICAgKiB0byBgSW1nQ3JvcHBlckNvbmZpZy53aWR0aGAgYW5kIGBJbWdDcm9wcGVyQ29uZmlnLmhlaWdodGBcbiAgICAgKiBkZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIGtlZXBBc3BlY3RSYXRpbz86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY3JvcHBlciBhcmVhIGlzIHJlc3BvbnNpdmUuXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNyb3BwZXIgYXJlYSBpcyBmaXhlZCxcbiAgICAgKiBzbyBjYW4gdXNlIHdoZW4gdGhlIGNyb3BwZXIgYXJlYSBpcyBsYXJnZXIgdGhhbiBpdHMgY29udGFpbmVyLFxuICAgICAqIG90aGVyd2lzZSB0aGlzIHdpbGwgYnJpbmcgcHJvYmxlbXMgd2hlbiBjcm9wcGluZy5cbiAgICAgKi9cbiAgICByZXNwb25zaXZlQXJlYT86IGJvb2xlYW47XG59XG4vKipcbiAqIFRoZSBvdXRwdXQgaW1hZ2VcbiAqIFdpdGggdGhpcyBvcHRpb24geW91IGNhbiByZXNpemUgdGhlIG91dHB1dCBpbWFnZS5cbiAqIElmIGB3aWR0aGAgb3IgYGhlaWdodGAgYXJlIDAsIHRoaXMgd2lsbCBiZSBzZXQgYXV0b21hdGljYWxseS5cbiAqIEJvdGggY2Fubm90IGJlIDAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1nT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgY3JvcHBlZCBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgdG8gdGhpcyBgd2lkdGhgLlxuICAgICAqL1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ3JvcHBlZCBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgdG8gdGhpcyBgaGVpZ2h0YC5cbiAgICAgKi9cbiAgICBoZWlnaHQ6IG51bWJlcjtcbn1cbi8qKiBJbWFnZSBvdXRwdXQgKi9cbmV4cG9ydCBkZWNsYXJlIGVudW0gSW1nUmVzb2x1dGlvbiB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBpbWFnZSB3aWxsIGJlIGVxdWFsIHRvIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIGNyb3BwZXIgYXJlYS5cbiAgICAgKi9cbiAgICBEZWZhdWx0ID0gMCxcbiAgICAvKiogSnVzdCBjcm9wIHRoZSBpbWFnZSB3aXRob3V0IHJlc2l6aW5nICovXG4gICAgT3JpZ2luYWxJbWFnZSA9IDFcbn1cbi8qKiBJbWFnZSBvdXRwdXQgKi9cbmV4cG9ydCBkZWNsYXJlIGVudW0gSW1nQ3JvcHBlckVycm9yIHtcbiAgICAvKiogVGhlIGxvYWRlZCBpbWFnZSBleGNlZWRzIHRoZSBzaXplIGxpbWl0IHNldC4gKi9cbiAgICBTaXplID0gMCxcbiAgICAvKiogVGhlIGZpbGUgbG9hZGVkIGlzIG5vdCBpbWFnZS4gKi9cbiAgICBUeXBlID0gMSxcbiAgICAvKiogV2hlbiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIGxvYWRlZC4gKi9cbiAgICBPdGhlciA9IDJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSW1nQ3JvcHBlckV2ZW50IHtcbiAgICAvKiogQ3JvcHBlZCBpbWFnZSBkYXRhIFVSTCAqL1xuICAgIGRhdGFVUkw/OiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICAvKiogRmlsZXR5cGUgKi9cbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIC8qKiBDcm9wcGVkIGFyZWEgd2lkdGggKi9cbiAgICBhcmVhV2lkdGg6IG51bWJlcjtcbiAgICAvKiogQ3JvcHBlZCBhcmVhIGhlaWdodCAqL1xuICAgIGFyZWFIZWlnaHQ6IG51bWJlcjtcbiAgICAvKiogQ3JvcHBlZCBpbWFnZSB3aWR0aCAqL1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgLyoqIENyb3BwZWQgaW1hZ2UgaGVpZ2h0ICovXG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgLyoqIE9yaWdpbmFsIEltYWdlIGRhdGEgVVJMICovXG4gICAgb3JpZ2luYWxEYXRhVVJMPzogc3RyaW5nO1xuICAgIHNjYWxlOiBudW1iZXI7XG4gICAgLyoqIEN1cnJlbnQgcm90YXRpb24gaW4gZGVncmVlcyAqL1xuICAgIHJvdGF0aW9uOiBudW1iZXI7XG4gICAgLyoqIFNpemUgb2YgdGhlIGltYWdlIGluIGJ5dGVzICovXG4gICAgc2l6ZTogbnVtYmVyO1xuICAgIC8qKiBTY2FsZWQgb2Zmc2V0IGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW1hZ2UgKi9cbiAgICBsZWZ0OiBudW1iZXI7XG4gICAgLyoqIFNjYWxlZCBvZmZzZXQgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGltYWdlICovXG4gICAgdG9wOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2NhbGVkIG9mZnNldCBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGltYWdlIHRvIGNlbnRlciBvZiBhcmVhXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gc2V0IGltYWdlIHBvc2l0aW9uXG4gICAgICovXG4gICAgeE9yaWdpbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNjYWxlZCBvZmZzZXQgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGltYWdlIHRvIGNlbnRlciBvZiBhcmVhXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gc2V0IGltYWdlIHBvc2l0aW9uXG4gICAgICovXG4gICAgeU9yaWdpbjogbnVtYmVyO1xuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHhPcmlnaW4gJiB5T3JpZ2luYCBpbnN0ZWFkLiAqL1xuICAgIHBvc2l0aW9uPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xufVxuZXhwb3J0IGludGVyZmFjZSBJbWdDcm9wcGVyRXJyb3JFdmVudCB7XG4gICAgbmFtZT86IHN0cmluZztcbiAgICAvKiogU2l6ZSBvZiB0aGUgaW1hZ2UgaW4gYnl0ZXMgKi9cbiAgICBzaXplOiBudW1iZXI7XG4gICAgLyoqIEZpbGV0eXBlICovXG4gICAgdHlwZTogc3RyaW5nO1xuICAgIC8qKiBUeXBlIG9mIGVycm9yICovXG4gICAgZXJyb3I6IEltZ0Nyb3BwZXJFcnJvcjtcbiAgICBlcnJvck1zZz86IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSW1nQ3JvcHBlckxvYWRlckNvbmZpZyB7XG4gICAgbmFtZT86IHN0cmluZyB8IG51bGw7XG4gICAgLyoqIEZpbGV0eXBlICovXG4gICAgdHlwZT86IHN0cmluZztcbiAgICAvKiogQ3JvcHBlZCBhcmVhIHdpZHRoICovXG4gICAgYXJlYVdpZHRoPzogbnVtYmVyO1xuICAgIC8qKiBDcm9wcGVkIGFyZWEgaGVpZ2h0ICovXG4gICAgYXJlYUhlaWdodD86IG51bWJlcjtcbiAgICAvKiogQ3JvcHBlZCBpbWFnZSB3aWR0aCAqL1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIC8qKiBDcm9wcGVkIGltYWdlIGhlaWdodCAqL1xuICAgIGhlaWdodD86IG51bWJlcjtcbiAgICAvKiogT3JpZ2luYWwgSW1hZ2UgZGF0YSBVUkwgKi9cbiAgICBvcmlnaW5hbERhdGFVUkw6IHN0cmluZztcbiAgICBzY2FsZT86IG51bWJlcjtcbiAgICAvKiogQ3VycmVudCByb3RhdGlvbiBpbiBkZWdyZWVzICovXG4gICAgcm90YXRpb24/OiBudW1iZXI7XG4gICAgLyoqIFNpemUgb2YgdGhlIGltYWdlIGluIGJ5dGVzICovXG4gICAgc2l6ZT86IG51bWJlcjtcbiAgICAvKiogT2Zmc2V0IGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW1hZ2UgdG8gY2VudGVyIG9mIGFyZWEgKi9cbiAgICB4T3JpZ2luPzogbnVtYmVyO1xuICAgIC8qKiBPZmZzZXQgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGltYWdlIHRvIGNlbnRlciBvZiBhcmVhICovXG4gICAgeU9yaWdpbj86IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5SW1hZ2VDcm9wcGVyIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHJlYWRvbmx5IHNSZW5kZXJlcjogU3R5bGVSZW5kZXJlcjtcbiAgICBwcml2YXRlIF9yZW5kZXJlcjtcbiAgICByZWFkb25seSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gICAgcHJpdmF0ZSBjZDtcbiAgICBwcml2YXRlIF9uZ1pvbmU7XG4gICAgc3RhdGljIHJlYWRvbmx5INC4ID0gXCJMeUltYWdlQ3JvcHBlclwiO1xuICAgIC8qKlxuICAgICAqIHN0eWxlc1xuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICByZWFkb25seSBjbGFzc2VzOiBQaWNrPHtcbiAgICAgICAgJG5hbWU6IHN0cmluZztcbiAgICAgICAgJHByaW9yaXR5OiBzdHJpbmc7XG4gICAgICAgIHJvb3Q6IHN0cmluZztcbiAgICAgICAgaW1nQ29udGFpbmVyOiBzdHJpbmc7XG4gICAgICAgIG92ZXJsYXk6IHN0cmluZztcbiAgICAgICAgYXJlYTogc3RyaW5nO1xuICAgICAgICByZXNpemVyOiBzdHJpbmc7XG4gICAgICAgIGRlZmF1bHRDb250ZW50OiBzdHJpbmc7XG4gICAgfSwgXCJyb290XCIgfCBcImltZ0NvbnRhaW5lclwiIHwgXCJvdmVybGF5XCIgfCBcImFyZWFcIiB8IFwicmVzaXplclwiIHwgXCJkZWZhdWx0Q29udGVudFwiPjtcbiAgICBwcml2YXRlIF9jdXJyZW50TG9hZENvbmZpZz87XG4gICAgLyoqIE9yaWdpbmFsIGltYWdlICovXG4gICAgcHJpdmF0ZSBfaW1nO1xuICAgIHByaXZhdGUgb2Zmc2V0PztcbiAgICBwcml2YXRlIF9zY2FsZT87XG4gICAgcHJpdmF0ZSBfc2NhbDNGaXg/O1xuICAgIHByaXZhdGUgX21pblNjYWxlPztcbiAgICBwcml2YXRlIF9tYXhTY2FsZT87XG4gICAgLyoqIEluaXRpYWwgY29uZmlnICovXG4gICAgcHJpdmF0ZSBfY29uZmlnUHJpbWFyeTtcbiAgICBwcml2YXRlIF9jb25maWc7XG4gICAgcHJpdmF0ZSBfaW1nUmVjdDtcbiAgICBwcml2YXRlIF9yb3RhdGlvbjtcbiAgICBwcml2YXRlIF9pc1NsaWRpbmc7XG4gICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBsYXN0IHBvaW50ZXIgZXZlbnQgdGhhdCB3YXMgY2FwdHVyZWQgYnkgdGhlIGNyb3AgYXJlYS4gKi9cbiAgICBwcml2YXRlIF9sYXN0UG9pbnRlckV2ZW50O1xuICAgIHByaXZhdGUgX3N0YXJ0UG9pbnRlckV2ZW50O1xuICAgIF9wcmltYXJ5QXJlYVdpZHRoOiBudW1iZXI7XG4gICAgX3ByaW1hcnlBcmVhSGVpZ2h0OiBudW1iZXI7XG4gICAgX2Fic29sdXRlU2NhbGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBXaGVuIGlzIGxvYWRlZCBpbWFnZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pc0xvYWRlZEltZzogYm9vbGVhbjtcbiAgICAvKiogV2hlbiBpcyBsb2FkZWQgaW1hZ2UgJiByZWFkeSBmb3IgY3JvcCAqL1xuICAgIGlzTG9hZGVkOiBib29sZWFuO1xuICAgIC8qKiBXaGVuIHRoZSBjcm9wcGVyIGlzIHJlYWR5IHRvIGJlIGludGVyYWN0ZWQgICovXG4gICAgaXNSZWFkeTogYm9vbGVhbjtcbiAgICBpc0Nyb3BwZWQ6IGJvb2xlYW47XG4gICAgX2ltZ0NvbnRhaW5lcjogRWxlbWVudFJlZjtcbiAgICBfYXJlYVJlZjogRWxlbWVudFJlZjtcbiAgICBfaW1nQ2FudmFzOiBFbGVtZW50UmVmPEhUTUxDYW52YXNFbGVtZW50PjtcbiAgICBnZXQgY29uZmlnKCk6IEltZ0Nyb3BwZXJDb25maWc7XG4gICAgc2V0IGNvbmZpZyh2YWw6IEltZ0Nyb3BwZXJDb25maWcpO1xuICAgIC8qKiBTZXQgc2NhbGUgKi9cbiAgICBnZXQgc2NhbGUoKTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIHNldCBzY2FsZSh2YWw6IG51bWJlciB8IHVuZGVmaW5lZCk7XG4gICAgLyoqXG4gICAgICogRW1pdCBldmVudCBgZXJyb3JgIGlmIHRoZSBmaWxlIHNpemUgZm9yIHRoZSBsaW1pdC5cbiAgICAgKiBOb3RlOiBJdCBvbmx5IHdvcmtzIHdoZW4gdGhlIGltYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIGA8aW5wdXQ+YCBldmVudC5cbiAgICAgKi9cbiAgICBtYXhGaWxlU2l6ZTogbnVtYmVyO1xuICAgIC8qKiBHZXQgbWluIHNjYWxlICovXG4gICAgZ2V0IG1pblNjYWxlKCk6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBzY2FsZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj47XG4gICAgLyoqIEVtaXRzIG1pbmltdW0gc3VwcG9ydGVkIGltYWdlIHNjYWxlICovXG4gICAgcmVhZG9ubHkgbWluU2NhbGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+O1xuICAgIC8qKiBFbWl0cyBtYXhpbXVtIHN1cHBvcnRlZCBpbWFnZSBzY2FsZSAqL1xuICAgIHJlYWRvbmx5IG1heFNjYWxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPjtcbiAgICAvKiogQGRlcHJlY2F0ZWQgRW1pdHMgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkLCBpbnN0ZWFkIHVzZSBgcmVhZHlgICovXG4gICAgcmVhZG9ubHkgbG9hZGVkOiBFdmVudEVtaXR0ZXI8SW1nQ3JvcHBlckV2ZW50PjtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkICovXG4gICAgcmVhZG9ubHkgaW1hZ2VMb2FkZWQ6IEV2ZW50RW1pdHRlcjxJbWdDcm9wcGVyRXZlbnQ+O1xuICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBjcm9wcGVyIGlzIHJlYWR5IHRvIGJlIGludGVyYWN0ZWQgKi9cbiAgICByZWFkb25seSByZWFkeTogRXZlbnRFbWl0dGVyPEltZ0Nyb3BwZXJFdmVudD47XG4gICAgLyoqIE9uIGNyb3AgbmV3IGltYWdlICovXG4gICAgcmVhZG9ubHkgY3JvcHBlZDogRXZlbnRFbWl0dGVyPEltZ0Nyb3BwZXJFdmVudD47XG4gICAgLyoqIEVtaXRzIHdoZW4gdGhlIGNyb3BwZXIgaXMgY2xlYW5lZCAqL1xuICAgIHJlYWRvbmx5IGNsZWFuZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKiogRW1pdCBhbiBlcnJvciB3aGVuIHRoZSBsb2FkZWQgaW1hZ2UgaXMgbm90IHZhbGlkICovXG4gICAgcmVhZG9ubHkgZXJyb3I6IEV2ZW50RW1pdHRlcjxJbWdDcm9wcGVyRXJyb3JFdmVudD47XG4gICAgcHJpdmF0ZSBfY3VycmVudElucHV0RWxlbWVudD87XG4gICAgLyoqIEVtaXRzIHdoZW5ldmVyIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLiAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3k7XG4gICAgLyoqIFVzZWQgdG8gc3Vic2NyaWJlIHRvIGdsb2JhbCBtb3ZlIGFuZCBlbmQgZXZlbnRzICovXG4gICAgcHJvdGVjdGVkIF9kb2N1bWVudDogRG9jdW1lbnQ7XG4gICAgY29uc3RydWN0b3Ioc1JlbmRlcmVyOiBTdHlsZVJlbmRlcmVyLCBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LCBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9uZ1pvbmU6IE5nWm9uZSwgX2RvY3VtZW50OiBhbnksIHZpZXdQb3J0UnVsZXI6IFZpZXdwb3J0UnVsZXIpO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogTG9hZCBpbWFnZSB3aXRoIGNhbnZhcyAqL1xuICAgIHByaXZhdGUgX2ltZ0xvYWRlZDtcbiAgICBwcml2YXRlIF9zZXRTdHlsZXNGb3JDb250SW1nO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhcmVhIGFuZCBpbWFnZSBwb3NpdGlvbiBvbmx5IGlmIG5lZWRlZCxcbiAgICAgKiB0aGlzIGlzIHVzZWQgd2hlbiB3aW5kb3cgcmVzaXplXG4gICAgICovXG4gICAgdXBkYXRlQ3JvcHBlclBvc2l0aW9uKCk6IHZvaWQ7XG4gICAgLyoqIExvYWQgSW1hZ2UgZnJvbSBpbnB1dCBldmVudCAqL1xuICAgIHNlbGVjdElucHV0RXZlbnQoaW1nOiBFdmVudCk6IHZvaWQ7XG4gICAgLyoqIFNldCB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2UsIHRoZSB2YWx1ZXMgY2FuIGJlIDAgYmV0d2VlbiAxLCB3aGVyZSAxIGlzIHRoZSBvcmlnaW5hbCBzaXplICovXG4gICAgc2V0U2NhbGUoc2l6ZT86IG51bWJlciwgbm9BdXRvQ3JvcD86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHByaXZhdGUgX2dldENlbnRlclBvaW50cztcbiAgICAvKipcbiAgICAgKiBGaXQgdG8gc2NyZWVuXG4gICAgICovXG4gICAgZml0VG9TY3JlZW4oKTogdm9pZDtcbiAgICBmaXQoKTogdm9pZDtcbiAgICBwcml2YXRlIF9wb2ludGVyRG93bjtcbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZSBwb2ludGVyTW92ZSB3aXRoIGNsaWVudFggPSAwIGFuZCBjbGllbnRZID0gMCxcbiAgICAgKiB0aGlzIGlzIHVzZWQgYnkgYHNldFNjYWxlYCBhbmQgYHJvdGF0ZWBcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zaW11bGF0ZVBvaW50ZXJNb3ZlO1xuICAgIF9tYXJrRm9yQ2hlY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgbW92ZWQgdGhlaXIgcG9pbnRlciBhZnRlclxuICAgICAqIHN0YXJ0aW5nIHRvIGRyYWcuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfcG9pbnRlck1vdmU7XG4gICAgdXBkYXRlUG9zaXRpb24oKTogdm9pZDtcbiAgICB1cGRhdGVQb3NpdGlvbih4T3JpZ2luOiBudW1iZXIsIHlPcmlnaW46IG51bWJlcik6IHZvaWQ7XG4gICAgX3NsaWRlRW5kKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfY3JvcElmQXV0b0Nyb3A7XG4gICAgLyoqICsgKi9cbiAgICB6b29tSW4oKTogdm9pZDtcbiAgICAvKiogQ2xlYW4gdGhlIGltZyBjcm9wcGVyICovXG4gICAgY2xlYW4oKTogdm9pZDtcbiAgICAvKiogLSAqL1xuICAgIHpvb21PdXQoKTogdm9pZDtcbiAgICBjZW50ZXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBsb2FkIGFuIGltYWdlIGZyb20gYSBnaXZlbiBjb25maWd1cmF0aW9uLFxuICAgICAqIG9yIGZyb20gdGhlIHJlc3VsdCBvZiBhIGNyb3BwZWQgaW1hZ2VcbiAgICAgKi9cbiAgICBsb2FkSW1hZ2UoY29uZmlnOiBJbWdDcm9wcGVyTG9hZGVyQ29uZmlnIHwgc3RyaW5nLCBmbj86ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIHByaXZhdGUgX3VwZGF0ZUFyZWFJZk5lZWRlZDtcbiAgICBwcml2YXRlIF91cGRhdGVBYnNvbHV0ZVNjYWxlO1xuICAgIC8qKlxuICAgICAqIExvYWQgSW1hZ2UgZnJvbSBVUkxcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGxvYWRJbWFnZWAgaW5zdGVhZCBvZiBgc2V0SW1hZ2VVcmxgXG4gICAgICogQHBhcmFtIHNyYyBVUkxcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgZW1pdCB0aGUgZXZlbnQgbG9hZGVkXG4gICAgICovXG4gICAgc2V0SW1hZ2VVcmwoc3JjOiBzdHJpbmcsIGZuPzogKCkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfcG9zaXRpb25JbWc7XG4gICAgcm90YXRlKGRlZ3JlZXM6IG51bWJlcik6IHZvaWQ7XG4gICAgX3VwZGF0ZU1pblNjYWxlKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZDtcbiAgICBwcml2YXRlIF91cGRhdGVNYXhTY2FsZTtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgJiBjcm9wIGltYWdlXG4gICAgICovXG4gICAgY3JvcChjb25maWc/OiBJbWdDcm9wcGVyQ29uZmlnKTogSW1nQ3JvcHBlckV2ZW50O1xuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIF9pbWdDcm9wO1xuICAgIF9yb290UmVjdCgpOiBET01SZWN0O1xuICAgIF9hcmVhQ3JvcHBlclJlY3QoKTogRE9NUmVjdDtcbiAgICBfY2FudmFzUmVjdCgpOiBET01SZWN0O1xuICAgIC8qKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgbGlmdGVkIHRoZWlyIHBvaW50ZXIuICovXG4gICAgcHJpdmF0ZSBfcG9pbnRlclVwO1xuICAgIC8qKiBDYWxsZWQgd2hlbiB0aGUgd2luZG93IGhhcyBsb3N0IGZvY3VzLiAqL1xuICAgIHByaXZhdGUgX3dpbmRvd0JsdXI7XG4gICAgcHJpdmF0ZSBfYmluZEdsb2JhbEV2ZW50cztcbiAgICAvKiogUmVtb3ZlcyBhbnkgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlIG1heSBoYXZlIGFkZGVkLiAqL1xuICAgIHByaXZhdGUgX3JlbW92ZUdsb2JhbEV2ZW50cztcbiAgICAvKiogVXNlIGRlZmF1bHRWaWV3IG9mIGluamVjdGVkIGRvY3VtZW50IGlmIGF2YWlsYWJsZSBvciBmYWxsYmFjayB0byBnbG9iYWwgd2luZG93IHJlZmVyZW5jZSAqL1xuICAgIHByaXZhdGUgX2dldFdpbmRvdztcbn1cbi8qKlxuICogTm9ybWFsaXplIGRlZ3JlZXMgZm9yIGNyb3BwZXIgcm90YXRpb25cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gX25vcm1hbGl6ZURlZ3JlZXMobjogbnVtYmVyKTogbnVtYmVyO1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gcm91bmQobjogbnVtYmVyKTogbnVtYmVyO1xuIl19