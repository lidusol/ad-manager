import { ElementRef, ChangeDetectorRef, EventEmitter, Renderer2, OnDestroy, NgZone, OnInit } from '@angular/core';
import { ThemeVariables, ThemeRef, StyleCollection, LyClasses, StyleTemplate, StyleRenderer } from '@alyle/ui';
import { ViewportRuler } from '@angular/cdk/scrolling';
export interface LyImageCropperTheme {
    /** Styles for Image Cropper Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
}
export interface LyImageCropperVariables {
    cropper?: LyImageCropperTheme;
}
export declare const STYLES: (theme: ThemeVariables & LyImageCropperVariables, ref: ThemeRef) => {
    $name: string;
    $priority: number;
    root: () => (className: string) => string;
    imgContainer: (className: string) => string;
    overlay: (className: string) => string;
    area: (className: string) => string;
    resizer: (className: string) => string;
    defaultContent: (className: string) => string;
};
/** Image Cropper Config */
export declare class ImgCropperConfig {
    /** Cropper area width */
    width: number;
    /** Cropper area height */
    height: number;
    minWidth?: number;
    minHeight?: number;
    /** If this is not defined, the new image will be automatically defined. */
    type?: string;
    /** Background color( default: null), if is null in png is transparent but not in jpg. */
    fill?: string | null;
    /**
     * Set anti-aliased (default: true)
     * @deprecated this is not necessary as the cropper will automatically resize the image
     * to the best quality
     */
    antiAliased?: boolean;
    autoCrop?: boolean;
    output?: ImgOutput | ImgResolution;
    /**
     * Zoom out until the entire image fits into the cropping area.
     * default: false
     */
    extraZoomOut?: boolean;
    /**
     * Emit event `error` if the file size in bytes for the limit.
     * Note: It only works when the image is received from the `<input>` event.
     */
    maxFileSize?: number | null;
    /**
     * Whether the cropper area will be round.
     * This implies that the cropper area will maintain its aspect ratio.
     * default: false
     */
    round?: boolean;
    /**
     * Whether the cropper area is resizable.
     * default: false
     */
    resizableArea?: boolean;
    /**
     * Keep the width and height of the growing area the same according
     * to `ImgCropperConfig.width` and `ImgCropperConfig.height`
     * default: false
     */
    keepAspectRatio?: boolean;
    /**
     * Whether the cropper area is responsive.
     * By default, the width and height of the cropper area is fixed,
     * so can use when the cropper area is larger than its container,
     * otherwise this will bring problems when cropping.
     */
    responsiveArea?: boolean;
}
/**
 * The output image
 * With this option you can resize the output image.
 * If `width` or `height` are 0, this will be set automatically.
 * Both cannot be 0.
 */
export interface ImgOutput {
    /**
     * The cropped image will be resized to this `width`.
     */
    width: number;
    /**
     * Cropped image will be resized to this `height`.
     */
    height: number;
}
/** Image output */
export declare enum ImgResolution {
    /**
     * The output image will be equal to the initial size of the cropper area.
     */
    Default = 0,
    /** Just crop the image without resizing */
    OriginalImage = 1
}
/** Image output */
export declare enum ImgCropperError {
    /** The loaded image exceeds the size limit set. */
    Size = 0,
    /** The file loaded is not image. */
    Type = 1,
    /** When the image has not been loaded. */
    Other = 2
}
export interface ImgCropperEvent {
    /** Cropped image data URL */
    dataURL?: string;
    name: string | null;
    /** Filetype */
    type?: string;
    /** Cropped area width */
    areaWidth: number;
    /** Cropped area height */
    areaHeight: number;
    /** Cropped image width */
    width: number;
    /** Cropped image height */
    height: number;
    /** Original Image data URL */
    originalDataURL?: string;
    scale: number;
    /** Current rotation in degrees */
    rotation: number;
    /** Size of the image in bytes */
    size: number;
    /** Scaled offset from the left edge of the image */
    left: number;
    /** Scaled offset from the top edge of the image */
    top: number;
    /**
     * Scaled offset from the left edge of the image to center of area
     * Can be used to set image position
     */
    xOrigin: number;
    /**
     * Scaled offset from the top edge of the image to center of area
     * Can be used to set image position
     */
    yOrigin: number;
    /** @deprecated Use `xOrigin & yOrigin` instead. */
    position?: {
        x: number;
        y: number;
    };
}
export interface ImgCropperErrorEvent {
    name?: string;
    /** Size of the image in bytes */
    size: number;
    /** Filetype */
    type: string;
    /** Type of error */
    error: ImgCropperError;
    errorMsg?: string;
}
export interface ImgCropperLoaderConfig {
    name?: string | null;
    /** Filetype */
    type?: string;
    /** Cropped area width */
    areaWidth?: number;
    /** Cropped area height */
    areaHeight?: number;
    /** Cropped image width */
    width?: number;
    /** Cropped image height */
    height?: number;
    /** Original Image data URL */
    originalDataURL: string;
    scale?: number;
    /** Current rotation in degrees */
    rotation?: number;
    /** Size of the image in bytes */
    size?: number;
    /** Offset from the left edge of the image to center of area */
    xOrigin?: number;
    /** Offset from the top edge of the image to center of area */
    yOrigin?: number;
}
export declare class LyImageCropper implements OnInit, OnDestroy {
    readonly sRenderer: StyleRenderer;
    private _renderer;
    readonly _elementRef: ElementRef<HTMLElement>;
    private cd;
    private _ngZone;
    static readonly Ð¸ = "LyImageCropper";
    /**
     * styles
     * @docs-private
     */
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        imgContainer: string;
        overlay: string;
        area: string;
        resizer: string;
        defaultContent: string;
    }, "root" | "imgContainer" | "overlay" | "area" | "resizer" | "defaultContent">;
    private _currentLoadConfig?;
    /** Original image */
    private _img;
    private offset?;
    private _scale?;
    private _scal3Fix?;
    private _minScale?;
    private _maxScale?;
    /** Initial config */
    private _configPrimary;
    private _config;
    private _imgRect;
    private _rotation;
    private _isSliding;
    /** Keeps track of the last pointer event that was captured by the crop area. */
    private _lastPointerEvent;
    private _startPointerEvent;
    _primaryAreaWidth: number;
    _primaryAreaHeight: number;
    _absoluteScale: number;
    /**
     * When is loaded image
     * @internal
     */
    _isLoadedImg: boolean;
    /** When is loaded image & ready for crop */
    isLoaded: boolean;
    /** When the cropper is ready to be interacted  */
    isReady: boolean;
    isCropped: boolean;
    _imgContainer: ElementRef;
    _areaRef: ElementRef;
    _imgCanvas: ElementRef<HTMLCanvasElement>;
    get config(): ImgCropperConfig;
    set config(val: ImgCropperConfig);
    /** Set scale */
    get scale(): number | undefined;
    set scale(val: number | undefined);
    /**
     * Emit event `error` if the file size for the limit.
     * Note: It only works when the image is received from the `<input>` event.
     */
    maxFileSize: number;
    /** Get min scale */
    get minScale(): number | undefined;
    readonly scaleChange: EventEmitter<number>;
    /** Emits minimum supported image scale */
    readonly minScaleChange: EventEmitter<number>;
    /** Emits maximum supported image scale */
    readonly maxScaleChange: EventEmitter<number>;
    /** @deprecated Emits when the image is loaded, instead use `ready` */
    readonly loaded: EventEmitter<ImgCropperEvent>;
    /** Emits when the image is loaded */
    readonly imageLoaded: EventEmitter<ImgCropperEvent>;
    /** Emits when the cropper is ready to be interacted */
    readonly ready: EventEmitter<ImgCropperEvent>;
    /** On crop new image */
    readonly cropped: EventEmitter<ImgCropperEvent>;
    /** Emits when the cropper is cleaned */
    readonly cleaned: EventEmitter<void>;
    /** Emit an error when the loaded image is not valid */
    readonly error: EventEmitter<ImgCropperErrorEvent>;
    private _currentInputElement?;
    /** Emits whenever the component is destroyed. */
    private readonly _destroy;
    /** Used to subscribe to global move and end events */
    protected _document: Document;
    constructor(sRenderer: StyleRenderer, _renderer: Renderer2, _elementRef: ElementRef<HTMLElement>, cd: ChangeDetectorRef, _ngZone: NgZone, _document: any, viewPortRuler: ViewportRuler);
    ngOnInit(): void;
    ngOnDestroy(): void;
    /** Load image with canvas */
    private _imgLoaded;
    private _setStylesForContImg;
    /**
     * Update area and image position only if needed,
     * this is used when window resize
     */
    updateCropperPosition(): void;
    /** Load Image from input event */
    selectInputEvent(img: Event): void;
    /** Set the size of the image, the values can be 0 between 1, where 1 is the original size */
    setScale(size?: number, noAutoCrop?: boolean): void;
    private _getCenterPoints;
    /**
     * Fit to screen
     */
    fitToScreen(): void;
    fit(): void;
    private _pointerDown;
    /**
     * Simulate pointerMove with clientX = 0 and clientY = 0,
     * this is used by `setScale` and `rotate`
     */
    private _simulatePointerMove;
    _markForCheck(): void;
    /**
     * Called when the user has moved their pointer after
     * starting to drag.
     */
    private _pointerMove;
    updatePosition(): void;
    updatePosition(xOrigin: number, yOrigin: number): void;
    _slideEnd(): void;
    private _cropIfAutoCrop;
    /** + */
    zoomIn(): void;
    /** Clean the img cropper */
    clean(): void;
    /** - */
    zoomOut(): void;
    center(): void;
    /**
     * load an image from a given configuration,
     * or from the result of a cropped image
     */
    loadImage(config: ImgCropperLoaderConfig | string, fn?: () => void): void;
    private _updateAreaIfNeeded;
    private _updateAbsoluteScale;
    /**
     * Load Image from URL
     * @deprecated Use `loadImage` instead of `setImageUrl`
     * @param src URL
     * @param fn function that will be called before emit the event loaded
     */
    setImageUrl(src: string, fn?: () => void): void;
    private _positionImg;
    rotate(degrees: number): void;
    _updateMinScale(canvas?: HTMLCanvasElement): void;
    private _updateMaxScale;
    /**
     * Resize & crop image
     */
    crop(config?: ImgCropperConfig): ImgCropperEvent;
    /**
     * @docs-private
     */
    private _imgCrop;
    _rootRect(): DOMRect;
    _areaCropperRect(): DOMRect;
    _canvasRect(): DOMRect;
    /** Called when the user has lifted their pointer. */
    private _pointerUp;
    /** Called when the window has lost focus. */
    private _windowBlur;
    private _bindGlobalEvents;
    /** Removes any global event listeners that we may have added. */
    private _removeGlobalEvents;
    /** Use defaultView of injected document if available or fallback to global window reference */
    private _getWindow;
}
/**
 * Normalize degrees for cropper rotation
 * @docs-private
 */
export declare function _normalizeDegrees(n: number): number;
export declare function round(n: number): number;
