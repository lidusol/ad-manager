import { AfterViewInit, ElementRef, OnDestroy, OnInit, Renderer2, TemplateRef, EventEmitter, OnChanges, QueryList } from '@angular/core';
import { LyOverlay, LyTheme2, OverlayFactory, Placement, ThemeVariables, XPosition, YPosition, StyleCollection, LyClasses, StyleTemplate, ThemeRef, StyleRenderer } from '@alyle/ui';
import { AnimationEvent } from '@angular/animations';
import { BooleanInput } from '@angular/cdk/coercion';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Subject } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export interface LyMenuTheme {
    /** Styles for Menu Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
}
export interface LyMenuVariables {
    menu?: LyMenuTheme;
}
export declare const STYLES: (theme: ThemeVariables & LyMenuVariables, ref: ThemeRef) => {
    $name: string;
    $priority: number;
    root: () => StyleTemplate;
    container: (className: string) => string;
    item: (className: string) => string;
    itemSubMenuTrigger: () => (className: string) => string;
};
/** Menu container */
export declare class LyMenu implements OnChanges, OnInit, AfterViewInit, OnDestroy {
    private _theme;
    private _el;
    private _renderer;
    private _viewportRuler;
    readonly sRenderer: StyleRenderer;
    /** Menu Trigger */
    set ref(value: LyMenuTriggerFor);
    get ref(): LyMenuTriggerFor;
    /** Whether the menu has a backdrop. */
    get hasBackdrop(): boolean;
    set hasBackdrop(value: boolean);
    constructor(_theme: LyTheme2, _el: ElementRef, _renderer: Renderer2, _viewportRuler: ViewportRuler, sRenderer: StyleRenderer);
    /** @docs-private */
    static readonly и = "LyMenu";
    static ngAcceptInputType_hasBackdrop: BooleanInput;
    /**
     * styles
     * @docs-private
     */
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        container: string;
        item: string;
        itemSubMenuTrigger: string;
    }, "root" | "container" | "item" | "itemSubMenuTrigger">;
    /** Whether the menu is animating. */
    _isAnimating: boolean;
    /** Whether the menu is destroying. */
    _isDestroying: boolean;
    /** Emits whenever an animation on the menu completes. */
    _animationDone: Subject<AnimationEvent>;
    private _menuRef;
    /**
     * Destroy menu
     * @docs-private
     */
    destroy: () => void;
    _container?: ElementRef<HTMLDivElement>;
    readonly menuItems?: QueryList<LyMenuItem>;
    private _ref;
    /** The point in the anchor where the menu `xAxis` will be attached. */
    xAnchor: XPosition;
    /** The point in the anchor where the menu `yAxis` will be attached. */
    yAnchor: YPosition;
    /** The x-axis position of the menu. */
    xAxis: XPosition;
    /** The y-axis position of the menu. */
    yAxis: YPosition;
    /**
     * Position where the menu will be placed.
     * @deprecated Use `xAxis` and` yAxis` together instead.
     */
    placement: Placement;
    /**
     * The x-axis position of the menu.
     * @deprecated Use `xAxis` instead.
     */
    xPosition: XPosition;
    /**
     * The y-axis position of the menu.
     * @deprecated Use `yAxis` instead.
     */
    yPosition: YPosition;
    private _hasBackdrop;
    private _mouseenterListen?;
    private _mouseleaveListen?;
    transformMenuLeave: unknown;
    ngOnChanges(): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _checkBackdropAndOpenOnHover;
    private _getHostMenuTrigger;
    private _addOpenOnHover;
    /** Remove listeners */
    private _removeOpenOnHoverListeners;
    /** Update Menu Position */
    private _updatePlacement;
    _onAnimationStart(event: AnimationEvent): void;
    _onAnimationDone(event: AnimationEvent): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyMenu, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<LyMenu, "ly-menu", ["lyMenu"], { "ref": "ref"; "hasBackdrop": "hasBackdrop"; "xAnchor": "xAnchor"; "yAnchor": "yAnchor"; "xAxis": "xAxis"; "yAxis": "yAxis"; "placement": "placement"; "xPosition": "xPosition"; "yPosition": "yPosition"; }, {}, ["menuItems"], ["*"]>;
}
export declare class LyMenuItem {
    private _menu;
    constructor(_menu: LyMenu, el: ElementRef, renderer: Renderer2);
    private _itemSubMenuTrigger?;
    _handleClick(): void;
    _handleMouseEnter(): void;
    /** Except for this, close all menus */
    private _closeOtherMenus;
    _setItemSubMenuTrigger(menuTrigger: LyMenuTriggerFor): void;
    _getItemSubMenuTrigger(): LyMenuTriggerFor;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyMenuItem, [{ optional: true; }, null, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LyMenuItem, "[ly-menu-item]", never, {}, {}, never>;
}
export declare class LyMenuTriggerFor implements OnDestroy {
    private elementRef;
    private overlay;
    private _menuItem;
    readonly sRenderer: StyleRenderer;
    _menu: LyMenu;
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        container: string;
        item: string;
        itemSubMenuTrigger: string;
    }, "root" | "container" | "item" | "itemSubMenuTrigger">;
    /** Current menuRef */
    _menuRef?: OverlayFactory | null;
    private _menuOpen;
    private _destroying;
    _menuDetached: Subject<void>;
    _menuOpenOnHoverRef?: LyMenuOpenOnHover;
    /** Whether the menu is open. */
    get menuOpen(): boolean;
    lyMenuTriggerFor: TemplateRef<any>;
    /** Data to be passed to the menu. */
    menuData: any;
    readonly menuOpened: EventEmitter<void>;
    readonly menuClosed: EventEmitter<void>;
    constructor(elementRef: ElementRef, overlay: LyOverlay, _menuItem: LyMenuItem, sRenderer: StyleRenderer, _menu: LyMenu);
    ngOnDestroy(): void;
    _handleClick(): void;
    /** Opens the menu */
    openMenu(): void;
    /** Closes the menu */
    closeMenu(): void;
    /** Toggle menu */
    toggleMenu(): void;
    /** @docs-private */
    detach(): void;
    /** @docs-private */
    destroy(menuRef: OverlayFactory<any>): void;
    _getHostElement(): any;
    _setMenuOpenToTrue(): void;
    /**
     * @docs-private
     */
    _isItemSubMenuTrigger(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyMenuTriggerFor, [null, null, { optional: true; }, null, { optional: true; }]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LyMenuTriggerFor, "[lyMenuTriggerFor]", ["lyMenuTriggerFor"], { "lyMenuTriggerFor": "lyMenuTriggerFor"; "menuData": "lyMenuTriggerData"; }, { "menuOpened": "menuOpened"; "menuClosed": "menuClosed"; }, never>;
}
export declare class LyMenuOpenOnHover implements OnDestroy {
    private _trigger;
    private _events;
    /** Whether menu should open on hover. */
    get openOnHover(): boolean;
    set openOnHover(value: boolean);
    private _openOnHover;
    constructor(_trigger: LyMenuTriggerFor);
    ngOnDestroy(): void;
    /** Handle mouseenter */
    _handleMouseEnterOrLeave(enter: true): void;
    /** Handle mouseleave */
    _handleMouseEnterOrLeave(leave: false): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyMenuOpenOnHover, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LyMenuOpenOnHover, "[lyMenuTriggerFor][openOnHover]", never, { "openOnHover": "openOnHover"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS5kLnRzIiwic291cmNlcyI6WyJtZW51LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTHlPdmVybGF5LCBMeVRoZW1lMiwgT3ZlcmxheUZhY3RvcnksIFBsYWNlbWVudCwgVGhlbWVWYXJpYWJsZXMsIFhQb3NpdGlvbiwgWVBvc2l0aW9uLCBTdHlsZUNvbGxlY3Rpb24sIEx5Q2xhc3NlcywgU3R5bGVUZW1wbGF0ZSwgVGhlbWVSZWYsIFN0eWxlUmVuZGVyZXIgfSBmcm9tICdAYWx5bGUvdWknO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBWaWV3cG9ydFJ1bGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5leHBvcnQgaW50ZXJmYWNlIEx5TWVudVRoZW1lIHtcbiAgICAvKiogU3R5bGVzIGZvciBNZW51IENvbXBvbmVudCAqL1xuICAgIHJvb3Q/OiBTdHlsZUNvbGxlY3Rpb248KChjbGFzc2VzOiBMeUNsYXNzZXM8dHlwZW9mIFNUWUxFUz4pID0+IFN0eWxlVGVtcGxhdGUpPiB8ICgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+KSA9PiBTdHlsZVRlbXBsYXRlKTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTHlNZW51VmFyaWFibGVzIHtcbiAgICBtZW51PzogTHlNZW51VGhlbWU7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBTVFlMRVM6ICh0aGVtZTogVGhlbWVWYXJpYWJsZXMgJiBMeU1lbnVWYXJpYWJsZXMsIHJlZjogVGhlbWVSZWYpID0+IHtcbiAgICAkbmFtZTogc3RyaW5nO1xuICAgICRwcmlvcml0eTogbnVtYmVyO1xuICAgIHJvb3Q6ICgpID0+IFN0eWxlVGVtcGxhdGU7XG4gICAgY29udGFpbmVyOiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBpdGVtOiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBpdGVtU3ViTWVudVRyaWdnZXI6ICgpID0+IChjbGFzc05hbWU6IHN0cmluZykgPT4gc3RyaW5nO1xufTtcbi8qKiBNZW51IGNvbnRhaW5lciAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTHlNZW51IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfdGhlbWU7XG4gICAgcHJpdmF0ZSBfZWw7XG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfdmlld3BvcnRSdWxlcjtcbiAgICByZWFkb25seSBzUmVuZGVyZXI6IFN0eWxlUmVuZGVyZXI7XG4gICAgLyoqIE1lbnUgVHJpZ2dlciAqL1xuICAgIHNldCByZWYodmFsdWU6IEx5TWVudVRyaWdnZXJGb3IpO1xuICAgIGdldCByZWYoKTogTHlNZW51VHJpZ2dlckZvcjtcbiAgICAvKiogV2hldGhlciB0aGUgbWVudSBoYXMgYSBiYWNrZHJvcC4gKi9cbiAgICBnZXQgaGFzQmFja2Ryb3AoKTogYm9vbGVhbjtcbiAgICBzZXQgaGFzQmFja2Ryb3AodmFsdWU6IGJvb2xlYW4pO1xuICAgIGNvbnN0cnVjdG9yKF90aGVtZTogTHlUaGVtZTIsIF9lbDogRWxlbWVudFJlZiwgX3JlbmRlcmVyOiBSZW5kZXJlcjIsIF92aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyLCBzUmVuZGVyZXI6IFN0eWxlUmVuZGVyZXIpO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgc3RhdGljIHJlYWRvbmx5INC4ID0gXCJMeU1lbnVcIjtcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaGFzQmFja2Ryb3A6IEJvb2xlYW5JbnB1dDtcbiAgICAvKipcbiAgICAgKiBzdHlsZXNcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgcmVhZG9ubHkgY2xhc3NlczogUGljazx7XG4gICAgICAgICRuYW1lOiBzdHJpbmc7XG4gICAgICAgICRwcmlvcml0eTogc3RyaW5nO1xuICAgICAgICByb290OiBzdHJpbmc7XG4gICAgICAgIGNvbnRhaW5lcjogc3RyaW5nO1xuICAgICAgICBpdGVtOiBzdHJpbmc7XG4gICAgICAgIGl0ZW1TdWJNZW51VHJpZ2dlcjogc3RyaW5nO1xuICAgIH0sIFwicm9vdFwiIHwgXCJjb250YWluZXJcIiB8IFwiaXRlbVwiIHwgXCJpdGVtU3ViTWVudVRyaWdnZXJcIj47XG4gICAgLyoqIFdoZXRoZXIgdGhlIG1lbnUgaXMgYW5pbWF0aW5nLiAqL1xuICAgIF9pc0FuaW1hdGluZzogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciB0aGUgbWVudSBpcyBkZXN0cm95aW5nLiAqL1xuICAgIF9pc0Rlc3Ryb3lpbmc6IGJvb2xlYW47XG4gICAgLyoqIEVtaXRzIHdoZW5ldmVyIGFuIGFuaW1hdGlvbiBvbiB0aGUgbWVudSBjb21wbGV0ZXMuICovXG4gICAgX2FuaW1hdGlvbkRvbmU6IFN1YmplY3Q8QW5pbWF0aW9uRXZlbnQ+O1xuICAgIHByaXZhdGUgX21lbnVSZWY7XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBtZW51XG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6ICgpID0+IHZvaWQ7XG4gICAgX2NvbnRhaW5lcj86IEVsZW1lbnRSZWY8SFRNTERpdkVsZW1lbnQ+O1xuICAgIHJlYWRvbmx5IG1lbnVJdGVtcz86IFF1ZXJ5TGlzdDxMeU1lbnVJdGVtPjtcbiAgICBwcml2YXRlIF9yZWY7XG4gICAgLyoqIFRoZSBwb2ludCBpbiB0aGUgYW5jaG9yIHdoZXJlIHRoZSBtZW51IGB4QXhpc2Agd2lsbCBiZSBhdHRhY2hlZC4gKi9cbiAgICB4QW5jaG9yOiBYUG9zaXRpb247XG4gICAgLyoqIFRoZSBwb2ludCBpbiB0aGUgYW5jaG9yIHdoZXJlIHRoZSBtZW51IGB5QXhpc2Agd2lsbCBiZSBhdHRhY2hlZC4gKi9cbiAgICB5QW5jaG9yOiBZUG9zaXRpb247XG4gICAgLyoqIFRoZSB4LWF4aXMgcG9zaXRpb24gb2YgdGhlIG1lbnUuICovXG4gICAgeEF4aXM6IFhQb3NpdGlvbjtcbiAgICAvKiogVGhlIHktYXhpcyBwb3NpdGlvbiBvZiB0aGUgbWVudS4gKi9cbiAgICB5QXhpczogWVBvc2l0aW9uO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdoZXJlIHRoZSBtZW51IHdpbGwgYmUgcGxhY2VkLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgeEF4aXNgIGFuZGAgeUF4aXNgIHRvZ2V0aGVyIGluc3RlYWQuXG4gICAgICovXG4gICAgcGxhY2VtZW50OiBQbGFjZW1lbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIHgtYXhpcyBwb3NpdGlvbiBvZiB0aGUgbWVudS5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHhBeGlzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHhQb3NpdGlvbjogWFBvc2l0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoZSB5LWF4aXMgcG9zaXRpb24gb2YgdGhlIG1lbnUuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB5QXhpc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICB5UG9zaXRpb246IFlQb3NpdGlvbjtcbiAgICBwcml2YXRlIF9oYXNCYWNrZHJvcDtcbiAgICBwcml2YXRlIF9tb3VzZWVudGVyTGlzdGVuPztcbiAgICBwcml2YXRlIF9tb3VzZWxlYXZlTGlzdGVuPztcbiAgICB0cmFuc2Zvcm1NZW51TGVhdmU6IHVua25vd247XG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZDtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfY2hlY2tCYWNrZHJvcEFuZE9wZW5PbkhvdmVyO1xuICAgIHByaXZhdGUgX2dldEhvc3RNZW51VHJpZ2dlcjtcbiAgICBwcml2YXRlIF9hZGRPcGVuT25Ib3ZlcjtcbiAgICAvKiogUmVtb3ZlIGxpc3RlbmVycyAqL1xuICAgIHByaXZhdGUgX3JlbW92ZU9wZW5PbkhvdmVyTGlzdGVuZXJzO1xuICAgIC8qKiBVcGRhdGUgTWVudSBQb3NpdGlvbiAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZVBsYWNlbWVudDtcbiAgICBfb25BbmltYXRpb25TdGFydChldmVudDogQW5pbWF0aW9uRXZlbnQpOiB2b2lkO1xuICAgIF9vbkFuaW1hdGlvbkRvbmUoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5TWVudUl0ZW0ge1xuICAgIHByaXZhdGUgX21lbnU7XG4gICAgY29uc3RydWN0b3IoX21lbnU6IEx5TWVudSwgZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlcjIpO1xuICAgIHByaXZhdGUgX2l0ZW1TdWJNZW51VHJpZ2dlcj87XG4gICAgX2hhbmRsZUNsaWNrKCk6IHZvaWQ7XG4gICAgX2hhbmRsZU1vdXNlRW50ZXIoKTogdm9pZDtcbiAgICAvKiogRXhjZXB0IGZvciB0aGlzLCBjbG9zZSBhbGwgbWVudXMgKi9cbiAgICBwcml2YXRlIF9jbG9zZU90aGVyTWVudXM7XG4gICAgX3NldEl0ZW1TdWJNZW51VHJpZ2dlcihtZW51VHJpZ2dlcjogTHlNZW51VHJpZ2dlckZvcik6IHZvaWQ7XG4gICAgX2dldEl0ZW1TdWJNZW51VHJpZ2dlcigpOiBMeU1lbnVUcmlnZ2VyRm9yO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTHlNZW51VHJpZ2dlckZvciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmO1xuICAgIHByaXZhdGUgb3ZlcmxheTtcbiAgICBwcml2YXRlIF9tZW51SXRlbTtcbiAgICByZWFkb25seSBzUmVuZGVyZXI6IFN0eWxlUmVuZGVyZXI7XG4gICAgX21lbnU6IEx5TWVudTtcbiAgICByZWFkb25seSBjbGFzc2VzOiBQaWNrPHtcbiAgICAgICAgJG5hbWU6IHN0cmluZztcbiAgICAgICAgJHByaW9yaXR5OiBzdHJpbmc7XG4gICAgICAgIHJvb3Q6IHN0cmluZztcbiAgICAgICAgY29udGFpbmVyOiBzdHJpbmc7XG4gICAgICAgIGl0ZW06IHN0cmluZztcbiAgICAgICAgaXRlbVN1Yk1lbnVUcmlnZ2VyOiBzdHJpbmc7XG4gICAgfSwgXCJyb290XCIgfCBcImNvbnRhaW5lclwiIHwgXCJpdGVtXCIgfCBcIml0ZW1TdWJNZW51VHJpZ2dlclwiPjtcbiAgICAvKiogQ3VycmVudCBtZW51UmVmICovXG4gICAgX21lbnVSZWY/OiBPdmVybGF5RmFjdG9yeSB8IG51bGw7XG4gICAgcHJpdmF0ZSBfbWVudU9wZW47XG4gICAgcHJpdmF0ZSBfZGVzdHJveWluZztcbiAgICBfbWVudURldGFjaGVkOiBTdWJqZWN0PHZvaWQ+O1xuICAgIF9tZW51T3Blbk9uSG92ZXJSZWY/OiBMeU1lbnVPcGVuT25Ib3ZlcjtcbiAgICAvKiogV2hldGhlciB0aGUgbWVudSBpcyBvcGVuLiAqL1xuICAgIGdldCBtZW51T3BlbigpOiBib29sZWFuO1xuICAgIGx5TWVudVRyaWdnZXJGb3I6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqIERhdGEgdG8gYmUgcGFzc2VkIHRvIHRoZSBtZW51LiAqL1xuICAgIG1lbnVEYXRhOiBhbnk7XG4gICAgcmVhZG9ubHkgbWVudU9wZW5lZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIHJlYWRvbmx5IG1lbnVDbG9zZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBvdmVybGF5OiBMeU92ZXJsYXksIF9tZW51SXRlbTogTHlNZW51SXRlbSwgc1JlbmRlcmVyOiBTdHlsZVJlbmRlcmVyLCBfbWVudTogTHlNZW51KTtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIF9oYW5kbGVDbGljaygpOiB2b2lkO1xuICAgIC8qKiBPcGVucyB0aGUgbWVudSAqL1xuICAgIG9wZW5NZW51KCk6IHZvaWQ7XG4gICAgLyoqIENsb3NlcyB0aGUgbWVudSAqL1xuICAgIGNsb3NlTWVudSgpOiB2b2lkO1xuICAgIC8qKiBUb2dnbGUgbWVudSAqL1xuICAgIHRvZ2dsZU1lbnUoKTogdm9pZDtcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGRldGFjaCgpOiB2b2lkO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZGVzdHJveShtZW51UmVmOiBPdmVybGF5RmFjdG9yeTxhbnk+KTogdm9pZDtcbiAgICBfZ2V0SG9zdEVsZW1lbnQoKTogYW55O1xuICAgIF9zZXRNZW51T3BlblRvVHJ1ZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNJdGVtU3ViTWVudVRyaWdnZXIoKTogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5TWVudU9wZW5PbkhvdmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF90cmlnZ2VyO1xuICAgIHByaXZhdGUgX2V2ZW50cztcbiAgICAvKiogV2hldGhlciBtZW51IHNob3VsZCBvcGVuIG9uIGhvdmVyLiAqL1xuICAgIGdldCBvcGVuT25Ib3ZlcigpOiBib29sZWFuO1xuICAgIHNldCBvcGVuT25Ib3Zlcih2YWx1ZTogYm9vbGVhbik7XG4gICAgcHJpdmF0ZSBfb3Blbk9uSG92ZXI7XG4gICAgY29uc3RydWN0b3IoX3RyaWdnZXI6IEx5TWVudVRyaWdnZXJGb3IpO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqIEhhbmRsZSBtb3VzZWVudGVyICovXG4gICAgX2hhbmRsZU1vdXNlRW50ZXJPckxlYXZlKGVudGVyOiB0cnVlKTogdm9pZDtcbiAgICAvKiogSGFuZGxlIG1vdXNlbGVhdmUgKi9cbiAgICBfaGFuZGxlTW91c2VFbnRlck9yTGVhdmUobGVhdmU6IGZhbHNlKTogdm9pZDtcbn1cbiJdfQ==