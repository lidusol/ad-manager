import { AfterViewInit, ElementRef, OnDestroy, OnInit, Renderer2, TemplateRef, EventEmitter, OnChanges, QueryList } from '@angular/core';
import { LyOverlay, LyTheme2, OverlayFactory, Placement, ThemeVariables, XPosition, YPosition, StyleCollection, LyClasses, StyleTemplate, ThemeRef, StyleRenderer } from '@alyle/ui';
import { AnimationEvent } from '@angular/animations';
import { BooleanInput } from '@angular/cdk/coercion';
import { ViewportRuler } from '@angular/cdk/scrolling';
import { Subject } from 'rxjs';
export interface LyMenuTheme {
    /** Styles for Menu Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
}
export interface LyMenuVariables {
    menu?: LyMenuTheme;
}
export declare const STYLES: (theme: ThemeVariables & LyMenuVariables, ref: ThemeRef) => {
    $name: string;
    $priority: number;
    root: () => StyleTemplate;
    container: (className: string) => string;
    item: (className: string) => string;
    itemSubMenuTrigger: () => (className: string) => string;
};
/** Menu container */
export declare class LyMenu implements OnChanges, OnInit, AfterViewInit, OnDestroy {
    private _theme;
    private _el;
    private _renderer;
    private _viewportRuler;
    readonly sRenderer: StyleRenderer;
    /** Menu Trigger */
    set ref(value: LyMenuTriggerFor);
    get ref(): LyMenuTriggerFor;
    /** Whether the menu has a backdrop. */
    get hasBackdrop(): boolean;
    set hasBackdrop(value: boolean);
    constructor(_theme: LyTheme2, _el: ElementRef, _renderer: Renderer2, _viewportRuler: ViewportRuler, sRenderer: StyleRenderer);
    /** @docs-private */
    static readonly Ð¸ = "LyMenu";
    static ngAcceptInputType_hasBackdrop: BooleanInput;
    /**
     * styles
     * @docs-private
     */
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        container: string;
        item: string;
        itemSubMenuTrigger: string;
    }, "root" | "container" | "item" | "itemSubMenuTrigger">;
    /** Whether the menu is animating. */
    _isAnimating: boolean;
    /** Whether the menu is destroying. */
    _isDestroying: boolean;
    /** Emits whenever an animation on the menu completes. */
    _animationDone: Subject<AnimationEvent>;
    private _menuRef;
    /**
     * Destroy menu
     * @docs-private
     */
    destroy: () => void;
    _container?: ElementRef<HTMLDivElement>;
    readonly menuItems?: QueryList<LyMenuItem>;
    private _ref;
    /** The point in the anchor where the menu `xAxis` will be attached. */
    xAnchor: XPosition;
    /** The point in the anchor where the menu `yAxis` will be attached. */
    yAnchor: YPosition;
    /** The x-axis position of the menu. */
    xAxis: XPosition;
    /** The y-axis position of the menu. */
    yAxis: YPosition;
    /**
     * Position where the menu will be placed.
     * @deprecated Use `xAxis` and` yAxis` together instead.
     */
    placement: Placement;
    /**
     * The x-axis position of the menu.
     * @deprecated Use `xAxis` instead.
     */
    xPosition: XPosition;
    /**
     * The y-axis position of the menu.
     * @deprecated Use `yAxis` instead.
     */
    yPosition: YPosition;
    private _hasBackdrop;
    private _mouseenterListen?;
    private _mouseleaveListen?;
    transformMenuLeave: unknown;
    ngOnChanges(): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _checkBackdropAndOpenOnHover;
    private _getHostMenuTrigger;
    private _addOpenOnHover;
    /** Remove listeners */
    private _removeOpenOnHoverListeners;
    /** Update Menu Position */
    private _updatePlacement;
    _onAnimationStart(event: AnimationEvent): void;
    _onAnimationDone(event: AnimationEvent): void;
}
export declare class LyMenuItem {
    private _menu;
    constructor(_menu: LyMenu, el: ElementRef, renderer: Renderer2);
    private _itemSubMenuTrigger?;
    _handleClick(): void;
    _handleMouseEnter(): void;
    /** Except for this, close all menus */
    private _closeOtherMenus;
    _setItemSubMenuTrigger(menuTrigger: LyMenuTriggerFor): void;
    _getItemSubMenuTrigger(): LyMenuTriggerFor;
}
export declare class LyMenuTriggerFor implements OnDestroy {
    private elementRef;
    private overlay;
    private _menuItem;
    readonly sRenderer: StyleRenderer;
    _menu: LyMenu;
    readonly classes: Pick<{
        $name: string;
        $priority: string;
        root: string;
        container: string;
        item: string;
        itemSubMenuTrigger: string;
    }, "root" | "container" | "item" | "itemSubMenuTrigger">;
    /** Current menuRef */
    _menuRef?: OverlayFactory | null;
    private _menuOpen;
    private _destroying;
    _menuDetached: Subject<void>;
    _menuOpenOnHoverRef?: LyMenuOpenOnHover;
    /** Whether the menu is open. */
    get menuOpen(): boolean;
    lyMenuTriggerFor: TemplateRef<any>;
    /** Data to be passed to the menu. */
    menuData: any;
    readonly menuOpened: EventEmitter<void>;
    readonly menuClosed: EventEmitter<void>;
    constructor(elementRef: ElementRef, overlay: LyOverlay, _menuItem: LyMenuItem, sRenderer: StyleRenderer, _menu: LyMenu);
    ngOnDestroy(): void;
    _handleClick(): void;
    /** Opens the menu */
    openMenu(): void;
    /** Closes the menu */
    closeMenu(): void;
    /** Toggle menu */
    toggleMenu(): void;
    /** @docs-private */
    detach(): void;
    /** @docs-private */
    destroy(menuRef: OverlayFactory<any>): void;
    _getHostElement(): any;
    _setMenuOpenToTrue(): void;
    /**
     * @docs-private
     */
    _isItemSubMenuTrigger(): boolean;
}
export declare class LyMenuOpenOnHover implements OnDestroy {
    private _trigger;
    private _events;
    /** Whether menu should open on hover. */
    get openOnHover(): boolean;
    set openOnHover(value: boolean);
    private _openOnHover;
    constructor(_trigger: LyMenuTriggerFor);
    ngOnDestroy(): void;
    /** Handle mouseenter */
    _handleMouseEnterOrLeave(enter: true): void;
    /** Handle mouseleave */
    _handleMouseEnterOrLeave(leave: false): void;
}
