import { ChangeDetectorRef, DoCheck, ElementRef, OnDestroy, OnInit, Renderer2, TemplateRef, NgZone, OnChanges, QueryList, AfterContentInit, EventEmitter } from '@angular/core';
import { ControlValueAccessor, FormGroupDirective, NgControl, NgForm } from '@angular/forms';
import { LyField, LyFieldControlBase } from '@alyle/ui/field';
import { LyOverlay, LyTheme2, ThemeVariables, LyRippleService, StyleCollection, LyClasses, StyleTemplate, ThemeRef, StyleRenderer, WithStyles } from '@alyle/ui';
import { Subject, Observable } from 'rxjs';
import { Platform } from '@angular/cdk/platform';
import { FocusableOption, FocusOrigin, ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { SelectionModel } from '@angular/cdk/collections';
import * as ɵngcc0 from '@angular/core';
export interface LySelectTheme {
    /** Styles for Select Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
}
export interface LySelectVariables {
    select?: LySelectTheme;
}
export declare const STYLES: (theme: ThemeVariables & LySelectVariables, ref: ThemeRef) => {
    $priority: number;
    root: () => (className: string) => string;
    container: {
        background: import("@alyle/ui/color/color").Color;
        borderRadius: string;
        boxShadow: string;
        display: string;
        transformOrigin: string;
        pointerEvents: string;
        overflow: string;
        maxHeight: string;
    };
    valueText: {
        overflow: string;
        textOverflow: string;
        whiteSpace: string;
    };
    option: {
        display: string;
        fontFamily: string;
        color: import("@alyle/ui/color/color").Color;
        '-webkit-tap-highlight-color': string;
        backgroundColor: string;
        border: number;
        padding: string;
        margin: number;
        outline: string;
        boxSizing: string;
        position: string;
        justifyContent: string;
        alignItems: string;
        alignContent: string;
        '-webkit-user-select': string;
        '-moz-user-select': string;
        '-ms-user-select': string;
        userSelect: string;
        lineHeight: number;
        height: string;
        cursor: string;
    };
    optionActive: (className: string) => string;
    optionText: {
        'ly-checkbox ~ &': {
            display: string;
            alignItems: string;
            alignContent: string;
        };
    };
    content: {
        padding: number;
        display: string;
        justifyContent: string;
        alignItems: string;
        alignContent: string;
        width: string;
        height: string;
        boxSizing: string;
    };
};
/** Change event object that is emitted when the select value has changed. */
export declare class LySelectChange {
    /** Reference to the select that emitted the change event. */
    source: LySelect;
    /** Current value of the select that emitted the event. */
    value: any;
    constructor(
    /** Reference to the select that emitted the change event. */
    source: LySelect, 
    /** Current value of the select that emitted the event. */
    value: any);
}
/** @docs-private */
export declare class LySelectBase {
}
/** @docs-private */
export declare const LySelectMixinBase: import("@alyle/ui/src/common/constructor").Constructor<import("@alyle/ui/alyle-ui").HasTabIndex> & import("@alyle/ui/src/common/constructor").Constructor<import("@alyle/ui/alyle-ui").CanDisable>;
/**
 * Allows the user to customize the trigger that is displayed when the select has a value.
 */
export declare class LySelectTrigger {
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LySelectTrigger, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<LySelectTrigger, "ly-select-trigger", never, {}, {}, never>;
}
export declare class LySelect extends LySelectMixinBase implements ControlValueAccessor, LyFieldControlBase, OnInit, DoCheck, AfterContentInit, OnDestroy {
    private _theme;
    readonly sRenderer: StyleRenderer;
    private _renderer;
    private _el;
    private _overlay;
    /** @internal */
    _field: LyField;
    /** @internal */
    _cd: ChangeDetectorRef;
    private _ngZone;
    /** @docs-private */
    ngControl: NgControl;
    private _parentForm;
    private _parentFormGroup;
    /** @docs-private */
    readonly classes: Pick<{
        $priority: string;
        root: string;
        container: string;
        valueText: string;
        option: string;
        optionActive: string;
        optionText: string;
        content: string;
    }, "root" | "container" | "valueText" | "option" | "optionActive" | "optionText" | "content">;
    /** @internal */
    _selectionModel: SelectionModel<LyOption>;
    /** @internal */
    _value: any;
    /** The cached font-size of the trigger element. */
    _triggerFontSize: number;
    private _overlayRef;
    protected _disabled: boolean;
    protected _required: boolean;
    protected _placeholder: string;
    readonly stateChanges: Subject<void>;
    private _hasDisabledClass?;
    private _errorClass?;
    private _form;
    private _multiple;
    private _opened;
    private _valueKey;
    _focused: boolean;
    errorState: boolean;
    private _cursorClass;
    /** Manages keyboard events for options in the panel. */
    _keyManager: ActiveDescendantKeyManager<LyOption>;
    /** Emits when the panel element is finished transforming in. */
    _panelDoneAnimatingStream: Subject<string>;
    /** Comparison function to specify which option is displayed. Defaults to object equality. */
    private _compareWith;
    /** Emits whenever the component is destroyed. */
    private readonly _destroy;
    /** Combined stream of all of the child options' change events. */
    readonly optionSelectionChanges: Observable<LyOptionSelectionChange>;
    templateRef: TemplateRef<any>;
    valueTextDivRef: ElementRef<HTMLDivElement>;
    /** @internal */
    _options: QueryList<LyOption>;
    options: QueryList<LyOption>;
    customTrigger: LySelectTrigger;
    /** Event emitted when the select panel has been toggled. */
    readonly openedChange: EventEmitter<boolean>;
    /** Event emitted when the select has been opened. */
    readonly _openedStream: Observable<void>;
    /** Event emitted when the select has been closed. */
    readonly _closedStream: Observable<void>;
    /** Event emitted when the selected value has been changed by the user. */
    readonly selectionChange: EventEmitter<LySelectChange>;
    /**
     * Event that emits whenever the raw value of the select changes. This is here primarily
     * to facilitate the two-way binding for the `value` input.
     * @docs-private
     */
    readonly valueChange: EventEmitter<any>;
    /**
     * The registered callback function called when a change event occurs on the input element.
     */
    onChange: (_: any) => void;
    /**
     * The registered callback function called when a blur event occurs on the input element.
     */
    onTouched: () => void;
    _onFocus(): void;
    _onBlur(): void;
    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */
    get typeaheadDebounceInterval(): number;
    set typeaheadDebounceInterval(value: number);
    private _typeaheadDebounceInterval;
    /** Value of the select control. */
    get value(): any;
    set value(newValue: any);
    /** Whether the input is disabled. */
    set disabled(val: boolean);
    get disabled(): boolean;
    set required(value: boolean);
    get required(): boolean;
    set multiple(value: boolean);
    get multiple(): boolean;
    /**
     * @deprecated has been deprecated in favor of `compareWith`
     */
    set valueKey(fn: (opt: unknown) => unknown);
    get valueKey(): (opt: unknown) => unknown;
    set placeholder(val: string);
    get placeholder(): string;
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     */
    get compareWith(): (o1: any, o2: any) => boolean;
    set compareWith(fn: (o1: any, o2: any) => boolean);
    /**
     * Function used to sort the values in a select in multiple mode.
     * Follows the same logic as `Array.prototype.sort`.
     */
    sortComparator: (a: LyOption, b: LyOption, options: LyOption[]) => number;
    get focused(): boolean;
    get empty(): boolean;
    get floatingLabel(): boolean;
    /** The value displayed in the trigger. */
    get triggerValue(): string;
    /** Current selecteds */
    get selected(): LyOption | LyOption[];
    constructor(_theme: LyTheme2, sRenderer: StyleRenderer, _renderer: Renderer2, _el: ElementRef, _overlay: LyOverlay, 
    /** @internal */
    _field: LyField, 
    /** @internal */
    _cd: ChangeDetectorRef, _ngZone: NgZone, 
    /** @docs-private */
    ngControl: NgControl, _parentForm: NgForm, _parentFormGroup: FormGroupDirective);
    ngOnInit(): void;
    ngDoCheck(): void;
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    open(): void;
    close(): void;
    /** @docs-private */
    onContainerClick(): void;
    /** Focuses the select element. */
    focus(options?: FocusOptions): void;
    _getHostElement(): any;
    /**
     * Sets the "value" property on the input element.
     *
     * @param value The checked value
     */
    writeValue(value: any): void;
    /**
     * Registers a function called when the control value changes.
     *
     * @param fn The callback function
     */
    registerOnChange(fn: (value: any) => any): void;
    /**
     * Registers a function called when the control is touched.
     *
     * @param fn The callback function
     */
    registerOnTouched(fn: () => any): void;
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    setDisabledState(isDisabled: boolean): void;
    /** Handles all keydown events on the select. */
    _handleKeydown(event: KeyboardEvent): void;
    /** Handles keyboard events while the select is closed. */
    private _handleClosedKeydown;
    /** Handles keyboard events when the selected is open. */
    private _handleOpenKeydown;
    private _initializeSelection;
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    private _setSelectionByValue;
    /**
     * Finds and selects and option based on its value.
     * @returns Option that has the corresponding value.
     */
    private _selectValue;
    private _updatePlacement;
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    private _initKeyManager;
    /** Sorts the selected values in the selected based on their order in the panel. */
    private _sortValues;
    private _resetOptions;
    /** Invoked when an option is clicked. */
    private _onSelect;
    /** Emits change event to set the model value. */
    private _propagateChanges;
    /**
     * Highlights the selected item. If no option is selected, it will highlight
     * the first item instead.
     */
    private _highlightCorrectOption;
    /** Scrolls the active option into view. */
    private _scrollActiveOptionIntoView;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LySelect, [null, null, null, null, null, { optional: true; }, null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<LySelect, "ly-select", ["lySelect"], { "tabIndex": "tabIndex"; "typeaheadDebounceInterval": "typeaheadDebounceInterval"; "value": "value"; "disabled": "disabled"; "required": "required"; "multiple": "multiple"; "valueKey": "valueKey"; "placeholder": "placeholder"; "compareWith": "compareWith"; "sortComparator": "sortComparator"; }, { "openedChange": "openedChange"; "_openedStream": "opened"; "_closedStream": "closed"; "selectionChange": "selectionChange"; "valueChange": "valueChange"; }, ["customTrigger", "options"], ["ly-select-trigger", "*"]>;
}
/** Event object emitted by LyOption when selected or deselected. */
export declare class LyOptionSelectionChange {
    /** Reference to the option that emitted the event. */
    source: LyOption;
    /** Whether the change in the option's value was a result of a user action. */
    isUserInput: boolean;
    constructor(
    /** Reference to the option that emitted the event. */
    source: LyOption, 
    /** Whether the change in the option's value was a result of a user action. */
    isUserInput?: boolean);
}
/** @docs-private */
export declare class LyOptionBase {
    _theme: LyTheme2;
    _ngZone: NgZone;
    _platform: Platform;
    constructor(_theme: LyTheme2, _ngZone: NgZone, _platform: Platform);
}
/** @docs-private */
export declare const LyOptionMixinBase: import("@alyle/ui/src/common/constructor").Constructor<import("@alyle/ui/src/common/disable-ripple").CanDisableRipple> & typeof LyOptionBase;
/**
 * @dynamic
 */
export declare class LyOption extends LyOptionMixinBase implements WithStyles, FocusableOption, OnInit, OnChanges {
    readonly sRenderer: StyleRenderer;
    /** @internal */
    readonly _select: LySelect;
    private _el;
    /** @internal */
    _rippleService: LyRippleService;
    /** @internal */
    _cd: ChangeDetectorRef;
    /** @docs-private */
    readonly classes: Pick<{
        $priority: string;
        root: string;
        container: string;
        valueText: string;
        option: string;
        optionActive: string;
        optionText: string;
        content: string;
    }, "root" | "container" | "valueText" | "option" | "optionActive" | "optionText" | "content">;
    private _value;
    private _selected;
    private _disabled;
    _rippleContainer: ElementRef;
    /** Event emitted when the option is selected or deselected. */
    readonly onSelectionChange: EventEmitter<LyOptionSelectionChange>;
    _onClick(): void;
    /** Whether or not the option is currently selected. */
    get selected(): boolean;
    /** Whether the wrapping component is in multiple selection mode. */
    get multiple(): boolean;
    /**
     * Tracks simple string values bound to the option element.
     */
    set value(value: any);
    get value(): any;
    /** Whether the option is disabled. */
    set disabled(value: any);
    get disabled(): any;
    _selectedColor: string | null;
    /** The displayed value of the option. */
    get viewValue(): string;
    /** The color of Select option */
    get _color(): string;
    /**
     * @deprecated use instead `selected`
     */
    get isSelected(): boolean;
    constructor(sRenderer: StyleRenderer, 
    /** @internal */
    _select: LySelect, _el: ElementRef, 
    /** @internal */
    _rippleService: LyRippleService, _renderer: Renderer2, _theme: LyTheme2, 
    /** @internal */
    _cd: ChangeDetectorRef, _ngZone: NgZone, platform: Platform);
    ngOnInit(): void;
    ngOnChanges(): void;
    /** Applies the styles for an active item to this item. */
    setActiveStyles(): void;
    /** Applies the styles for an inactive item to this item. */
    setInactiveStyles(): void;
    /** Gets the label to be used when determining whether the option should be focused. */
    getLabel(): string;
    /** Selects the option. */
    select(): void;
    /** Deselects the option. */
    deselect(): void;
    /** Sets focus onto this option. */
    focus(_origin?: FocusOrigin, options?: FocusOptions): void;
    /** Ensures the option is selected when activated from the keyboard. */
    _handleKeydown(event: KeyboardEvent): void;
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     */
    _selectViaInteraction(): void;
    /** @internal */
    _getHostElement(): HTMLElement;
    /** Returns the correct tabindex for the option depending on disabled state. */
    _getTabIndex(): string;
    /** Emits the selection change event. */
    private _emitSelectionChangeEvent;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LyOption, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<LyOption, "ly-option", never, { "disableRipple": "disableRipple"; "value": "value"; "disabled": "disabled"; }, { "onSelectionChange": "onSelectionChange"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmQudHMiLCJzb3VyY2VzIjpbInNlbGVjdC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRG9DaGVjaywgRWxlbWVudFJlZiwgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiwgVGVtcGxhdGVSZWYsIE5nWm9uZSwgT25DaGFuZ2VzLCBRdWVyeUxpc3QsIEFmdGVyQ29udGVudEluaXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Hcm91cERpcmVjdGl2ZSwgTmdDb250cm9sLCBOZ0Zvcm0gfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBMeUZpZWxkLCBMeUZpZWxkQ29udHJvbEJhc2UgfSBmcm9tICdAYWx5bGUvdWkvZmllbGQnO1xuaW1wb3J0IHsgTHlPdmVybGF5LCBMeVRoZW1lMiwgVGhlbWVWYXJpYWJsZXMsIEx5UmlwcGxlU2VydmljZSwgU3R5bGVDb2xsZWN0aW9uLCBMeUNsYXNzZXMsIFN0eWxlVGVtcGxhdGUsIFRoZW1lUmVmLCBTdHlsZVJlbmRlcmVyLCBXaXRoU3R5bGVzIH0gZnJvbSAnQGFseWxlL3VpJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IEZvY3VzYWJsZU9wdGlvbiwgRm9jdXNPcmlnaW4sIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZWwgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuZXhwb3J0IGludGVyZmFjZSBMeVNlbGVjdFRoZW1lIHtcbiAgICAvKiogU3R5bGVzIGZvciBTZWxlY3QgQ29tcG9uZW50ICovXG4gICAgcm9vdD86IFN0eWxlQ29sbGVjdGlvbjwoKGNsYXNzZXM6IEx5Q2xhc3Nlczx0eXBlb2YgU1RZTEVTPikgPT4gU3R5bGVUZW1wbGF0ZSk+IHwgKChjbGFzc2VzOiBMeUNsYXNzZXM8dHlwZW9mIFNUWUxFUz4pID0+IFN0eWxlVGVtcGxhdGUpO1xufVxuZXhwb3J0IGludGVyZmFjZSBMeVNlbGVjdFZhcmlhYmxlcyB7XG4gICAgc2VsZWN0PzogTHlTZWxlY3RUaGVtZTtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IFNUWUxFUzogKHRoZW1lOiBUaGVtZVZhcmlhYmxlcyAmIEx5U2VsZWN0VmFyaWFibGVzLCByZWY6IFRoZW1lUmVmKSA9PiB7XG4gICAgJHByaW9yaXR5OiBudW1iZXI7XG4gICAgcm9vdDogKCkgPT4gKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgY29udGFpbmVyOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGltcG9ydChcIkBhbHlsZS91aS9jb2xvci9jb2xvclwiKS5Db2xvcjtcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBzdHJpbmc7XG4gICAgICAgIGJveFNoYWRvdzogc3RyaW5nO1xuICAgICAgICBkaXNwbGF5OiBzdHJpbmc7XG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogc3RyaW5nO1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBzdHJpbmc7XG4gICAgICAgIG92ZXJmbG93OiBzdHJpbmc7XG4gICAgICAgIG1heEhlaWdodDogc3RyaW5nO1xuICAgIH07XG4gICAgdmFsdWVUZXh0OiB7XG4gICAgICAgIG92ZXJmbG93OiBzdHJpbmc7XG4gICAgICAgIHRleHRPdmVyZmxvdzogc3RyaW5nO1xuICAgICAgICB3aGl0ZVNwYWNlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBvcHRpb246IHtcbiAgICAgICAgZGlzcGxheTogc3RyaW5nO1xuICAgICAgICBmb250RmFtaWx5OiBzdHJpbmc7XG4gICAgICAgIGNvbG9yOiBpbXBvcnQoXCJAYWx5bGUvdWkvY29sb3IvY29sb3JcIikuQ29sb3I7XG4gICAgICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiBzdHJpbmc7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogc3RyaW5nO1xuICAgICAgICBib3JkZXI6IG51bWJlcjtcbiAgICAgICAgcGFkZGluZzogc3RyaW5nO1xuICAgICAgICBtYXJnaW46IG51bWJlcjtcbiAgICAgICAgb3V0bGluZTogc3RyaW5nO1xuICAgICAgICBib3hTaXppbmc6IHN0cmluZztcbiAgICAgICAgcG9zaXRpb246IHN0cmluZztcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgYWxpZ25JdGVtczogc3RyaW5nO1xuICAgICAgICBhbGlnbkNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiBzdHJpbmc7XG4gICAgICAgICctbW96LXVzZXItc2VsZWN0Jzogc3RyaW5nO1xuICAgICAgICAnLW1zLXVzZXItc2VsZWN0Jzogc3RyaW5nO1xuICAgICAgICB1c2VyU2VsZWN0OiBzdHJpbmc7XG4gICAgICAgIGxpbmVIZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgaGVpZ2h0OiBzdHJpbmc7XG4gICAgICAgIGN1cnNvcjogc3RyaW5nO1xuICAgIH07XG4gICAgb3B0aW9uQWN0aXZlOiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBvcHRpb25UZXh0OiB7XG4gICAgICAgICdseS1jaGVja2JveCB+ICYnOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiBzdHJpbmc7XG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBzdHJpbmc7XG4gICAgICAgICAgICBhbGlnbkNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgcGFkZGluZzogbnVtYmVyO1xuICAgICAgICBkaXNwbGF5OiBzdHJpbmc7XG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBzdHJpbmc7XG4gICAgICAgIGFsaWduSXRlbXM6IHN0cmluZztcbiAgICAgICAgYWxpZ25Db250ZW50OiBzdHJpbmc7XG4gICAgICAgIHdpZHRoOiBzdHJpbmc7XG4gICAgICAgIGhlaWdodDogc3RyaW5nO1xuICAgICAgICBib3hTaXppbmc6IHN0cmluZztcbiAgICB9O1xufTtcbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgdmFsdWUgaGFzIGNoYW5nZWQuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBMeVNlbGVjdENoYW5nZSB7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgc2VsZWN0IHRoYXQgZW1pdHRlZCB0aGUgY2hhbmdlIGV2ZW50LiAqL1xuICAgIHNvdXJjZTogTHlTZWxlY3Q7XG4gICAgLyoqIEN1cnJlbnQgdmFsdWUgb2YgdGhlIHNlbGVjdCB0aGF0IGVtaXR0ZWQgdGhlIGV2ZW50LiAqL1xuICAgIHZhbHVlOiBhbnk7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgc2VsZWN0IHRoYXQgZW1pdHRlZCB0aGUgY2hhbmdlIGV2ZW50LiAqL1xuICAgIHNvdXJjZTogTHlTZWxlY3QsIFxuICAgIC8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBzZWxlY3QgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICB2YWx1ZTogYW55KTtcbn1cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBMeVNlbGVjdEJhc2Uge1xufVxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IEx5U2VsZWN0TWl4aW5CYXNlOiBpbXBvcnQoXCJAYWx5bGUvdWkvc3JjL2NvbW1vbi9jb25zdHJ1Y3RvclwiKS5Db25zdHJ1Y3RvcjxpbXBvcnQoXCJAYWx5bGUvdWkvYWx5bGUtdWlcIikuSGFzVGFiSW5kZXg+ICYgaW1wb3J0KFwiQGFseWxlL3VpL3NyYy9jb21tb24vY29uc3RydWN0b3JcIikuQ29uc3RydWN0b3I8aW1wb3J0KFwiQGFseWxlL3VpL2FseWxlLXVpXCIpLkNhbkRpc2FibGU+O1xuLyoqXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gY3VzdG9taXplIHRoZSB0cmlnZ2VyIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTHlTZWxlY3RUcmlnZ2VyIHtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5U2VsZWN0IGV4dGVuZHMgTHlTZWxlY3RNaXhpbkJhc2UgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTHlGaWVsZENvbnRyb2xCYXNlLCBPbkluaXQsIERvQ2hlY2ssIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfdGhlbWU7XG4gICAgcmVhZG9ubHkgc1JlbmRlcmVyOiBTdHlsZVJlbmRlcmVyO1xuICAgIHByaXZhdGUgX3JlbmRlcmVyO1xuICAgIHByaXZhdGUgX2VsO1xuICAgIHByaXZhdGUgX292ZXJsYXk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9maWVsZDogTHlGaWVsZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBwcml2YXRlIF9uZ1pvbmU7XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBuZ0NvbnRyb2w6IE5nQ29udHJvbDtcbiAgICBwcml2YXRlIF9wYXJlbnRGb3JtO1xuICAgIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDtcbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHJlYWRvbmx5IGNsYXNzZXM6IFBpY2s8e1xuICAgICAgICAkcHJpb3JpdHk6IHN0cmluZztcbiAgICAgICAgcm9vdDogc3RyaW5nO1xuICAgICAgICBjb250YWluZXI6IHN0cmluZztcbiAgICAgICAgdmFsdWVUZXh0OiBzdHJpbmc7XG4gICAgICAgIG9wdGlvbjogc3RyaW5nO1xuICAgICAgICBvcHRpb25BY3RpdmU6IHN0cmluZztcbiAgICAgICAgb3B0aW9uVGV4dDogc3RyaW5nO1xuICAgICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgfSwgXCJyb290XCIgfCBcImNvbnRhaW5lclwiIHwgXCJ2YWx1ZVRleHRcIiB8IFwib3B0aW9uXCIgfCBcIm9wdGlvbkFjdGl2ZVwiIHwgXCJvcHRpb25UZXh0XCIgfCBcImNvbnRlbnRcIj47XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZWxlY3Rpb25Nb2RlbDogU2VsZWN0aW9uTW9kZWw8THlPcHRpb24+O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdmFsdWU6IGFueTtcbiAgICAvKiogVGhlIGNhY2hlZCBmb250LXNpemUgb2YgdGhlIHRyaWdnZXIgZWxlbWVudC4gKi9cbiAgICBfdHJpZ2dlckZvbnRTaXplOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjtcbiAgICBwcm90ZWN0ZWQgX2Rpc2FibGVkOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBfcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9wbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHN0YXRlQ2hhbmdlczogU3ViamVjdDx2b2lkPjtcbiAgICBwcml2YXRlIF9oYXNEaXNhYmxlZENsYXNzPztcbiAgICBwcml2YXRlIF9lcnJvckNsYXNzPztcbiAgICBwcml2YXRlIF9mb3JtO1xuICAgIHByaXZhdGUgX211bHRpcGxlO1xuICAgIHByaXZhdGUgX29wZW5lZDtcbiAgICBwcml2YXRlIF92YWx1ZUtleTtcbiAgICBfZm9jdXNlZDogYm9vbGVhbjtcbiAgICBlcnJvclN0YXRlOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2N1cnNvckNsYXNzO1xuICAgIC8qKiBNYW5hZ2VzIGtleWJvYXJkIGV2ZW50cyBmb3Igb3B0aW9ucyBpbiB0aGUgcGFuZWwuICovXG4gICAgX2tleU1hbmFnZXI6IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPEx5T3B0aW9uPjtcbiAgICAvKiogRW1pdHMgd2hlbiB0aGUgcGFuZWwgZWxlbWVudCBpcyBmaW5pc2hlZCB0cmFuc2Zvcm1pbmcgaW4uICovXG4gICAgX3BhbmVsRG9uZUFuaW1hdGluZ1N0cmVhbTogU3ViamVjdDxzdHJpbmc+O1xuICAgIC8qKiBDb21wYXJpc29uIGZ1bmN0aW9uIHRvIHNwZWNpZnkgd2hpY2ggb3B0aW9uIGlzIGRpc3BsYXllZC4gRGVmYXVsdHMgdG8gb2JqZWN0IGVxdWFsaXR5LiAqL1xuICAgIHByaXZhdGUgX2NvbXBhcmVXaXRoO1xuICAgIC8qKiBFbWl0cyB3aGVuZXZlciB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC4gKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kZXN0cm95O1xuICAgIC8qKiBDb21iaW5lZCBzdHJlYW0gb2YgYWxsIG9mIHRoZSBjaGlsZCBvcHRpb25zJyBjaGFuZ2UgZXZlbnRzLiAqL1xuICAgIHJlYWRvbmx5IG9wdGlvblNlbGVjdGlvbkNoYW5nZXM6IE9ic2VydmFibGU8THlPcHRpb25TZWxlY3Rpb25DaGFuZ2U+O1xuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIHZhbHVlVGV4dERpdlJlZjogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD47XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vcHRpb25zOiBRdWVyeUxpc3Q8THlPcHRpb24+O1xuICAgIG9wdGlvbnM6IFF1ZXJ5TGlzdDxMeU9wdGlvbj47XG4gICAgY3VzdG9tVHJpZ2dlcjogTHlTZWxlY3RUcmlnZ2VyO1xuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBwYW5lbCBoYXMgYmVlbiB0b2dnbGVkLiAqL1xuICAgIHJlYWRvbmx5IG9wZW5lZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBvcGVuZWQuICovXG4gICAgcmVhZG9ubHkgX29wZW5lZFN0cmVhbTogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gY2xvc2VkLiAqL1xuICAgIHJlYWRvbmx5IF9jbG9zZWRTdHJlYW06IE9ic2VydmFibGU8dm9pZD47XG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCBieSB0aGUgdXNlci4gKi9cbiAgICByZWFkb25seSBzZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxMeVNlbGVjdENoYW5nZT47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzZWxlY3QgY2hhbmdlcy4gVGhpcyBpcyBoZXJlIHByaW1hcmlseVxuICAgICAqIHRvIGZhY2lsaXRhdGUgdGhlIHR3by13YXkgYmluZGluZyBmb3IgdGhlIGB2YWx1ZWAgaW5wdXQuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlYWRvbmx5IHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhIGNoYW5nZSBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICovXG4gICAgb25DaGFuZ2U6IChfOiBhbnkpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gYSBibHVyIGV2ZW50IG9jY3VycyBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBvblRvdWNoZWQ6ICgpID0+IHZvaWQ7XG4gICAgX29uRm9jdXMoKTogdm9pZDtcbiAgICBfb25CbHVyKCk6IHZvaWQ7XG4gICAgLyoqIFRpbWUgdG8gd2FpdCBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgdGhlIGxhc3Qga2V5c3Ryb2tlIGJlZm9yZSBtb3ZpbmcgZm9jdXMgdG8gYW4gaXRlbS4gKi9cbiAgICBnZXQgdHlwZWFoZWFkRGVib3VuY2VJbnRlcnZhbCgpOiBudW1iZXI7XG4gICAgc2V0IHR5cGVhaGVhZERlYm91bmNlSW50ZXJ2YWwodmFsdWU6IG51bWJlcik7XG4gICAgcHJpdmF0ZSBfdHlwZWFoZWFkRGVib3VuY2VJbnRlcnZhbDtcbiAgICAvKiogVmFsdWUgb2YgdGhlIHNlbGVjdCBjb250cm9sLiAqL1xuICAgIGdldCB2YWx1ZSgpOiBhbnk7XG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlOiBhbnkpO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZC4gKi9cbiAgICBzZXQgZGlzYWJsZWQodmFsOiBib29sZWFuKTtcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgcmVxdWlyZWQodmFsdWU6IGJvb2xlYW4pO1xuICAgIGdldCByZXF1aXJlZCgpOiBib29sZWFuO1xuICAgIHNldCBtdWx0aXBsZSh2YWx1ZTogYm9vbGVhbik7XG4gICAgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgY29tcGFyZVdpdGhgXG4gICAgICovXG4gICAgc2V0IHZhbHVlS2V5KGZuOiAob3B0OiB1bmtub3duKSA9PiB1bmtub3duKTtcbiAgICBnZXQgdmFsdWVLZXkoKTogKG9wdDogdW5rbm93bikgPT4gdW5rbm93bjtcbiAgICBzZXQgcGxhY2Vob2xkZXIodmFsOiBzdHJpbmcpO1xuICAgIGdldCBwbGFjZWhvbGRlcigpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY29tcGFyZSB0aGUgb3B0aW9uIHZhbHVlcyB3aXRoIHRoZSBzZWxlY3RlZCB2YWx1ZXMuIFRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIGlzIGEgdmFsdWUgZnJvbSBhbiBvcHRpb24uIFRoZSBzZWNvbmQgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3Rpb24uIEEgYm9vbGVhblxuICAgICAqIHNob3VsZCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFyZVdpdGgoKTogKG8xOiBhbnksIG8yOiBhbnkpID0+IGJvb2xlYW47XG4gICAgc2V0IGNvbXBhcmVXaXRoKGZuOiAobzE6IGFueSwgbzI6IGFueSkgPT4gYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzb3J0IHRoZSB2YWx1ZXMgaW4gYSBzZWxlY3QgaW4gbXVsdGlwbGUgbW9kZS5cbiAgICAgKiBGb2xsb3dzIHRoZSBzYW1lIGxvZ2ljIGFzIGBBcnJheS5wcm90b3R5cGUuc29ydGAuXG4gICAgICovXG4gICAgc29ydENvbXBhcmF0b3I6IChhOiBMeU9wdGlvbiwgYjogTHlPcHRpb24sIG9wdGlvbnM6IEx5T3B0aW9uW10pID0+IG51bWJlcjtcbiAgICBnZXQgZm9jdXNlZCgpOiBib29sZWFuO1xuICAgIGdldCBlbXB0eSgpOiBib29sZWFuO1xuICAgIGdldCBmbG9hdGluZ0xhYmVsKCk6IGJvb2xlYW47XG4gICAgLyoqIFRoZSB2YWx1ZSBkaXNwbGF5ZWQgaW4gdGhlIHRyaWdnZXIuICovXG4gICAgZ2V0IHRyaWdnZXJWYWx1ZSgpOiBzdHJpbmc7XG4gICAgLyoqIEN1cnJlbnQgc2VsZWN0ZWRzICovXG4gICAgZ2V0IHNlbGVjdGVkKCk6IEx5T3B0aW9uIHwgTHlPcHRpb25bXTtcbiAgICBjb25zdHJ1Y3RvcihfdGhlbWU6IEx5VGhlbWUyLCBzUmVuZGVyZXI6IFN0eWxlUmVuZGVyZXIsIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBfZWw6IEVsZW1lbnRSZWYsIF9vdmVybGF5OiBMeU92ZXJsYXksIFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmllbGQ6IEx5RmllbGQsIFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY2Q6IENoYW5nZURldGVjdG9yUmVmLCBfbmdab25lOiBOZ1pvbmUsIFxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgbmdDb250cm9sOiBOZ0NvbnRyb2wsIF9wYXJlbnRGb3JtOiBOZ0Zvcm0sIF9wYXJlbnRGb3JtR3JvdXA6IEZvcm1Hcm91cERpcmVjdGl2ZSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ0RvQ2hlY2soKTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIG9wZW4oKTogdm9pZDtcbiAgICBjbG9zZSgpOiB2b2lkO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgb25Db250YWluZXJDbGljaygpOiB2b2lkO1xuICAgIC8qKiBGb2N1c2VzIHRoZSBzZWxlY3QgZWxlbWVudC4gKi9cbiAgICBmb2N1cyhvcHRpb25zPzogRm9jdXNPcHRpb25zKTogdm9pZDtcbiAgICBfZ2V0SG9zdEVsZW1lbnQoKTogYW55O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgY2hlY2tlZCB2YWx1ZVxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IGFueSkgPT4gYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCBpcyB0b3VjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqIEhhbmRsZXMgYWxsIGtleWRvd24gZXZlbnRzIG9uIHRoZSBzZWxlY3QuICovXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKiBIYW5kbGVzIGtleWJvYXJkIGV2ZW50cyB3aGlsZSB0aGUgc2VsZWN0IGlzIGNsb3NlZC4gKi9cbiAgICBwcml2YXRlIF9oYW5kbGVDbG9zZWRLZXlkb3duO1xuICAgIC8qKiBIYW5kbGVzIGtleWJvYXJkIGV2ZW50cyB3aGVuIHRoZSBzZWxlY3RlZCBpcyBvcGVuLiAqL1xuICAgIHByaXZhdGUgX2hhbmRsZU9wZW5LZXlkb3duO1xuICAgIHByaXZhdGUgX2luaXRpYWxpemVTZWxlY3Rpb247XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGJhc2VkIG9uIGEgdmFsdWUuIElmIG5vIG9wdGlvbiBjYW4gYmVcbiAgICAgKiBmb3VuZCB3aXRoIHRoZSBkZXNpZ25hdGVkIHZhbHVlLCB0aGUgc2VsZWN0IHRyaWdnZXIgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9zZXRTZWxlY3Rpb25CeVZhbHVlO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCBzZWxlY3RzIGFuZCBvcHRpb24gYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIE9wdGlvbiB0aGF0IGhhcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9zZWxlY3RWYWx1ZTtcbiAgICBwcml2YXRlIF91cGRhdGVQbGFjZW1lbnQ7XG4gICAgLyoqIFNldHMgdXAgYSBrZXkgbWFuYWdlciB0byBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICAgIHByaXZhdGUgX2luaXRLZXlNYW5hZ2VyO1xuICAgIC8qKiBTb3J0cyB0aGUgc2VsZWN0ZWQgdmFsdWVzIGluIHRoZSBzZWxlY3RlZCBiYXNlZCBvbiB0aGVpciBvcmRlciBpbiB0aGUgcGFuZWwuICovXG4gICAgcHJpdmF0ZSBfc29ydFZhbHVlcztcbiAgICBwcml2YXRlIF9yZXNldE9wdGlvbnM7XG4gICAgLyoqIEludm9rZWQgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZC4gKi9cbiAgICBwcml2YXRlIF9vblNlbGVjdDtcbiAgICAvKiogRW1pdHMgY2hhbmdlIGV2ZW50IHRvIHNldCB0aGUgbW9kZWwgdmFsdWUuICovXG4gICAgcHJpdmF0ZSBfcHJvcGFnYXRlQ2hhbmdlcztcbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBzZWxlY3RlZCBpdGVtLiBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIGl0IHdpbGwgaGlnaGxpZ2h0XG4gICAgICogdGhlIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9oaWdobGlnaHRDb3JyZWN0T3B0aW9uO1xuICAgIC8qKiBTY3JvbGxzIHRoZSBhY3RpdmUgb3B0aW9uIGludG8gdmlldy4gKi9cbiAgICBwcml2YXRlIF9zY3JvbGxBY3RpdmVPcHRpb25JbnRvVmlldztcbn1cbi8qKiBFdmVudCBvYmplY3QgZW1pdHRlZCBieSBMeU9wdGlvbiB3aGVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBMeU9wdGlvblNlbGVjdGlvbkNoYW5nZSB7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9uIHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuICovXG4gICAgc291cmNlOiBMeU9wdGlvbjtcbiAgICAvKiogV2hldGhlciB0aGUgY2hhbmdlIGluIHRoZSBvcHRpb24ncyB2YWx1ZSB3YXMgYSByZXN1bHQgb2YgYSB1c2VyIGFjdGlvbi4gKi9cbiAgICBpc1VzZXJJbnB1dDogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBvcHRpb24gdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICBzb3VyY2U6IEx5T3B0aW9uLCBcbiAgICAvKiogV2hldGhlciB0aGUgY2hhbmdlIGluIHRoZSBvcHRpb24ncyB2YWx1ZSB3YXMgYSByZXN1bHQgb2YgYSB1c2VyIGFjdGlvbi4gKi9cbiAgICBpc1VzZXJJbnB1dD86IGJvb2xlYW4pO1xufVxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5T3B0aW9uQmFzZSB7XG4gICAgX3RoZW1lOiBMeVRoZW1lMjtcbiAgICBfbmdab25lOiBOZ1pvbmU7XG4gICAgX3BsYXRmb3JtOiBQbGF0Zm9ybTtcbiAgICBjb25zdHJ1Y3RvcihfdGhlbWU6IEx5VGhlbWUyLCBfbmdab25lOiBOZ1pvbmUsIF9wbGF0Zm9ybTogUGxhdGZvcm0pO1xufVxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IEx5T3B0aW9uTWl4aW5CYXNlOiBpbXBvcnQoXCJAYWx5bGUvdWkvc3JjL2NvbW1vbi9jb25zdHJ1Y3RvclwiKS5Db25zdHJ1Y3RvcjxpbXBvcnQoXCJAYWx5bGUvdWkvc3JjL2NvbW1vbi9kaXNhYmxlLXJpcHBsZVwiKS5DYW5EaXNhYmxlUmlwcGxlPiAmIHR5cGVvZiBMeU9wdGlvbkJhc2U7XG4vKipcbiAqIEBkeW5hbWljXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5T3B0aW9uIGV4dGVuZHMgTHlPcHRpb25NaXhpbkJhc2UgaW1wbGVtZW50cyBXaXRoU3R5bGVzLCBGb2N1c2FibGVPcHRpb24sIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgICByZWFkb25seSBzUmVuZGVyZXI6IFN0eWxlUmVuZGVyZXI7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHJlYWRvbmx5IF9zZWxlY3Q6IEx5U2VsZWN0O1xuICAgIHByaXZhdGUgX2VsO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmlwcGxlU2VydmljZTogTHlSaXBwbGVTZXJ2aWNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY2Q6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgcmVhZG9ubHkgY2xhc3NlczogUGljazx7XG4gICAgICAgICRwcmlvcml0eTogc3RyaW5nO1xuICAgICAgICByb290OiBzdHJpbmc7XG4gICAgICAgIGNvbnRhaW5lcjogc3RyaW5nO1xuICAgICAgICB2YWx1ZVRleHQ6IHN0cmluZztcbiAgICAgICAgb3B0aW9uOiBzdHJpbmc7XG4gICAgICAgIG9wdGlvbkFjdGl2ZTogc3RyaW5nO1xuICAgICAgICBvcHRpb25UZXh0OiBzdHJpbmc7XG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICB9LCBcInJvb3RcIiB8IFwiY29udGFpbmVyXCIgfCBcInZhbHVlVGV4dFwiIHwgXCJvcHRpb25cIiB8IFwib3B0aW9uQWN0aXZlXCIgfCBcIm9wdGlvblRleHRcIiB8IFwiY29udGVudFwiPjtcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIF9zZWxlY3RlZDtcbiAgICBwcml2YXRlIF9kaXNhYmxlZDtcbiAgICBfcmlwcGxlQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLiAqL1xuICAgIHJlYWRvbmx5IG9uU2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8THlPcHRpb25TZWxlY3Rpb25DaGFuZ2U+O1xuICAgIF9vbkNsaWNrKCk6IHZvaWQ7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvcHRpb24gaXMgY3VycmVudGx5IHNlbGVjdGVkLiAqL1xuICAgIGdldCBzZWxlY3RlZCgpOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIHRoZSB3cmFwcGluZyBjb21wb25lbnQgaXMgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuICovXG4gICAgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVHJhY2tzIHNpbXBsZSBzdHJpbmcgdmFsdWVzIGJvdW5kIHRvIHRoZSBvcHRpb24gZWxlbWVudC5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSk7XG4gICAgZ2V0IHZhbHVlKCk6IGFueTtcbiAgICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAqL1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogYW55KTtcbiAgICBnZXQgZGlzYWJsZWQoKTogYW55O1xuICAgIF9zZWxlY3RlZENvbG9yOiBzdHJpbmcgfCBudWxsO1xuICAgIC8qKiBUaGUgZGlzcGxheWVkIHZhbHVlIG9mIHRoZSBvcHRpb24uICovXG4gICAgZ2V0IHZpZXdWYWx1ZSgpOiBzdHJpbmc7XG4gICAgLyoqIFRoZSBjb2xvciBvZiBTZWxlY3Qgb3B0aW9uICovXG4gICAgZ2V0IF9jb2xvcigpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGluc3RlYWQgYHNlbGVjdGVkYFxuICAgICAqL1xuICAgIGdldCBpc1NlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3Ioc1JlbmRlcmVyOiBTdHlsZVJlbmRlcmVyLCBcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NlbGVjdDogTHlTZWxlY3QsIF9lbDogRWxlbWVudFJlZiwgXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yaXBwbGVTZXJ2aWNlOiBMeVJpcHBsZVNlcnZpY2UsIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBfdGhlbWU6IEx5VGhlbWUyLCBcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZiwgX25nWm9uZTogTmdab25lLCBwbGF0Zm9ybTogUGxhdGZvcm0pO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZDtcbiAgICAvKiogQXBwbGllcyB0aGUgc3R5bGVzIGZvciBhbiBhY3RpdmUgaXRlbSB0byB0aGlzIGl0ZW0uICovXG4gICAgc2V0QWN0aXZlU3R5bGVzKCk6IHZvaWQ7XG4gICAgLyoqIEFwcGxpZXMgdGhlIHN0eWxlcyBmb3IgYW4gaW5hY3RpdmUgaXRlbSB0byB0aGlzIGl0ZW0uICovXG4gICAgc2V0SW5hY3RpdmVTdHlsZXMoKTogdm9pZDtcbiAgICAvKiogR2V0cyB0aGUgbGFiZWwgdG8gYmUgdXNlZCB3aGVuIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIG9wdGlvbiBzaG91bGQgYmUgZm9jdXNlZC4gKi9cbiAgICBnZXRMYWJlbCgpOiBzdHJpbmc7XG4gICAgLyoqIFNlbGVjdHMgdGhlIG9wdGlvbi4gKi9cbiAgICBzZWxlY3QoKTogdm9pZDtcbiAgICAvKiogRGVzZWxlY3RzIHRoZSBvcHRpb24uICovXG4gICAgZGVzZWxlY3QoKTogdm9pZDtcbiAgICAvKiogU2V0cyBmb2N1cyBvbnRvIHRoaXMgb3B0aW9uLiAqL1xuICAgIGZvY3VzKF9vcmlnaW4/OiBGb2N1c09yaWdpbiwgb3B0aW9ucz86IEZvY3VzT3B0aW9ucyk6IHZvaWQ7XG4gICAgLyoqIEVuc3VyZXMgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCB3aGVuIGFjdGl2YXRlZCBmcm9tIHRoZSBrZXlib2FyZC4gKi9cbiAgICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogYFNlbGVjdHMgdGhlIG9wdGlvbiB3aGlsZSBpbmRpY2F0aW5nIHRoZSBzZWxlY3Rpb24gY2FtZSBmcm9tIHRoZSB1c2VyLiBVc2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QncyB2aWV3IC0+IG1vZGVsIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLmBcbiAgICAgKi9cbiAgICBfc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTogdm9pZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldEhvc3RFbGVtZW50KCk6IEhUTUxFbGVtZW50O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBjb3JyZWN0IHRhYmluZGV4IGZvciB0aGUgb3B0aW9uIGRlcGVuZGluZyBvbiBkaXNhYmxlZCBzdGF0ZS4gKi9cbiAgICBfZ2V0VGFiSW5kZXgoKTogc3RyaW5nO1xuICAgIC8qKiBFbWl0cyB0aGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudC4gKi9cbiAgICBwcml2YXRlIF9lbWl0U2VsZWN0aW9uQ2hhbmdlRXZlbnQ7XG59XG4iXX0=