import { ElementRef, Renderer2, OnInit, ChangeDetectorRef, EventEmitter, OnChanges, OnDestroy, QueryList, InjectionToken } from '@angular/core';
import { LyTheme2, ThemeVariables, HammerInput, StyleCollection, LyClasses, StyleTemplate, ThemeRef, StyleRenderer } from '@alyle/ui';
import { Color } from '@alyle/ui/color';
import { ControlValueAccessor } from '@angular/forms';
import { Subject } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export interface LySliderTheme {
    /** Styles for Slider Component */
    root?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
    disabled?: StyleCollection<((classes: LyClasses<typeof STYLES>, color: Color) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>, color: Color) => StyleTemplate);
    color?: StyleCollection<((classes: LyClasses<typeof STYLES>, color: Color) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>, color: Color) => StyleTemplate);
    appearance?: {
        standard?: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate);
        [key: string]: StyleCollection<((classes: LyClasses<typeof STYLES>) => StyleTemplate)> | ((classes: LyClasses<typeof STYLES>) => StyleTemplate) | undefined;
    };
}
export interface LySliderDefaultOptions {
    appearance?: string;
}
export declare const LY_SLIDER_DEFAULT_OPTIONS: InjectionToken<LySliderDefaultOptions>;
export interface LySliderVariables {
    slider?: LySliderTheme;
}
export declare const LY_SLIDER_CONTROL_VALUE_ACCESSOR: {
    provide: InjectionToken<ControlValueAccessor>;
    useExisting: import("@angular/core").Type<any>;
    multi: boolean;
};
export declare const STYLES: (theme: ThemeVariables & LySliderVariables, ref: ThemeRef) => {
    $priority: number;
    root: () => (className: string) => string;
    track: (className: string) => string;
    bg: any;
    thumbContainer: (className: string) => string;
    thumbContent: (className: string) => string;
    thumb: (className: string) => string;
    thumbLabel: (className: string) => string;
    thumbLabelValue: (className: string) => string;
    horizontal: () => (className: string) => string;
    vertical: () => (className: string) => string;
    marked: any;
    mark: (className: string) => string;
    markActive: (className: string) => string;
    tick: (className: string) => string;
    tickActive: any;
    thumbVisible: any;
    thumbNotVisible: any;
    thumbContentFocused: any;
    sliding: any;
    disabled: (className: string) => string;
};
/** A change event emitted by the LySlider component. */
export declare class LySliderChange {
    /** The LySlider that changed. */
    source: LySlider;
    /** The new value of the source slider. */
    value: number | (number | null)[] | null;
    constructor(
    /** The LySlider that changed. */
    source: LySlider, 
    /** The new value of the source slider. */
    value: number | (number | null)[] | null);
}
interface Thumb {
    value: number;
    displayValue: string | number | null;
    percent: number | null;
    styles: {
        [key: string]: string;
    };
    focused?: boolean;
    sliding?: boolean;
    index: number;
}
export interface LySliderMark {
    value: number;
    label: number | string;
}
export declare class LySlider implements OnChanges, OnInit, OnDestroy, ControlValueAccessor {
    private _theme;
    private _el;
    private _renderer;
    private _cd;
    readonly sRenderer: StyleRenderer;
    private _sr;
    private _default;
    /** Whether or not to show the thumb. */
    get thumbVisible(): boolean | null;
    set thumbVisible(val: boolean | null);
    /** Whether or not to show the marks, also accepts an array of marks. */
    get marks(): boolean | LySliderMark[];
    set marks(val: boolean | LySliderMark[]);
    /** The maximum value that the slider can have. */
    get max(): number;
    set max(v: number);
    /** The minimum value that the slider can have. */
    get min(): number;
    set min(v: number);
    /** The slider appearance style. */
    set appearance(val: string);
    get appearance(): string;
    /** Color of Slider */
    get color(): string;
    set color(val: string);
    /** Whether the slider is vertical. */
    get vertical(): boolean;
    set vertical(val: boolean);
    /** The values at which the thumb will snap. */
    get step(): number;
    set step(v: number);
    /**
     * Value of a slider, this can be a number or an array of numbers.
     * If the array of numbers has more than one value,
     * then this will create more thumbs
     */
    get value(): number | (number | null)[] | null;
    set value(val: number | (number | null)[] | null);
    /** Whether the slider is disabled. */
    get disabled(): boolean;
    set disabled(val: boolean);
    /**
     * Whether or not to show the thumb label, but if the value is a number,
     * it will show ticks according to the steps. For example: if you set
     * 3 ticks with a step of 10, you will draw a tick every 30 values
     */
    get ticks(): number | boolean;
    set ticks(val: number | boolean);
    get _tickList(): number[];
    constructor(_theme: LyTheme2, _el: ElementRef, _renderer: Renderer2, _cd: ChangeDetectorRef, sRenderer: StyleRenderer, _sr: StyleRenderer, _default: LySliderDefaultOptions);
    static и: string;
    readonly classes: Pick<{
        $priority: string;
        root: string;
        track: string;
        bg: string;
        thumbContainer: string;
        thumbContent: string;
        thumb: string;
        thumbLabel: string;
        thumbLabelValue: string;
        horizontal: string;
        vertical: string;
        marked: string;
        mark: string;
        markActive: string;
        tick: string;
        tickActive: string;
        thumbVisible: string;
        thumbNotVisible: string;
        thumbContentFocused: string;
        sliding: string;
        disabled: string;
    }, "root" | "track" | "bg" | "thumbContainer" | "thumbContent" | "thumb" | "thumbLabel" | "thumbLabelValue" | "horizontal" | "vertical" | "marked" | "mark" | "markActive" | "tick" | "tickActive" | "thumbVisible" | "thumbNotVisible" | "thumbContentFocused" | "sliding" | "disabled">;
    private _disabled;
    private _disabledClass;
    private _color;
    private _colorClass;
    private _vertical;
    private _verticalClass?;
    private _appearance;
    private _appearanceClass;
    private _value;
    private _thumbsOnSlideStart;
    private _valueOnSlideStart;
    private _min;
    private _max;
    private _step;
    private _stepPrecision?;
    private _closestIndex;
    private _currentRect;
    _changes: Subject<void>;
    /** Min percentage, this is for mark. */
    _minPercent: number;
    /** Max percentage, this is for mark. */
    _maxPercent: number;
    /**
     * Whether or not the thumb is sliding.
     */
    _isSliding: boolean;
    _slidingThumbValue?: number | null;
    _thumbs: Thumb[];
    _rootClasses: Set<string>;
    _bg?: ElementRef<HTMLDivElement>;
    _track: ElementRef<HTMLDivElement>;
    _ticksRef: ElementRef<HTMLDivElement>;
    _thumbsRef?: QueryList<ElementRef<HTMLDivElement>>;
    displayWith: (value: number | null) => string | number;
    /** Event emitted when the slider value has changed. */
    readonly change: EventEmitter<LySliderChange>;
    /** Event emitted when the slider thumb moves. */
    readonly input: EventEmitter<LySliderChange>;
    /** @docs-private */
    readonly valueChange: EventEmitter<number | (number | null)[] | null>;
    private _thumbVisible;
    private _marks;
    private _marksClass;
    _marksList?: LySliderMark[] | null;
    private _ticks;
    _tickInterval: number;
    private __tickList;
    /**
     * The registered callback function called when a blur event occurs on the input element.
     * @docs-private
     */
    onTouched: () => void;
    private _controlValueAccessorChangeFn;
    ngOnChanges(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    writeValue(value: any): void;
    /**
     * Registers a function called when the control value changes.
     *
     * @param fn The callback function
     */
    registerOnChange(fn: (value: any) => any): void;
    /**
     * Registers a function called when the control is touched.
     *
     * @param fn The callback function
     */
    registerOnTouched(fn: () => any): void;
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    setDisabledState(isDisabled: boolean): void;
    _onFocus(thumb: Thumb): void;
    _onBlur(thumb: Thumb): void;
    _onTap(event: HammerInput): void;
    _onSlide(event: HammerInput): void;
    private _startSlide;
    _onSlideEnd(): void;
    _trackByFn(_index: number, item: Thumb): number;
    private _updateValueFromPosition;
    private _updateThumbs;
    _calculatePosition(percent: number): {
        style: string;
        value: string;
    };
    private _updateTrack;
    /** Emits a change event. */
    private _emitChangeEvent;
    /** Emits an input event. */
    private _emitInputEvent;
    private _createChangeEvent;
    private _roundValueToStep;
    private _transformValue;
    _getHostElement(): any;
    private _updateTickValues;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LySlider, [null, null, null, null, null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<LySlider, "ly-slider", ["lySlider"], { "thumbVisible": "thumbVisible"; "marks": "marks"; "max": "max"; "min": "min"; "value": "value"; "appearance": "appearance"; "color": "color"; "vertical": "vertical"; "step": "step"; "disabled": "disabled"; "ticks": "ticks"; "displayWith": "displayWith"; }, { "change": "change"; "input": "input"; "valueChange": "valueChange"; }, never, ["ly-mark"]>;
}
export declare function гvalueToPercent(value: number, min: number, max: number): number;
export declare function гbetween(x: number, min: number, max: number): boolean;
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmQudHMiLCJzb3VyY2VzIjpbInNsaWRlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgT25Jbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTHlUaGVtZTIsIFRoZW1lVmFyaWFibGVzLCBIYW1tZXJJbnB1dCwgU3R5bGVDb2xsZWN0aW9uLCBMeUNsYXNzZXMsIFN0eWxlVGVtcGxhdGUsIFRoZW1lUmVmLCBTdHlsZVJlbmRlcmVyIH0gZnJvbSAnQGFseWxlL3VpJztcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnQGFseWxlL3VpL2NvbG9yJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IGludGVyZmFjZSBMeVNsaWRlclRoZW1lIHtcbiAgICAvKiogU3R5bGVzIGZvciBTbGlkZXIgQ29tcG9uZW50ICovXG4gICAgcm9vdD86IFN0eWxlQ29sbGVjdGlvbjwoKGNsYXNzZXM6IEx5Q2xhc3Nlczx0eXBlb2YgU1RZTEVTPikgPT4gU3R5bGVUZW1wbGF0ZSk+IHwgKChjbGFzc2VzOiBMeUNsYXNzZXM8dHlwZW9mIFNUWUxFUz4pID0+IFN0eWxlVGVtcGxhdGUpO1xuICAgIGRpc2FibGVkPzogU3R5bGVDb2xsZWN0aW9uPCgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+LCBjb2xvcjogQ29sb3IpID0+IFN0eWxlVGVtcGxhdGUpPiB8ICgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+LCBjb2xvcjogQ29sb3IpID0+IFN0eWxlVGVtcGxhdGUpO1xuICAgIGNvbG9yPzogU3R5bGVDb2xsZWN0aW9uPCgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+LCBjb2xvcjogQ29sb3IpID0+IFN0eWxlVGVtcGxhdGUpPiB8ICgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+LCBjb2xvcjogQ29sb3IpID0+IFN0eWxlVGVtcGxhdGUpO1xuICAgIGFwcGVhcmFuY2U/OiB7XG4gICAgICAgIHN0YW5kYXJkPzogU3R5bGVDb2xsZWN0aW9uPCgoY2xhc3NlczogTHlDbGFzc2VzPHR5cGVvZiBTVFlMRVM+KSA9PiBTdHlsZVRlbXBsYXRlKT4gfCAoKGNsYXNzZXM6IEx5Q2xhc3Nlczx0eXBlb2YgU1RZTEVTPikgPT4gU3R5bGVUZW1wbGF0ZSk7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IFN0eWxlQ29sbGVjdGlvbjwoKGNsYXNzZXM6IEx5Q2xhc3Nlczx0eXBlb2YgU1RZTEVTPikgPT4gU3R5bGVUZW1wbGF0ZSk+IHwgKChjbGFzc2VzOiBMeUNsYXNzZXM8dHlwZW9mIFNUWUxFUz4pID0+IFN0eWxlVGVtcGxhdGUpIHwgdW5kZWZpbmVkO1xuICAgIH07XG59XG5leHBvcnQgaW50ZXJmYWNlIEx5U2xpZGVyRGVmYXVsdE9wdGlvbnMge1xuICAgIGFwcGVhcmFuY2U/OiBzdHJpbmc7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBMWV9TTElERVJfREVGQVVMVF9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjxMeVNsaWRlckRlZmF1bHRPcHRpb25zPjtcbmV4cG9ydCBpbnRlcmZhY2UgTHlTbGlkZXJWYXJpYWJsZXMge1xuICAgIHNsaWRlcj86IEx5U2xpZGVyVGhlbWU7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBMWV9TTElERVJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjoge1xuICAgIHByb3ZpZGU6IEluamVjdGlvblRva2VuPENvbnRyb2xWYWx1ZUFjY2Vzc29yPjtcbiAgICB1c2VFeGlzdGluZzogaW1wb3J0KFwiQGFuZ3VsYXIvY29yZVwiKS5UeXBlPGFueT47XG4gICAgbXVsdGk6IGJvb2xlYW47XG59O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgU1RZTEVTOiAodGhlbWU6IFRoZW1lVmFyaWFibGVzICYgTHlTbGlkZXJWYXJpYWJsZXMsIHJlZjogVGhlbWVSZWYpID0+IHtcbiAgICAkcHJpb3JpdHk6IG51bWJlcjtcbiAgICByb290OiAoKSA9PiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICB0cmFjazogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgYmc6IGFueTtcbiAgICB0aHVtYkNvbnRhaW5lcjogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgdGh1bWJDb250ZW50OiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICB0aHVtYjogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgdGh1bWJMYWJlbDogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgdGh1bWJMYWJlbFZhbHVlOiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBob3Jpem9udGFsOiAoKSA9PiAoY2xhc3NOYW1lOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICB2ZXJ0aWNhbDogKCkgPT4gKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgbWFya2VkOiBhbnk7XG4gICAgbWFyazogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgbWFya0FjdGl2ZTogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgdGljazogKGNsYXNzTmFtZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgdGlja0FjdGl2ZTogYW55O1xuICAgIHRodW1iVmlzaWJsZTogYW55O1xuICAgIHRodW1iTm90VmlzaWJsZTogYW55O1xuICAgIHRodW1iQ29udGVudEZvY3VzZWQ6IGFueTtcbiAgICBzbGlkaW5nOiBhbnk7XG4gICAgZGlzYWJsZWQ6IChjbGFzc05hbWU6IHN0cmluZykgPT4gc3RyaW5nO1xufTtcbi8qKiBBIGNoYW5nZSBldmVudCBlbWl0dGVkIGJ5IHRoZSBMeVNsaWRlciBjb21wb25lbnQuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBMeVNsaWRlckNoYW5nZSB7XG4gICAgLyoqIFRoZSBMeVNsaWRlciB0aGF0IGNoYW5nZWQuICovXG4gICAgc291cmNlOiBMeVNsaWRlcjtcbiAgICAvKiogVGhlIG5ldyB2YWx1ZSBvZiB0aGUgc291cmNlIHNsaWRlci4gKi9cbiAgICB2YWx1ZTogbnVtYmVyIHwgKG51bWJlciB8IG51bGwpW10gfCBudWxsO1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgTHlTbGlkZXIgdGhhdCBjaGFuZ2VkLiAqL1xuICAgIHNvdXJjZTogTHlTbGlkZXIsIFxuICAgIC8qKiBUaGUgbmV3IHZhbHVlIG9mIHRoZSBzb3VyY2Ugc2xpZGVyLiAqL1xuICAgIHZhbHVlOiBudW1iZXIgfCAobnVtYmVyIHwgbnVsbClbXSB8IG51bGwpO1xufVxuaW50ZXJmYWNlIFRodW1iIHtcbiAgICB2YWx1ZTogbnVtYmVyO1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBwZXJjZW50OiBudW1iZXIgfCBudWxsO1xuICAgIHN0eWxlczoge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gICAgfTtcbiAgICBmb2N1c2VkPzogYm9vbGVhbjtcbiAgICBzbGlkaW5nPzogYm9vbGVhbjtcbiAgICBpbmRleDogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBMeVNsaWRlck1hcmsge1xuICAgIHZhbHVlOiBudW1iZXI7XG4gICAgbGFiZWw6IG51bWJlciB8IHN0cmluZztcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEx5U2xpZGVyIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHByaXZhdGUgX3RoZW1lO1xuICAgIHByaXZhdGUgX2VsO1xuICAgIHByaXZhdGUgX3JlbmRlcmVyO1xuICAgIHByaXZhdGUgX2NkO1xuICAgIHJlYWRvbmx5IHNSZW5kZXJlcjogU3R5bGVSZW5kZXJlcjtcbiAgICBwcml2YXRlIF9zcjtcbiAgICBwcml2YXRlIF9kZWZhdWx0O1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSB0aHVtYi4gKi9cbiAgICBnZXQgdGh1bWJWaXNpYmxlKCk6IGJvb2xlYW4gfCBudWxsO1xuICAgIHNldCB0aHVtYlZpc2libGUodmFsOiBib29sZWFuIHwgbnVsbCk7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIG1hcmtzLCBhbHNvIGFjY2VwdHMgYW4gYXJyYXkgb2YgbWFya3MuICovXG4gICAgZ2V0IG1hcmtzKCk6IGJvb2xlYW4gfCBMeVNsaWRlck1hcmtbXTtcbiAgICBzZXQgbWFya3ModmFsOiBib29sZWFuIHwgTHlTbGlkZXJNYXJrW10pO1xuICAgIC8qKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGF0IHRoZSBzbGlkZXIgY2FuIGhhdmUuICovXG4gICAgZ2V0IG1heCgpOiBudW1iZXI7XG4gICAgc2V0IG1heCh2OiBudW1iZXIpO1xuICAgIC8qKiBUaGUgbWluaW11bSB2YWx1ZSB0aGF0IHRoZSBzbGlkZXIgY2FuIGhhdmUuICovXG4gICAgZ2V0IG1pbigpOiBudW1iZXI7XG4gICAgc2V0IG1pbih2OiBudW1iZXIpO1xuICAgIC8qKiBUaGUgc2xpZGVyIGFwcGVhcmFuY2Ugc3R5bGUuICovXG4gICAgc2V0IGFwcGVhcmFuY2UodmFsOiBzdHJpbmcpO1xuICAgIGdldCBhcHBlYXJhbmNlKCk6IHN0cmluZztcbiAgICAvKiogQ29sb3Igb2YgU2xpZGVyICovXG4gICAgZ2V0IGNvbG9yKCk6IHN0cmluZztcbiAgICBzZXQgY29sb3IodmFsOiBzdHJpbmcpO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgdmVydGljYWwuICovXG4gICAgZ2V0IHZlcnRpY2FsKCk6IGJvb2xlYW47XG4gICAgc2V0IHZlcnRpY2FsKHZhbDogYm9vbGVhbik7XG4gICAgLyoqIFRoZSB2YWx1ZXMgYXQgd2hpY2ggdGhlIHRodW1iIHdpbGwgc25hcC4gKi9cbiAgICBnZXQgc3RlcCgpOiBudW1iZXI7XG4gICAgc2V0IHN0ZXAodjogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiBhIHNsaWRlciwgdGhpcyBjYW4gYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgKiBJZiB0aGUgYXJyYXkgb2YgbnVtYmVycyBoYXMgbW9yZSB0aGFuIG9uZSB2YWx1ZSxcbiAgICAgKiB0aGVuIHRoaXMgd2lsbCBjcmVhdGUgbW9yZSB0aHVtYnNcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHwgKG51bWJlciB8IG51bGwpW10gfCBudWxsO1xuICAgIHNldCB2YWx1ZSh2YWw6IG51bWJlciB8IChudW1iZXIgfCBudWxsKVtdIHwgbnVsbCk7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBkaXNhYmxlZC4gKi9cbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgZGlzYWJsZWQodmFsOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byBzaG93IHRoZSB0aHVtYiBsYWJlbCwgYnV0IGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlcixcbiAgICAgKiBpdCB3aWxsIHNob3cgdGlja3MgYWNjb3JkaW5nIHRvIHRoZSBzdGVwcy4gRm9yIGV4YW1wbGU6IGlmIHlvdSBzZXRcbiAgICAgKiAzIHRpY2tzIHdpdGggYSBzdGVwIG9mIDEwLCB5b3Ugd2lsbCBkcmF3IGEgdGljayBldmVyeSAzMCB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXQgdGlja3MoKTogbnVtYmVyIHwgYm9vbGVhbjtcbiAgICBzZXQgdGlja3ModmFsOiBudW1iZXIgfCBib29sZWFuKTtcbiAgICBnZXQgX3RpY2tMaXN0KCk6IG51bWJlcltdO1xuICAgIGNvbnN0cnVjdG9yKF90aGVtZTogTHlUaGVtZTIsIF9lbDogRWxlbWVudFJlZiwgX3JlbmRlcmVyOiBSZW5kZXJlcjIsIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYsIHNSZW5kZXJlcjogU3R5bGVSZW5kZXJlciwgX3NyOiBTdHlsZVJlbmRlcmVyLCBfZGVmYXVsdDogTHlTbGlkZXJEZWZhdWx0T3B0aW9ucyk7XG4gICAgc3RhdGljINC4OiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgY2xhc3NlczogUGljazx7XG4gICAgICAgICRwcmlvcml0eTogc3RyaW5nO1xuICAgICAgICByb290OiBzdHJpbmc7XG4gICAgICAgIHRyYWNrOiBzdHJpbmc7XG4gICAgICAgIGJnOiBzdHJpbmc7XG4gICAgICAgIHRodW1iQ29udGFpbmVyOiBzdHJpbmc7XG4gICAgICAgIHRodW1iQ29udGVudDogc3RyaW5nO1xuICAgICAgICB0aHVtYjogc3RyaW5nO1xuICAgICAgICB0aHVtYkxhYmVsOiBzdHJpbmc7XG4gICAgICAgIHRodW1iTGFiZWxWYWx1ZTogc3RyaW5nO1xuICAgICAgICBob3Jpem9udGFsOiBzdHJpbmc7XG4gICAgICAgIHZlcnRpY2FsOiBzdHJpbmc7XG4gICAgICAgIG1hcmtlZDogc3RyaW5nO1xuICAgICAgICBtYXJrOiBzdHJpbmc7XG4gICAgICAgIG1hcmtBY3RpdmU6IHN0cmluZztcbiAgICAgICAgdGljazogc3RyaW5nO1xuICAgICAgICB0aWNrQWN0aXZlOiBzdHJpbmc7XG4gICAgICAgIHRodW1iVmlzaWJsZTogc3RyaW5nO1xuICAgICAgICB0aHVtYk5vdFZpc2libGU6IHN0cmluZztcbiAgICAgICAgdGh1bWJDb250ZW50Rm9jdXNlZDogc3RyaW5nO1xuICAgICAgICBzbGlkaW5nOiBzdHJpbmc7XG4gICAgICAgIGRpc2FibGVkOiBzdHJpbmc7XG4gICAgfSwgXCJyb290XCIgfCBcInRyYWNrXCIgfCBcImJnXCIgfCBcInRodW1iQ29udGFpbmVyXCIgfCBcInRodW1iQ29udGVudFwiIHwgXCJ0aHVtYlwiIHwgXCJ0aHVtYkxhYmVsXCIgfCBcInRodW1iTGFiZWxWYWx1ZVwiIHwgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBcIm1hcmtlZFwiIHwgXCJtYXJrXCIgfCBcIm1hcmtBY3RpdmVcIiB8IFwidGlja1wiIHwgXCJ0aWNrQWN0aXZlXCIgfCBcInRodW1iVmlzaWJsZVwiIHwgXCJ0aHVtYk5vdFZpc2libGVcIiB8IFwidGh1bWJDb250ZW50Rm9jdXNlZFwiIHwgXCJzbGlkaW5nXCIgfCBcImRpc2FibGVkXCI+O1xuICAgIHByaXZhdGUgX2Rpc2FibGVkO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkQ2xhc3M7XG4gICAgcHJpdmF0ZSBfY29sb3I7XG4gICAgcHJpdmF0ZSBfY29sb3JDbGFzcztcbiAgICBwcml2YXRlIF92ZXJ0aWNhbDtcbiAgICBwcml2YXRlIF92ZXJ0aWNhbENsYXNzPztcbiAgICBwcml2YXRlIF9hcHBlYXJhbmNlO1xuICAgIHByaXZhdGUgX2FwcGVhcmFuY2VDbGFzcztcbiAgICBwcml2YXRlIF92YWx1ZTtcbiAgICBwcml2YXRlIF90aHVtYnNPblNsaWRlU3RhcnQ7XG4gICAgcHJpdmF0ZSBfdmFsdWVPblNsaWRlU3RhcnQ7XG4gICAgcHJpdmF0ZSBfbWluO1xuICAgIHByaXZhdGUgX21heDtcbiAgICBwcml2YXRlIF9zdGVwO1xuICAgIHByaXZhdGUgX3N0ZXBQcmVjaXNpb24/O1xuICAgIHByaXZhdGUgX2Nsb3Nlc3RJbmRleDtcbiAgICBwcml2YXRlIF9jdXJyZW50UmVjdDtcbiAgICBfY2hhbmdlczogU3ViamVjdDx2b2lkPjtcbiAgICAvKiogTWluIHBlcmNlbnRhZ2UsIHRoaXMgaXMgZm9yIG1hcmsuICovXG4gICAgX21pblBlcmNlbnQ6IG51bWJlcjtcbiAgICAvKiogTWF4IHBlcmNlbnRhZ2UsIHRoaXMgaXMgZm9yIG1hcmsuICovXG4gICAgX21heFBlcmNlbnQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdGh1bWIgaXMgc2xpZGluZy5cbiAgICAgKi9cbiAgICBfaXNTbGlkaW5nOiBib29sZWFuO1xuICAgIF9zbGlkaW5nVGh1bWJWYWx1ZT86IG51bWJlciB8IG51bGw7XG4gICAgX3RodW1iczogVGh1bWJbXTtcbiAgICBfcm9vdENsYXNzZXM6IFNldDxzdHJpbmc+O1xuICAgIF9iZz86IEVsZW1lbnRSZWY8SFRNTERpdkVsZW1lbnQ+O1xuICAgIF90cmFjazogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD47XG4gICAgX3RpY2tzUmVmOiBFbGVtZW50UmVmPEhUTUxEaXZFbGVtZW50PjtcbiAgICBfdGh1bWJzUmVmPzogUXVlcnlMaXN0PEVsZW1lbnRSZWY8SFRNTERpdkVsZW1lbnQ+PjtcbiAgICBkaXNwbGF5V2l0aDogKHZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiBzdHJpbmcgfCBudW1iZXI7XG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2xpZGVyIHZhbHVlIGhhcyBjaGFuZ2VkLiAqL1xuICAgIHJlYWRvbmx5IGNoYW5nZTogRXZlbnRFbWl0dGVyPEx5U2xpZGVyQ2hhbmdlPjtcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzbGlkZXIgdGh1bWIgbW92ZXMuICovXG4gICAgcmVhZG9ubHkgaW5wdXQ6IEV2ZW50RW1pdHRlcjxMeVNsaWRlckNoYW5nZT47XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICByZWFkb25seSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlciB8IChudW1iZXIgfCBudWxsKVtdIHwgbnVsbD47XG4gICAgcHJpdmF0ZSBfdGh1bWJWaXNpYmxlO1xuICAgIHByaXZhdGUgX21hcmtzO1xuICAgIHByaXZhdGUgX21hcmtzQ2xhc3M7XG4gICAgX21hcmtzTGlzdD86IEx5U2xpZGVyTWFya1tdIHwgbnVsbDtcbiAgICBwcml2YXRlIF90aWNrcztcbiAgICBfdGlja0ludGVydmFsOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfX3RpY2tMaXN0O1xuICAgIC8qKlxuICAgICAqIFRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgYmx1ciBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uVG91Y2hlZDogKCkgPT4gdm9pZDtcbiAgICBwcml2YXRlIF9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuO1xuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQ7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IGFueSkgPT4gYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCBpcyB0b3VjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgX29uRm9jdXModGh1bWI6IFRodW1iKTogdm9pZDtcbiAgICBfb25CbHVyKHRodW1iOiBUaHVtYik6IHZvaWQ7XG4gICAgX29uVGFwKGV2ZW50OiBIYW1tZXJJbnB1dCk6IHZvaWQ7XG4gICAgX29uU2xpZGUoZXZlbnQ6IEhhbW1lcklucHV0KTogdm9pZDtcbiAgICBwcml2YXRlIF9zdGFydFNsaWRlO1xuICAgIF9vblNsaWRlRW5kKCk6IHZvaWQ7XG4gICAgX3RyYWNrQnlGbihfaW5kZXg6IG51bWJlciwgaXRlbTogVGh1bWIpOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfdXBkYXRlVmFsdWVGcm9tUG9zaXRpb247XG4gICAgcHJpdmF0ZSBfdXBkYXRlVGh1bWJzO1xuICAgIF9jYWxjdWxhdGVQb3NpdGlvbihwZXJjZW50OiBudW1iZXIpOiB7XG4gICAgICAgIHN0eWxlOiBzdHJpbmc7XG4gICAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgfTtcbiAgICBwcml2YXRlIF91cGRhdGVUcmFjaztcbiAgICAvKiogRW1pdHMgYSBjaGFuZ2UgZXZlbnQuICovXG4gICAgcHJpdmF0ZSBfZW1pdENoYW5nZUV2ZW50O1xuICAgIC8qKiBFbWl0cyBhbiBpbnB1dCBldmVudC4gKi9cbiAgICBwcml2YXRlIF9lbWl0SW5wdXRFdmVudDtcbiAgICBwcml2YXRlIF9jcmVhdGVDaGFuZ2VFdmVudDtcbiAgICBwcml2YXRlIF9yb3VuZFZhbHVlVG9TdGVwO1xuICAgIHByaXZhdGUgX3RyYW5zZm9ybVZhbHVlO1xuICAgIF9nZXRIb3N0RWxlbWVudCgpOiBhbnk7XG4gICAgcHJpdmF0ZSBfdXBkYXRlVGlja1ZhbHVlcztcbn1cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uINCzdmFsdWVUb1BlcmNlbnQodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyO1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24g0LNiZXR3ZWVuKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogYm9vbGVhbjtcbmV4cG9ydCB7fTtcbiJdfQ==