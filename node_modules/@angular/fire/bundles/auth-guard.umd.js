(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/fire/auth'),exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser'), require('@angular/fire/auth')) :
    typeof define === 'function' && define.amd ? define(['@angular/core','@angular/common','@angular/fire/auth','exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/platform-browser', '@angular/fire/auth'], factory) :
    (factory(global.ng.core,global.ng.common,global.ng.fire.auth,(global.angularfire2 = global.angularfire2 || {}, global.angularfire2.auth_guard = {}),global.ng.common,global.ng.core,global.rxjs,global.rxjs.operators,global.ng.platformBrowser,global.angularfire2.auth));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports,common,core,rxjs,operators,platformBrowser,auth) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @license Angular v8.0.0
     * (c) 2010-2019 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Base for events the Router goes through, as opposed to events tied to a specific
     * Route. `RouterEvent`s will only be fired one time for any given navigation.
     *
     * Example:
     *
     * ```
     * class MyService {
     *   constructor(public router: Router, logger: Logger) {
     *     router.events.pipe(
     *       filter(e => e instanceof RouterEvent)
     *     ).subscribe(e => {
     *       logger.log(e.id, e.url);
     *     });
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var RouterEvent = /** @class */ (function () {
        function RouterEvent(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url) {
            this.id = id;
            this.url = url;
        }
        return RouterEvent;
    }());
    /**
     * @description
     *
     * Represents an event triggered when a navigation starts.
     *
     * @publicApi
     */
    var NavigationStart = /** @class */ (function (_super) {
        __extends(NavigationStart, _super);
        function NavigationStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        navigationTrigger, 
        /** @docsNotRequired */
        restoredState) {
            if (navigationTrigger === void 0) { navigationTrigger = 'imperative'; }
            if (restoredState === void 0) { restoredState = null; }
            var _this = _super.call(this, id, url) || this;
            _this.navigationTrigger = navigationTrigger;
            _this.restoredState = restoredState;
            return _this;
        }
        /** @docsNotRequired */
        NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
        return NavigationStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation ends successfully.
     *
     * @publicApi
     */
    var NavigationEnd = /** @class */ (function (_super) {
        __extends(NavigationEnd, _super);
        function NavigationEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            return _this;
        }
        /** @docsNotRequired */
        NavigationEnd.prototype.toString = function () {
            return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
        };
        return NavigationEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation is canceled.
     *
     * @publicApi
     */
    var NavigationCancel = /** @class */ (function (_super) {
        __extends(NavigationCancel, _super);
        function NavigationCancel(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        reason) {
            var _this = _super.call(this, id, url) || this;
            _this.reason = reason;
            return _this;
        }
        /** @docsNotRequired */
        NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
        return NavigationCancel;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when a navigation fails due to an unexpected error.
     *
     * @publicApi
     */
    var NavigationError = /** @class */ (function (_super) {
        __extends(NavigationError, _super);
        function NavigationError(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        error) {
            var _this = _super.call(this, id, url) || this;
            _this.error = error;
            return _this;
        }
        /** @docsNotRequired */
        NavigationError.prototype.toString = function () {
            return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
        };
        return NavigationError;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered when routes are recognized.
     *
     * @publicApi
     */
    var RoutesRecognized = /** @class */ (function (_super) {
        __extends(RoutesRecognized, _super);
        function RoutesRecognized(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        /** @docsNotRequired */
        RoutesRecognized.prototype.toString = function () {
            return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return RoutesRecognized;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the start of the Guard phase of routing.
     *
     * @publicApi
     */
    var GuardsCheckStart = /** @class */ (function (_super) {
        __extends(GuardsCheckStart, _super);
        function GuardsCheckStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        GuardsCheckStart.prototype.toString = function () {
            return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return GuardsCheckStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the end of the Guard phase of routing.
     *
     * @publicApi
     */
    var GuardsCheckEnd = /** @class */ (function (_super) {
        __extends(GuardsCheckEnd, _super);
        function GuardsCheckEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state, 
        /** @docsNotRequired */
        shouldActivate) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            _this.shouldActivate = shouldActivate;
            return _this;
        }
        GuardsCheckEnd.prototype.toString = function () {
            return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";
        };
        return GuardsCheckEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the start of the Resolve phase of routing. The timing of this
     * event may change, thus it's experimental. In the current iteration it will run
     * in the "resolve" phase whether there's things to resolve or not. In the future this
     * behavior may change to only run when there are things to be resolved.
     *
     * @publicApi
     */
    var ResolveStart = /** @class */ (function (_super) {
        __extends(ResolveStart, _super);
        function ResolveStart(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        ResolveStart.prototype.toString = function () {
            return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return ResolveStart;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents the end of the Resolve phase of routing. See note on
     * `ResolveStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ResolveEnd = /** @class */ (function (_super) {
        __extends(ResolveEnd, _super);
        function ResolveEnd(
        /** @docsNotRequired */
        id, 
        /** @docsNotRequired */
        url, 
        /** @docsNotRequired */
        urlAfterRedirects, 
        /** @docsNotRequired */
        state) {
            var _this = _super.call(this, id, url) || this;
            _this.urlAfterRedirects = urlAfterRedirects;
            _this.state = state;
            return _this;
        }
        ResolveEnd.prototype.toString = function () {
            return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
        };
        return ResolveEnd;
    }(RouterEvent));
    /**
     * @description
     *
     * Represents an event triggered before lazy loading a route config.
     *
     * @publicApi
     */
    var RouteConfigLoadStart = /** @class */ (function () {
        function RouteConfigLoadStart(
        /** @docsNotRequired */
        route) {
            this.route = route;
        }
        RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };
        return RouteConfigLoadStart;
    }());
    /**
     * @description
     *
     * Represents an event triggered when a route has been lazy loaded.
     *
     * @publicApi
     */
    var RouteConfigLoadEnd = /** @class */ (function () {
        function RouteConfigLoadEnd(
        /** @docsNotRequired */
        route) {
            this.route = route;
        }
        RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };
        return RouteConfigLoadEnd;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ChildActivationEnd` for use of this experimental API.
     *
     * @publicApi
     */
    var ChildActivationStart = /** @class */ (function () {
        function ChildActivationStart(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ChildActivationStart.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ChildActivationStart(path: '" + path + "')";
        };
        return ChildActivationStart;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ChildActivationStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ChildActivationEnd = /** @class */ (function () {
        function ChildActivationEnd(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ChildActivationEnd.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ChildActivationEnd(path: '" + path + "')";
        };
        return ChildActivationEnd;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ActivationEnd` for use of this experimental API.
     *
     * @publicApi
     */
    var ActivationStart = /** @class */ (function () {
        function ActivationStart(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ActivationStart.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ActivationStart(path: '" + path + "')";
        };
        return ActivationStart;
    }());
    /**
     * @description
     *
     * Represents the start of end of the Resolve phase of routing. See note on
     * `ActivationStart` for use of this experimental API.
     *
     * @publicApi
     */
    var ActivationEnd = /** @class */ (function () {
        function ActivationEnd(
        /** @docsNotRequired */
        snapshot) {
            this.snapshot = snapshot;
        }
        ActivationEnd.prototype.toString = function () {
            var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
            return "ActivationEnd(path: '" + path + "')";
        };
        return ActivationEnd;
    }());
    /**
     * @description
     *
     * Represents a scrolling event.
     *
     * @publicApi
     */
    var Scroll = /** @class */ (function () {
        function Scroll(
        /** @docsNotRequired */
        routerEvent, 
        /** @docsNotRequired */
        position, 
        /** @docsNotRequired */
        anchor) {
            this.routerEvent = routerEvent;
            this.position = position;
            this.anchor = anchor;
        }
        Scroll.prototype.toString = function () {
            var pos = this.position ? this.position[0] + ", " + this.position[1] : null;
            return "Scroll(anchor: '" + this.anchor + "', position: '" + pos + "')";
        };
        return Scroll;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This component is used internally within the router to be a placeholder when an empty
     * router-outlet is needed. For example, with a config such as:
     *
     * `{path: 'parent', outlet: 'nav', children: [...]}`
     *
     * In order to render, there needs to be a component on this config, which will default
     * to this `EmptyOutletComponent`.
     */
    var ɵEmptyOutletComponent = /** @class */ (function () {
        function ɵEmptyOutletComponent() {
        }
ɵEmptyOutletComponent.ɵfac = function ɵEmptyOutletComponent_Factory(t) { return new (t || ɵEmptyOutletComponent)(); };
ɵEmptyOutletComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ɵEmptyOutletComponent, selectors: [["ng-component"]], decls: 1, vars: 0, template: function ɵEmptyOutletComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "router-outlet");
    } }, directives: function () { return [RouterOutlet]; }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ɵEmptyOutletComponent, [{
        type: core.Component,
        args: [{ template: "<router-outlet></router-outlet>" }]
    }], function () { return []; }, null); })();
        return ɵEmptyOutletComponent;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Name of the primary outlet.
     *
     * @publicApi
     */
    var PRIMARY_OUTLET = 'primary';
    var ParamsAsMap = /** @class */ (function () {
        function ParamsAsMap(params) {
            this.params = params || {};
        }
        ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };
        ParamsAsMap.prototype.get = function (name) {
            if (this.has(name)) {
                var v = this.params[name];
                return Array.isArray(v) ? v[0] : v;
            }
            return null;
        };
        ParamsAsMap.prototype.getAll = function (name) {
            if (this.has(name)) {
                var v = this.params[name];
                return Array.isArray(v) ? v : [v];
            }
            return [];
        };
        Object.defineProperty(ParamsAsMap.prototype, "keys", {
            get: function () { return Object.keys(this.params); },
            enumerable: true,
            configurable: true
        });
        return ParamsAsMap;
    }());
    /**
     * Convert a `Params` instance to a `ParamMap`.
     *
     * @publicApi
     */
    function convertToParamMap(params) {
        return new ParamsAsMap(params);
    }
    var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
    function navigationCancelingError(message) {
        var error = Error('NavigationCancelingError: ' + message);
        error[NAVIGATION_CANCELING_ERROR] = true;
        return error;
    }
    function isNavigationCancelingError(error) {
        return error && error[NAVIGATION_CANCELING_ERROR];
    }
    // Matches the route configuration (`route`) against the actual URL (`segments`).
    function defaultUrlMatcher(segments, segmentGroup, route) {
        var parts = route.path.split('/');
        if (parts.length > segments.length) {
            // The actual URL is shorter than the config, no match
            return null;
        }
        if (route.pathMatch === 'full' &&
            (segmentGroup.hasChildren() || parts.length < segments.length)) {
            // The config is longer than the actual URL but we are looking for a full match, return null
            return null;
        }
        var posParams = {};
        // Check each config part against the actual URL
        for (var index = 0; index < parts.length; index++) {
            var part = parts[index];
            var segment = segments[index];
            var isParameter = part.startsWith(':');
            if (isParameter) {
                posParams[part.substring(1)] = segment;
            }
            else if (part !== segment.path) {
                // The actual URL part does not match the config, no match
                return null;
            }
        }
        return { consumed: segments.slice(0, parts.length), posParams: posParams };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LoadedRouterConfig = /** @class */ (function () {
        function LoadedRouterConfig(routes, module) {
            this.routes = routes;
            this.module = module;
        }
        return LoadedRouterConfig;
    }());
    function validateConfig(config, parentPath) {
        if (parentPath === void 0) { parentPath = ''; }
        // forEach doesn't iterate undefined values
        for (var i = 0; i < config.length; i++) {
            var route = config[i];
            var fullPath = getFullPath(parentPath, route);
            validateNode(route, fullPath);
        }
    }
    function validateNode(route, fullPath) {
        if (!route) {
            throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
        }
        if (Array.isArray(route)) {
            throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
        }
        if (!route.component && !route.children && !route.loadChildren &&
            (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
            throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route without children or loadChildren cannot have a named outlet set");
        }
        if (route.redirectTo && route.children) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
        }
        if (route.redirectTo && route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
        }
        if (route.children && route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
        }
        if (route.redirectTo && route.component) {
            throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
        }
        if (route.path && route.matcher) {
            throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
        }
        if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
            throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
        }
        if (route.path === void 0 && route.matcher === void 0) {
            throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
        }
        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
            throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
        }
        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
            var exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
            throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
        }
        if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
            throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
        }
        if (route.children) {
            validateConfig(route.children, fullPath);
        }
    }
    function getFullPath(parentPath, currentRoute) {
        if (!currentRoute) {
            return parentPath;
        }
        if (!parentPath && !currentRoute.path) {
            return '';
        }
        else if (parentPath && !currentRoute.path) {
            return parentPath + "/";
        }
        else if (!parentPath && currentRoute.path) {
            return currentRoute.path;
        }
        else {
            return parentPath + "/" + currentRoute.path;
        }
    }
    /**
     * Makes a copy of the config and adds any default required properties.
     */
    function standardizeConfig(r) {
        var children = r.children && r.children.map(standardizeConfig);
        var c = children ? __assign({}, r, { children: children }) : __assign({}, r);
        if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
            c.component = ɵEmptyOutletComponent;
        }
        return c;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function shallowEqualArrays(a, b) {
        if (a.length !== b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (!shallowEqual(a[i], b[i]))
                return false;
        }
        return true;
    }
    function shallowEqual(a, b) {
        // Casting Object.keys return values to include `undefined` as there are some cases
        // in IE 11 where this can happen. Cannot provide a test because the behavior only
        // exists in certain circumstances in IE 11, therefore doing this cast ensures the
        // logic is correct for when this edge case is hit.
        var k1 = Object.keys(a);
        var k2 = Object.keys(b);
        if (!k1 || !k2 || k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (a[key] !== b[key]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Flattens single-level nested arrays.
     */
    function flatten(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    /**
     * Return the last element of an array.
     */
    function last(a) {
        return a.length > 0 ? a[a.length - 1] : null;
    }
    function forEach(map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    }
    function waitForMap(obj, fn) {
        if (Object.keys(obj).length === 0) {
            return rxjs.of({});
        }
        var waitHead = [];
        var waitTail = [];
        var res = {};
        forEach(obj, function (a, k) {
            var mapped = fn(k, a).pipe(operators.map(function (r) { return res[k] = r; }));
            if (k === PRIMARY_OUTLET) {
                waitHead.push(mapped);
            }
            else {
                waitTail.push(mapped);
            }
        });
        // Closure compiler has problem with using spread operator here. So just using Array.concat.
        return rxjs.of.apply(null, waitHead.concat(waitTail)).pipe(operators.concatAll(), operators.last(), operators.map(function () { return res; }));
    }
    function wrapIntoObservable(value) {
        if (core.ɵisObservable(value)) {
            return value;
        }
        if (core.ɵisPromise(value)) {
            // Use `Promise.resolve()` to wrap promise-like instances.
            // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
            // change detection.
            return rxjs.from(Promise.resolve(value));
        }
        return rxjs.of(value);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createEmptyUrlTree() {
        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
    }
    function containsTree(container, containee, exact) {
        if (exact) {
            return equalQueryParams(container.queryParams, containee.queryParams) &&
                equalSegmentGroups(container.root, containee.root);
        }
        return containsQueryParams(container.queryParams, containee.queryParams) &&
            containsSegmentGroup(container.root, containee.root);
    }
    function equalQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return shallowEqual(container, containee);
    }
    function equalSegmentGroups(container, containee) {
        if (!equalPath(container.segments, containee.segments))
            return false;
        if (container.numberOfChildren !== containee.numberOfChildren)
            return false;
        for (var c in containee.children) {
            if (!container.children[c])
                return false;
            if (!equalSegmentGroups(container.children[c], containee.children[c]))
                return false;
        }
        return true;
    }
    function containsQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return Object.keys(containee).length <= Object.keys(container).length &&
            Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
    }
    function containsSegmentGroup(container, containee) {
        return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    function containsSegmentGroupHelper(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths))
                return false;
            if (containee.hasChildren())
                return false;
            return true;
        }
        else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths))
                return false;
            for (var c in containee.children) {
                if (!container.children[c])
                    return false;
                if (!containsSegmentGroup(container.children[c], containee.children[c]))
                    return false;
            }
            return true;
        }
        else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current))
                return false;
            if (!container.children[PRIMARY_OUTLET])
                return false;
            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
        }
    }
    /**
     * @description
     *
     * Represents the parsed URL.
     *
     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
     * serialized tree.
     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree =
     *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
     *     const f = tree.fragment; // return 'fragment'
     *     const q = tree.queryParams; // returns {debug: 'true'}
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
     *     g.children['support'].segments; // return 1 segment 'help'
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var UrlTree = /** @class */ (function () {
        /** @internal */
        function UrlTree(
        /** The root segment group of the URL tree */
        root, 
        /** The query params of the URL */
        queryParams, 
        /** The fragment of the URL */
        fragment) {
            this.root = root;
            this.queryParams = queryParams;
            this.fragment = fragment;
        }
        Object.defineProperty(UrlTree.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };
        return UrlTree;
    }());
    /**
     * @description
     *
     * Represents the parsed URL segment group.
     *
     * See `UrlTree` for more information.
     *
     * @publicApi
     */
    var UrlSegmentGroup = /** @class */ (function () {
        function UrlSegmentGroup(
        /** The URL segments of this group. See `UrlSegment` for more information */
        segments, 
        /** The list of children of this group */
        children) {
            var _this = this;
            this.segments = segments;
            this.children = children;
            /** The parent node in the url tree */
            this.parent = null;
            forEach(children, function (v, k) { return v.parent = _this; });
        }
        /** Whether the segment has child segments */
        UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
        Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
            /** Number of child segments */
            get: function () { return Object.keys(this.children).length; },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
        return UrlSegmentGroup;
    }());
    /**
     * @description
     *
     * Represents a single URL segment.
     *
     * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
     * parameters associated with the segment.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree = router.parseUrl('/team;id=33');
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments;
     *     s[0].path; // returns 'team'
     *     s[0].parameters; // returns {id: 33}
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var UrlSegment = /** @class */ (function () {
        function UrlSegment(
        /** The path part of a URL segment */
        path, 
        /** The matrix parameters associated with a segment */
        parameters) {
            this.path = path;
            this.parameters = parameters;
        }
        Object.defineProperty(UrlSegment.prototype, "parameterMap", {
            get: function () {
                if (!this._parameterMap) {
                    this._parameterMap = convertToParamMap(this.parameters);
                }
                return this._parameterMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegment.prototype.toString = function () { return serializePath(this); };
        return UrlSegment;
    }());
    function equalSegments(as, bs) {
        return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });
    }
    function equalPath(as, bs) {
        if (as.length !== bs.length)
            return false;
        return as.every(function (a, i) { return a.path === bs[i].path; });
    }
    function mapChildrenIntoArray(segment, fn) {
        var res = [];
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet === PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet !== PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        return res;
    }
    /**
     * @description
     *
     * Serializes and deserializes a URL string into a URL tree.
     *
     * The url serialization strategy is customizable. You can
     * make all URLs case insensitive by providing a custom UrlSerializer.
     *
     * See `DefaultUrlSerializer` for an example of a URL serializer.
     *
     * @publicApi
     */
    var UrlSerializer = /** @class */ (function () {
        function UrlSerializer() {
        }
        return UrlSerializer;
    }());
    /**
     * @description
     *
     * A default implementation of the `UrlSerializer`.
     *
     * Example URLs:
     *
     * ```
     * /inbox/33(popup:compose)
     * /inbox/33;open=true/messages/44
     * ```
     *
     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
     * specify route specific parameters.
     *
     * @publicApi
     */
    var DefaultUrlSerializer = /** @class */ (function () {
        function DefaultUrlSerializer() {
        }
        /** Parses a url into a `UrlTree` */
        DefaultUrlSerializer.prototype.parse = function (url) {
            var p = new UrlParser(url);
            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
        };
        /** Converts a `UrlTree` into a url */
        DefaultUrlSerializer.prototype.serialize = function (tree) {
            var segment = "/" + serializeSegment(tree.root, true);
            var query = serializeQueryParams(tree.queryParams);
            var fragment = typeof tree.fragment === "string" ? "#" + encodeUriFragment(tree.fragment) : '';
            return "" + segment + query + fragment;
        };
        return DefaultUrlSerializer;
    }());
    var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    function serializePaths(segment) {
        return segment.segments.map(function (p) { return serializePath(p); }).join('/');
    }
    function serializeSegment(segment, root) {
        if (!segment.hasChildren()) {
            return serializePaths(segment);
        }
        if (root) {
            var primary = segment.children[PRIMARY_OUTLET] ?
                serializeSegment(segment.children[PRIMARY_OUTLET], false) :
                '';
            var children_1 = [];
            forEach(segment.children, function (v, k) {
                if (k !== PRIMARY_OUTLET) {
                    children_1.push(k + ":" + serializeSegment(v, false));
                }
            });
            return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
        }
        else {
            var children = mapChildrenIntoArray(segment, function (v, k) {
                if (k === PRIMARY_OUTLET) {
                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
                }
                return [k + ":" + serializeSegment(v, false)];
            });
            return serializePaths(segment) + "/(" + children.join('//') + ")";
        }
    }
    /**
     * Encodes a URI string with the default encoding. This function will only ever be called from
     * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need
     * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't
     * have to be encoded per https://url.spec.whatwg.org.
     */
    function encodeUriString(s) {
        return encodeURIComponent(s)
            .replace(/%40/g, '@')
            .replace(/%3A/gi, ':')
            .replace(/%24/g, '$')
            .replace(/%2C/gi, ',');
    }
    /**
     * This function should be used to encode both keys and values in a query string key/value. In
     * the following URL, you need to call encodeUriQuery on "k" and "v":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriQuery(s) {
        return encodeUriString(s).replace(/%3B/gi, ';');
    }
    /**
     * This function should be used to encode a URL fragment. In the following URL, you need to call
     * encodeUriFragment on "f":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriFragment(s) {
        return encodeURI(s);
    }
    /**
     * This function should be run on any URI segment as well as the key and value in a key/value
     * pair for matrix params. In the following URL, you need to call encodeUriSegment on "html",
     * "mk", and "mv":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    function encodeUriSegment(s) {
        return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
    }
    function decode(s) {
        return decodeURIComponent(s);
    }
    // Query keys/values should have the "+" replaced first, as "+" in a query string is " ".
    // decodeURIComponent function will not decode "+" as a space.
    function decodeQuery(s) {
        return decode(s.replace(/\+/g, '%20'));
    }
    function serializePath(path) {
        return "" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);
    }
    function serializeMatrixParams(params) {
        return Object.keys(params)
            .map(function (key) { return ";" + encodeUriSegment(key) + "=" + encodeUriSegment(params[key]); })
            .join('');
    }
    function serializeQueryParams(params) {
        var strParams = Object.keys(params).map(function (name) {
            var value = params[name];
            return Array.isArray(value) ?
                value.map(function (v) { return encodeUriQuery(name) + "=" + encodeUriQuery(v); }).join('&') :
                encodeUriQuery(name) + "=" + encodeUriQuery(value);
        });
        return strParams.length ? "?" + strParams.join("&") : '';
    }
    var SEGMENT_RE = /^[^\/()?;=#]+/;
    function matchSegments(str) {
        var match = str.match(SEGMENT_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_RE = /^[^=?&#]+/;
    // Return the name of the query param at the start of the string or an empty string
    function matchQueryParams(str) {
        var match = str.match(QUERY_PARAM_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
    // Return the value of the query param at the start of the string or an empty string
    function matchUrlQueryParamValue(str) {
        var match = str.match(QUERY_PARAM_VALUE_RE);
        return match ? match[0] : '';
    }
    var UrlParser = /** @class */ (function () {
        function UrlParser(url) {
            this.url = url;
            this.remaining = url;
        }
        UrlParser.prototype.parseRootSegment = function () {
            this.consumeOptional('/');
            if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
                return new UrlSegmentGroup([], {});
            }
            // The root segment group never has segments
            return new UrlSegmentGroup([], this.parseChildren());
        };
        UrlParser.prototype.parseQueryParams = function () {
            var params = {};
            if (this.consumeOptional('?')) {
                do {
                    this.parseQueryParam(params);
                } while (this.consumeOptional('&'));
            }
            return params;
        };
        UrlParser.prototype.parseFragment = function () {
            return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
        };
        UrlParser.prototype.parseChildren = function () {
            if (this.remaining === '') {
                return {};
            }
            this.consumeOptional('/');
            var segments = [];
            if (!this.peekStartsWith('(')) {
                segments.push(this.parseSegment());
            }
            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
                this.capture('/');
                segments.push(this.parseSegment());
            }
            var children = {};
            if (this.peekStartsWith('/(')) {
                this.capture('/');
                children = this.parseParens(true);
            }
            var res = {};
            if (this.peekStartsWith('(')) {
                res = this.parseParens(false);
            }
            if (segments.length > 0 || Object.keys(children).length > 0) {
                res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
            }
            return res;
        };
        // parse a segment with its matrix parameters
        // ie `name;k1=v1;k2`
        UrlParser.prototype.parseSegment = function () {
            var path = matchSegments(this.remaining);
            if (path === '' && this.peekStartsWith(';')) {
                throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
            }
            this.capture(path);
            return new UrlSegment(decode(path), this.parseMatrixParams());
        };
        UrlParser.prototype.parseMatrixParams = function () {
            var params = {};
            while (this.consumeOptional(';')) {
                this.parseParam(params);
            }
            return params;
        };
        UrlParser.prototype.parseParam = function (params) {
            var key = matchSegments(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchSegments(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            params[decode(key)] = decode(value);
        };
        // Parse a single query parameter `name[=value]`
        UrlParser.prototype.parseQueryParam = function (params) {
            var key = matchQueryParams(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchUrlQueryParamValue(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            var decodedKey = decodeQuery(key);
            var decodedVal = decodeQuery(value);
            if (params.hasOwnProperty(decodedKey)) {
                // Append to existing values
                var currentVal = params[decodedKey];
                if (!Array.isArray(currentVal)) {
                    currentVal = [currentVal];
                    params[decodedKey] = currentVal;
                }
                currentVal.push(decodedVal);
            }
            else {
                // Create a new value
                params[decodedKey] = decodedVal;
            }
        };
        // parse `(a/b//outlet_name:c/d)`
        UrlParser.prototype.parseParens = function (allowPrimary) {
            var segments = {};
            this.capture('(');
            while (!this.consumeOptional(')') && this.remaining.length > 0) {
                var path = matchSegments(this.remaining);
                var next = this.remaining[path.length];
                // if is is not one of these characters, then the segment was unescaped
                // or the group was not closed
                if (next !== '/' && next !== ')' && next !== ';') {
                    throw new Error("Cannot parse url '" + this.url + "'");
                }
                var outletName = undefined;
                if (path.indexOf(':') > -1) {
                    outletName = path.substr(0, path.indexOf(':'));
                    this.capture(outletName);
                    this.capture(':');
                }
                else if (allowPrimary) {
                    outletName = PRIMARY_OUTLET;
                }
                var children = this.parseChildren();
                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
                    new UrlSegmentGroup([], children);
                this.consumeOptional('//');
            }
            return segments;
        };
        UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
        // Consumes the prefix when it is present and returns whether it has been consumed
        UrlParser.prototype.consumeOptional = function (str) {
            if (this.peekStartsWith(str)) {
                this.remaining = this.remaining.substring(str.length);
                return true;
            }
            return false;
        };
        UrlParser.prototype.capture = function (str) {
            if (!this.consumeOptional(str)) {
                throw new Error("Expected \"" + str + "\".");
            }
        };
        return UrlParser;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var Tree = /** @class */ (function () {
        function Tree(root) {
            this._root = root;
        }
        Object.defineProperty(Tree.prototype, "root", {
            get: function () { return this._root.value; },
            enumerable: true,
            configurable: true
        });
        /**
         * @internal
         */
        Tree.prototype.parent = function (t) {
            var p = this.pathFromRoot(t);
            return p.length > 1 ? p[p.length - 2] : null;
        };
        /**
         * @internal
         */
        Tree.prototype.children = function (t) {
            var n = findNode(t, this._root);
            return n ? n.children.map(function (t) { return t.value; }) : [];
        };
        /**
         * @internal
         */
        Tree.prototype.firstChild = function (t) {
            var n = findNode(t, this._root);
            return n && n.children.length > 0 ? n.children[0].value : null;
        };
        /**
         * @internal
         */
        Tree.prototype.siblings = function (t) {
            var p = findPath(t, this._root);
            if (p.length < 2)
                return [];
            var c = p[p.length - 2].children.map(function (c) { return c.value; });
            return c.filter(function (cc) { return cc !== t; });
        };
        /**
         * @internal
         */
        Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };
        return Tree;
    }());
    // DFS for the node matching the value
    function findNode(value, node) {
        var e_1, _a;
        if (value === node.value)
            return node;
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var node_1 = findNode(value, child);
                if (node_1)
                    return node_1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    }
    // Return the path to the node with the given value using DFS
    function findPath(value, node) {
        var e_2, _a;
        if (value === node.value)
            return [node];
        try {
            for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var path = findPath(value, child);
                if (path.length) {
                    path.unshift(node);
                    return path;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return [];
    }
    var TreeNode = /** @class */ (function () {
        function TreeNode(value, children) {
            this.value = value;
            this.children = children;
        }
        TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
        return TreeNode;
    }());
    // Return the list of T indexed by outlet name
    function nodeChildrenAsMap(node) {
        var map = {};
        if (node) {
            node.children.forEach(function (child) { return map[child.value.outlet] = child; });
        }
        return map;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Represents the state of the router.
     *
     * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
     * segments, the extracted parameters, and the resolved data.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const root: ActivatedRoute = state.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * See `ActivatedRoute` for more information.
     *
     * @publicApi
     */
    var RouterState = /** @class */ (function (_super) {
        __extends(RouterState, _super);
        /** @internal */
        function RouterState(root, 
        /** The current snapshot of the router state */
        snapshot) {
            var _this = _super.call(this, root) || this;
            _this.snapshot = snapshot;
            setRouterState(_this, root);
            return _this;
        }
        RouterState.prototype.toString = function () { return this.snapshot.toString(); };
        return RouterState;
    }(Tree));
    function createEmptyState(urlTree, rootComponent) {
        var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
        var emptyUrl = new rxjs.BehaviorSubject([new UrlSegment('', {})]);
        var emptyParams = new rxjs.BehaviorSubject({});
        var emptyData = new rxjs.BehaviorSubject({});
        var emptyQueryParams = new rxjs.BehaviorSubject({});
        var fragment = new rxjs.BehaviorSubject('');
        var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
        activated.snapshot = snapshot.root;
        return new RouterState(new TreeNode(activated, []), snapshot);
    }
    function createEmptyStateSnapshot(urlTree, rootComponent) {
        var emptyParams = {};
        var emptyData = {};
        var emptyQueryParams = {};
        var fragment = '';
        var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
        return new RouterStateSnapshot('', new TreeNode(activated, []));
    }
    /**
     * @description
     *
     * Contains the information about a route associated with a component loaded in an
     * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.
     *
     * {@example router/activated-route/module.ts region="activated-route"
     *     header="activated-route.component.ts" linenums="false"}
     *
     * @publicApi
     */
    var ActivatedRoute = /** @class */ (function () {
        /** @internal */
        function ActivatedRoute(
        /** An observable of the URL segments matched by this route */
        url, 
        /** An observable of the matrix parameters scoped to this route */
        params, 
        /** An observable of the query parameters shared by all the routes */
        queryParams, 
        /** An observable of the URL fragment shared by all the routes */
        fragment, 
        /** An observable of the static and resolved data of this route. */
        data, 
        /** The outlet name of the route. It's a constant */
        outlet, 
        /** The component of the route. It's a constant */
        // TODO(vsavkin): remove |string
        component, futureSnapshot) {
            this.url = url;
            this.params = params;
            this.queryParams = queryParams;
            this.fragment = fragment;
            this.data = data;
            this.outlet = outlet;
            this.component = component;
            this._futureSnapshot = futureSnapshot;
        }
        Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
            /** The configuration used to match this route */
            get: function () { return this._futureSnapshot.routeConfig; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "root", {
            /** The root of the router state */
            get: function () { return this._routerState.root; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "parent", {
            /** The parent of this route in the router state tree */
            get: function () { return this._routerState.parent(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
            /** The first child of this route in the router state tree */
            get: function () { return this._routerState.firstChild(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "children", {
            /** The children of this route in the router state tree */
            get: function () { return this._routerState.children(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
            /** The path from the root of the router state tree to this route */
            get: function () { return this._routerState.pathFromRoot(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "paramMap", {
            get: function () {
                if (!this._paramMap) {
                    this._paramMap = this.params.pipe(operators.map(function (p) { return convertToParamMap(p); }));
                }
                return this._paramMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap =
                        this.queryParams.pipe(operators.map(function (p) { return convertToParamMap(p); }));
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        ActivatedRoute.prototype.toString = function () {
            return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
        };
        return ActivatedRoute;
    }());
    /**
     * Returns the inherited params, data, and resolve for a given route.
     * By default, this only inherits values up to the nearest path-less or component-less route.
     * @internal
     */
    function inheritedParamsDataResolve(route, paramsInheritanceStrategy) {
        if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
        var pathFromRoot = route.pathFromRoot;
        var inheritingStartingFrom = 0;
        if (paramsInheritanceStrategy !== 'always') {
            inheritingStartingFrom = pathFromRoot.length - 1;
            while (inheritingStartingFrom >= 1) {
                var current = pathFromRoot[inheritingStartingFrom];
                var parent_1 = pathFromRoot[inheritingStartingFrom - 1];
                // current route is an empty path => inherits its parent's params and data
                if (current.routeConfig && current.routeConfig.path === '') {
                    inheritingStartingFrom--;
                    // parent is componentless => current route should inherit its params and data
                }
                else if (!parent_1.component) {
                    inheritingStartingFrom--;
                }
                else {
                    break;
                }
            }
        }
        return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
    }
    /** @internal */
    function flattenInherited(pathFromRoot) {
        return pathFromRoot.reduce(function (res, curr) {
            var params = __assign({}, res.params, curr.params);
            var data = __assign({}, res.data, curr.data);
            var resolve = __assign({}, res.resolve, curr._resolvedData);
            return { params: params, data: data, resolve: resolve };
        }, { params: {}, data: {}, resolve: {} });
    }
    /**
     * @description
     *
     * Contains the information about a route associated with a component loaded in an
     * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to
     * traverse the router state tree.
     *
     * ```
     * @Component({templateUrl:'./my-component.html'})
     * class MyComponent {
     *   constructor(route: ActivatedRoute) {
     *     const id: string = route.snapshot.params.id;
     *     const url: string = route.snapshot.url.join('');
     *     const user = route.snapshot.data.user;
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var ActivatedRouteSnapshot = /** @class */ (function () {
        /** @internal */
        function ActivatedRouteSnapshot(
        /** The URL segments matched by this route */
        url, 
        /** The matrix parameters scoped to this route */
        params, 
        /** The query parameters shared by all the routes */
        queryParams, 
        /** The URL fragment shared by all the routes */
        fragment, 
        /** The static and resolved data of this route */
        data, 
        /** The outlet name of the route */
        outlet, 
        /** The component of the route */
        component, routeConfig, urlSegment, lastPathIndex, resolve) {
            this.url = url;
            this.params = params;
            this.queryParams = queryParams;
            this.fragment = fragment;
            this.data = data;
            this.outlet = outlet;
            this.component = component;
            this.routeConfig = routeConfig;
            this._urlSegment = urlSegment;
            this._lastPathIndex = lastPathIndex;
            this._resolve = resolve;
        }
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
            /** The root of the router state */
            get: function () { return this._routerState.root; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
            /** The parent of this route in the router state tree */
            get: function () { return this._routerState.parent(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
            /** The first child of this route in the router state tree */
            get: function () { return this._routerState.firstChild(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
            /** The children of this route in the router state tree */
            get: function () { return this._routerState.children(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
            /** The path from the root of the router state tree to this route */
            get: function () { return this._routerState.pathFromRoot(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {
            get: function () {
                if (!this._paramMap) {
                    this._paramMap = convertToParamMap(this.params);
                }
                return this._paramMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        ActivatedRouteSnapshot.prototype.toString = function () {
            var url = this.url.map(function (segment) { return segment.toString(); }).join('/');
            var matched = this.routeConfig ? this.routeConfig.path : '';
            return "Route(url:'" + url + "', path:'" + matched + "')";
        };
        return ActivatedRouteSnapshot;
    }());
    /**
     * @description
     *
     * Represents the state of the router at a moment in time.
     *
     * This is a tree of activated route snapshots. Every node in this tree knows about
     * the "consumed" URL segments, the extracted parameters, and the resolved data.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const state: RouterState = router.routerState;
     *     const snapshot: RouterStateSnapshot = state.snapshot;
     *     const root: ActivatedRouteSnapshot = snapshot.root;
     *     const child = root.firstChild;
     *     const id: Observable<string> = child.params.map(p => p.id);
     *     //...
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var RouterStateSnapshot = /** @class */ (function (_super) {
        __extends(RouterStateSnapshot, _super);
        /** @internal */
        function RouterStateSnapshot(
        /** The url from which this snapshot was created */
        url, root) {
            var _this = _super.call(this, root) || this;
            _this.url = url;
            setRouterState(_this, root);
            return _this;
        }
        RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
        return RouterStateSnapshot;
    }(Tree));
    function setRouterState(state, node) {
        node.value._routerState = state;
        node.children.forEach(function (c) { return setRouterState(state, c); });
    }
    function serializeNode(node) {
        var c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(', ') + " } " : '';
        return "" + node.value + c;
    }
    /**
     * The expectation is that the activate route is created with the right set of parameters.
     * So we push new values into the observables only when they are not the initial values.
     * And we detect that by checking if the snapshot field is set.
     */
    function advanceActivatedRoute(route) {
        if (route.snapshot) {
            var currentSnapshot = route.snapshot;
            var nextSnapshot = route._futureSnapshot;
            route.snapshot = nextSnapshot;
            if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
                route.queryParams.next(nextSnapshot.queryParams);
            }
            if (currentSnapshot.fragment !== nextSnapshot.fragment) {
                route.fragment.next(nextSnapshot.fragment);
            }
            if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
                route.params.next(nextSnapshot.params);
            }
            if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
                route.url.next(nextSnapshot.url);
            }
            if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
                route.data.next(nextSnapshot.data);
            }
        }
        else {
            route.snapshot = route._futureSnapshot;
            // this is for resolved data
            route.data.next(route._futureSnapshot.data);
        }
    }
    function equalParamsAndUrlSegments(a, b) {
        var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
        var parentsMismatch = !a.parent !== !b.parent;
        return equalUrlParams && !parentsMismatch &&
            (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createRouterState(routeReuseStrategy, curr, prevState) {
        var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
        return new RouterState(root, curr);
    }
    function createNode(routeReuseStrategy, curr, prevState) {
        // reuse an activated route that is currently displayed on the screen
        if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
            var value = prevState.value;
            value._futureSnapshot = curr.value;
            var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
            return new TreeNode(value, children);
            // retrieve an activated route that is used to be displayed, but is not currently displayed
        }
        else {
            var detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
            if (detachedRouteHandle) {
                var tree = detachedRouteHandle.route;
                setFutureSnapshotsOfActivatedRoutes(curr, tree);
                return tree;
            }
            else {
                var value = createActivatedRoute(curr.value);
                var children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
                return new TreeNode(value, children);
            }
        }
    }
    function setFutureSnapshotsOfActivatedRoutes(curr, result) {
        if (curr.value.routeConfig !== result.value.routeConfig) {
            throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
        }
        if (curr.children.length !== result.children.length) {
            throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
        }
        result.value._futureSnapshot = curr.value;
        for (var i = 0; i < curr.children.length; ++i) {
            setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
        }
    }
    function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
        return curr.children.map(function (child) {
            var e_1, _a;
            try {
                for (var _b = __values(prevState.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var p = _c.value;
                    if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
                        return createNode(routeReuseStrategy, child, p);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return createNode(routeReuseStrategy, child);
        });
    }
    function createActivatedRoute(c) {
        return new ActivatedRoute(new rxjs.BehaviorSubject(c.url), new rxjs.BehaviorSubject(c.params), new rxjs.BehaviorSubject(c.queryParams), new rxjs.BehaviorSubject(c.fragment), new rxjs.BehaviorSubject(c.data), c.outlet, c.component, c);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createUrlTree(route, urlTree, commands, queryParams, fragment) {
        if (commands.length === 0) {
            return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
        }
        var nav = computeNavigation(commands);
        if (nav.toRoot()) {
            return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
        }
        var startingPosition = findStartingPosition(nav, urlTree, route);
        var segmentGroup = startingPosition.processChildren ?
            updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
            updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
        return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
    }
    function isMatrixParams(command) {
        return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
    }
    function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
        var qp = {};
        if (queryParams) {
            forEach(queryParams, function (value, name) {
                qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;
            });
        }
        if (urlTree.root === oldSegmentGroup) {
            return new UrlTree(newSegmentGroup, qp, fragment);
        }
        return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
    }
    function replaceSegment(current, oldSegment, newSegment) {
        var children = {};
        forEach(current.children, function (c, outletName) {
            if (c === oldSegment) {
                children[outletName] = newSegment;
            }
            else {
                children[outletName] = replaceSegment(c, oldSegment, newSegment);
            }
        });
        return new UrlSegmentGroup(current.segments, children);
    }
    var Navigation = /** @class */ (function () {
        function Navigation(isAbsolute, numberOfDoubleDots, commands) {
            this.isAbsolute = isAbsolute;
            this.numberOfDoubleDots = numberOfDoubleDots;
            this.commands = commands;
            if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
                throw new Error('Root segment cannot have matrix parameters');
            }
            var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
            if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
                throw new Error('{outlets:{}} has to be the last command');
            }
        }
        Navigation.prototype.toRoot = function () {
            return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
        };
        return Navigation;
    }());
    /** Transforms commands to a normalized `Navigation` */
    function computeNavigation(commands) {
        if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
            return new Navigation(true, 0, commands);
        }
        var numberOfDoubleDots = 0;
        var isAbsolute = false;
        var res = commands.reduce(function (res, cmd, cmdIdx) {
            if (typeof cmd === 'object' && cmd != null) {
                if (cmd.outlets) {
                    var outlets_1 = {};
                    forEach(cmd.outlets, function (commands, name) {
                        outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
                    });
                    return __spread(res, [{ outlets: outlets_1 }]);
                }
                if (cmd.segmentPath) {
                    return __spread(res, [cmd.segmentPath]);
                }
            }
            if (!(typeof cmd === 'string')) {
                return __spread(res, [cmd]);
            }
            if (cmdIdx === 0) {
                cmd.split('/').forEach(function (urlPart, partIndex) {
                    if (partIndex == 0 && urlPart === '.') ;
                    else if (partIndex == 0 && urlPart === '') { //  '/a'
                        isAbsolute = true;
                    }
                    else if (urlPart === '..') { //  '../a'
                        numberOfDoubleDots++;
                    }
                    else if (urlPart != '') {
                        res.push(urlPart);
                    }
                });
                return res;
            }
            return __spread(res, [cmd]);
        }, []);
        return new Navigation(isAbsolute, numberOfDoubleDots, res);
    }
    var Position = /** @class */ (function () {
        function Position(segmentGroup, processChildren, index) {
            this.segmentGroup = segmentGroup;
            this.processChildren = processChildren;
            this.index = index;
        }
        return Position;
    }());
    function findStartingPosition(nav, tree, route) {
        if (nav.isAbsolute) {
            return new Position(tree.root, true, 0);
        }
        if (route.snapshot._lastPathIndex === -1) {
            return new Position(route.snapshot._urlSegment, true, 0);
        }
        var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
        var index = route.snapshot._lastPathIndex + modifier;
        return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
    }
    function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
        var g = group;
        var ci = index;
        var dd = numberOfDoubleDots;
        while (dd > ci) {
            dd -= ci;
            g = g.parent;
            if (!g) {
                throw new Error('Invalid number of \'../\'');
            }
            ci = g.segments.length;
        }
        return new Position(g, false, ci - dd);
    }
    function getPath(command) {
        if (typeof command === 'object' && command != null && command.outlets) {
            return command.outlets[PRIMARY_OUTLET];
        }
        return "" + command;
    }
    function getOutlets(commands) {
        var _a, _b;
        if (!(typeof commands[0] === 'object'))
            return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;
        if (commands[0].outlets === undefined)
            return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;
        return commands[0].outlets;
    }
    function updateSegmentGroup(segmentGroup, startIndex, commands) {
        if (!segmentGroup) {
            segmentGroup = new UrlSegmentGroup([], {});
        }
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
        }
        var m = prefixedWith(segmentGroup, startIndex, commands);
        var slicedCommands = commands.slice(m.commandIndex);
        if (m.match && m.pathIndex < segmentGroup.segments.length) {
            var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
            g.children[PRIMARY_OUTLET] =
                new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
            return updateSegmentGroupChildren(g, 0, slicedCommands);
        }
        else if (m.match && slicedCommands.length === 0) {
            return new UrlSegmentGroup(segmentGroup.segments, {});
        }
        else if (m.match && !segmentGroup.hasChildren()) {
            return createNewSegmentGroup(segmentGroup, startIndex, commands);
        }
        else if (m.match) {
            return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
        }
        else {
            return createNewSegmentGroup(segmentGroup, startIndex, commands);
        }
    }
    function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
        if (commands.length === 0) {
            return new UrlSegmentGroup(segmentGroup.segments, {});
        }
        else {
            var outlets_2 = getOutlets(commands);
            var children_1 = {};
            forEach(outlets_2, function (commands, outlet) {
                if (commands !== null) {
                    children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
                }
            });
            forEach(segmentGroup.children, function (child, childOutlet) {
                if (outlets_2[childOutlet] === undefined) {
                    children_1[childOutlet] = child;
                }
            });
            return new UrlSegmentGroup(segmentGroup.segments, children_1);
        }
    }
    function prefixedWith(segmentGroup, startIndex, commands) {
        var currentCommandIndex = 0;
        var currentPathIndex = startIndex;
        var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
        while (currentPathIndex < segmentGroup.segments.length) {
            if (currentCommandIndex >= commands.length)
                return noMatch;
            var path = segmentGroup.segments[currentPathIndex];
            var curr = getPath(commands[currentCommandIndex]);
            var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
            if (currentPathIndex > 0 && curr === undefined)
                break;
            if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
                if (!compare(curr, next, path))
                    return noMatch;
                currentCommandIndex += 2;
            }
            else {
                if (!compare(curr, {}, path))
                    return noMatch;
                currentCommandIndex++;
            }
            currentPathIndex++;
        }
        return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
    }
    function createNewSegmentGroup(segmentGroup, startIndex, commands) {
        var paths = segmentGroup.segments.slice(0, startIndex);
        var i = 0;
        while (i < commands.length) {
            if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
                var children = createNewSegmentChildren(commands[i].outlets);
                return new UrlSegmentGroup(paths, children);
            }
            // if we start with an object literal, we need to reuse the path part from the segment
            if (i === 0 && isMatrixParams(commands[0])) {
                var p = segmentGroup.segments[startIndex];
                paths.push(new UrlSegment(p.path, commands[0]));
                i++;
                continue;
            }
            var curr = getPath(commands[i]);
            var next = (i < commands.length - 1) ? commands[i + 1] : null;
            if (curr && next && isMatrixParams(next)) {
                paths.push(new UrlSegment(curr, stringify(next)));
                i += 2;
            }
            else {
                paths.push(new UrlSegment(curr, {}));
                i++;
            }
        }
        return new UrlSegmentGroup(paths, {});
    }
    function createNewSegmentChildren(outlets) {
        var children = {};
        forEach(outlets, function (commands, outlet) {
            if (commands !== null) {
                children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
            }
        });
        return children;
    }
    function stringify(params) {
        var res = {};
        forEach(params, function (v, k) { return res[k] = "" + v; });
        return res;
    }
    function compare(path, params, segment) {
        return path == segment.path && shallowEqual(params, segment.parameters);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var activateRoutes = function (rootContexts, routeReuseStrategy, forwardEvent) {
        return operators.map(function (t) {
            new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent)
                .activate(rootContexts);
            return t;
        });
    };
    var ActivateRoutes = /** @class */ (function () {
        function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {
            this.routeReuseStrategy = routeReuseStrategy;
            this.futureState = futureState;
            this.currState = currState;
            this.forwardEvent = forwardEvent;
        }
        ActivateRoutes.prototype.activate = function (parentContexts) {
            var futureRoot = this.futureState._root;
            var currRoot = this.currState ? this.currState._root : null;
            this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
            advanceActivatedRoute(this.futureState.root);
            this.activateChildRoutes(futureRoot, currRoot, parentContexts);
        };
        // De-activate the child route that are not re-used for the future state
        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            // Recurse on the routes active in the future state to de-activate deeper children
            futureNode.children.forEach(function (futureChild) {
                var childOutletName = futureChild.value.outlet;
                _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
                delete children[childOutletName];
            });
            // De-activate the routes that will not be re-used
            forEach(children, function (v, childName) {
                _this.deactivateRouteAndItsChildren(v, contexts);
            });
        };
        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            if (future === curr) {
                // Reusing the node, check to see if the children need to be de-activated
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContext.getContext(future.outlet);
                    if (context) {
                        this.deactivateChildRoutes(futureNode, currNode, context.children);
                    }
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.deactivateChildRoutes(futureNode, currNode, parentContext);
                }
            }
            else {
                if (curr) {
                    // Deactivate the current route which will not be re-used
                    this.deactivateRouteAndItsChildren(currNode, parentContext);
                }
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
            if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
                this.detachAndStoreRouteSubtree(route, parentContexts);
            }
            else {
                this.deactivateRouteAndOutlet(route, parentContexts);
            }
        };
        ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
            var context = parentContexts.getContext(route.value.outlet);
            if (context && context.outlet) {
                var componentRef = context.outlet.detach();
                var contexts = context.children.onOutletDeactivated();
                this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
            var _this = this;
            var context = parentContexts.getContext(route.value.outlet);
            if (context) {
                var children = nodeChildrenAsMap(route);
                var contexts_1 = route.value.component ? context.children : parentContexts;
                forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });
                if (context.outlet) {
                    // Destroy the component
                    context.outlet.deactivate();
                    // Destroy the contexts for all the outlets that were in the component
                    context.children.onOutletDeactivated();
                }
            }
        };
        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            futureNode.children.forEach(function (c) {
                _this.activateRoutes(c, children[c.value.outlet], contexts);
                _this.forwardEvent(new ActivationEnd(c.value.snapshot));
            });
            if (futureNode.children.length) {
                this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
            }
        };
        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            advanceActivatedRoute(future);
            // reusing the node
            if (future === curr) {
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    this.activateChildRoutes(futureNode, currNode, context.children);
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, currNode, parentContexts);
                }
            }
            else {
                if (future.component) {
                    // if we have a normal route, we need to place the component into the outlet and recurse.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                        var stored = this.routeReuseStrategy.retrieve(future.snapshot);
                        this.routeReuseStrategy.store(future.snapshot, null);
                        context.children.onOutletReAttached(stored.contexts);
                        context.attachRef = stored.componentRef;
                        context.route = stored.route.value;
                        if (context.outlet) {
                            // Attach right away when the outlet has already been instantiated
                            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                            context.outlet.attach(stored.componentRef, stored.route.value);
                        }
                        advanceActivatedRouteNodeAndItsChildren(stored.route);
                    }
                    else {
                        var config = parentLoadedConfig(future.snapshot);
                        var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                        context.attachRef = null;
                        context.route = future;
                        context.resolver = cmpFactoryResolver;
                        if (context.outlet) {
                            // Activate the outlet when it has already been instantiated
                            // Otherwise it will get activated from its `ngOnInit` when instantiated
                            context.outlet.activateWith(future, cmpFactoryResolver);
                        }
                        this.activateChildRoutes(futureNode, null, context.children);
                    }
                }
                else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, null, parentContexts);
                }
            }
        };
        return ActivateRoutes;
    }());
    function advanceActivatedRouteNodeAndItsChildren(node) {
        advanceActivatedRoute(node.value);
        node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
    }
    function parentLoadedConfig(snapshot) {
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig)
                return route._loadedConfig;
            if (route && route.component)
                return null;
        }
        return null;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Simple function check, but generic so type inference will flow. Example:
     *
     * function product(a: number, b: number) {
     *   return a * b;
     * }
     *
     * if (isFunction<product>(fn)) {
     *   return fn(1, 2);
     * } else {
     *   throw "Must provide the `product` function";
     * }
     */
    function isFunction(v) {
        return typeof v === 'function';
    }
    function isBoolean(v) {
        return typeof v === 'boolean';
    }
    function isUrlTree(v) {
        return v instanceof UrlTree;
    }
    function isCanLoad(guard) {
        return guard && isFunction(guard.canLoad);
    }
    function isCanActivate(guard) {
        return guard && isFunction(guard.canActivate);
    }
    function isCanActivateChild(guard) {
        return guard && isFunction(guard.canActivateChild);
    }
    function isCanDeactivate(guard) {
        return guard && isFunction(guard.canDeactivate);
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NoMatch = /** @class */ (function () {
        function NoMatch(segmentGroup) {
            this.segmentGroup = segmentGroup || null;
        }
        return NoMatch;
    }());
    var AbsoluteRedirect = /** @class */ (function () {
        function AbsoluteRedirect(urlTree) {
            this.urlTree = urlTree;
        }
        return AbsoluteRedirect;
    }());
    function noMatch(segmentGroup) {
        return new rxjs.Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });
    }
    function absoluteRedirect(newTree) {
        return new rxjs.Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
    }
    function namedOutletsRedirect(redirectTo) {
        return new rxjs.Observable(function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
    }
    function canLoadFails(route) {
        return new rxjs.Observable(function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
    }
    /**
     * Returns the `UrlTree` with the redirection applied.
     *
     * Lazy modules are loaded along the way.
     */
    function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
        return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
    }
    var ApplyRedirects = /** @class */ (function () {
        function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
            this.configLoader = configLoader;
            this.urlSerializer = urlSerializer;
            this.urlTree = urlTree;
            this.config = config;
            this.allowRedirects = true;
            this.ngModule = moduleInjector.get(core.NgModuleRef);
        }
        ApplyRedirects.prototype.apply = function () {
            var _this = this;
            var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
            var urlTrees$ = expanded$.pipe(operators.map(function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); }));
            return urlTrees$.pipe(operators.catchError(function (e) {
                if (e instanceof AbsoluteRedirect) {
                    // after an absolute redirect we do not apply any more redirects!
                    _this.allowRedirects = false;
                    // we need to run matching, so we can fetch all lazy-loaded modules
                    return _this.match(e.urlTree);
                }
                if (e instanceof NoMatch) {
                    throw _this.noMatchError(e);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.match = function (tree) {
            var _this = this;
            var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
            var mapped$ = expanded$.pipe(operators.map(function (rootSegmentGroup) {
                return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);
            }));
            return mapped$.pipe(operators.catchError(function (e) {
                if (e instanceof NoMatch) {
                    throw _this.noMatchError(e);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.noMatchError = function (e) {
            return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
        };
        ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
            var _a;
            var root = rootCandidate.segments.length > 0 ?
                new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
                rootCandidate;
            return new UrlTree(root, queryParams, fragment);
        };
        ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {
            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                return this.expandChildren(ngModule, routes, segmentGroup)
                    .pipe(operators.map(function (children) { return new UrlSegmentGroup([], children); }));
            }
            return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
        };
        // Recursively expand segment groups for all the child outlets
        ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {
            var _this = this;
            return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });
        };
        ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
            var _this = this;
            return rxjs.of.apply(void 0, __spread(routes)).pipe(operators.map(function (r) {
                var expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
                return expanded$.pipe(operators.catchError(function (e) {
                    if (e instanceof NoMatch) {
                        // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -
                        // talk to Jason
                        return rxjs.of(null);
                    }
                    throw e;
                }));
            }), operators.concatAll(), operators.first(function (s) { return !!s; }), operators.catchError(function (e, _) {
                if (e instanceof rxjs.EmptyError || e.name === 'EmptyError') {
                    if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                        return rxjs.of(new UrlSegmentGroup([], {}));
                    }
                    throw new NoMatch(segmentGroup);
                }
                throw e;
            }));
        };
        ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
            return segments.length === 0 && !segmentGroup.children[outlet];
        };
        ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
            if (getOutlet(route) !== outlet) {
                return noMatch(segmentGroup);
            }
            if (route.redirectTo === undefined) {
                return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
            }
            if (allowRedirects && this.allowRedirects) {
                return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
            }
            return noMatch(segmentGroup);
        };
        ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
            if (route.path === '**') {
                return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
            }
            return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
        };
        ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {
            var _this = this;
            var newTree = this.applyRedirectCommands([], route.redirectTo, {});
            if (route.redirectTo.startsWith('/')) {
                return absoluteRedirect(newTree);
            }
            return this.lineralizeSegments(route, newTree).pipe(operators.mergeMap(function (newSegments) {
                var group = new UrlSegmentGroup(newSegments, {});
                return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
            }));
        };
        ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
            var _this = this;
            var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
            if (!matched)
                return noMatch(segmentGroup);
            var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
            if (route.redirectTo.startsWith('/')) {
                return absoluteRedirect(newTree);
            }
            return this.lineralizeSegments(route, newTree).pipe(operators.mergeMap(function (newSegments) {
                return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
            }));
        };
        ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {
            var _this = this;
            if (route.path === '**') {
                if (route.loadChildren) {
                    return this.configLoader.load(ngModule.injector, route)
                        .pipe(operators.map(function (cfg) {
                        route._loadedConfig = cfg;
                        return new UrlSegmentGroup(segments, {});
                    }));
                }
                return rxjs.of(new UrlSegmentGroup(segments, {}));
            }
            var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;
            if (!matched)
                return noMatch(rawSegmentGroup);
            var rawSlicedSegments = segments.slice(lastChild);
            var childConfig$ = this.getChildConfig(ngModule, route, segments);
            return childConfig$.pipe(operators.mergeMap(function (routerConfig) {
                var childModule = routerConfig.module;
                var childConfig = routerConfig.routes;
                var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                    var expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);
                    return expanded$_1.pipe(operators.map(function (children) { return new UrlSegmentGroup(consumedSegments, children); }));
                }
                if (childConfig.length === 0 && slicedSegments.length === 0) {
                    return rxjs.of(new UrlSegmentGroup(consumedSegments, {}));
                }
                var expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
                return expanded$.pipe(operators.map(function (cs) {
                    return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);
                }));
            }));
        };
        ApplyRedirects.prototype.getChildConfig = function (ngModule, route, segments) {
            var _this = this;
            if (route.children) {
                // The children belong to the same module
                return rxjs.of(new LoadedRouterConfig(route.children, ngModule));
            }
            if (route.loadChildren) {
                // lazy children belong to the loaded module
                if (route._loadedConfig !== undefined) {
                    return rxjs.of(route._loadedConfig);
                }
                return runCanLoadGuard(ngModule.injector, route, segments)
                    .pipe(operators.mergeMap(function (shouldLoad) {
                    if (shouldLoad) {
                        return _this.configLoader.load(ngModule.injector, route)
                            .pipe(operators.map(function (cfg) {
                            route._loadedConfig = cfg;
                            return cfg;
                        }));
                    }
                    return canLoadFails(route);
                }));
            }
            return rxjs.of(new LoadedRouterConfig([], ngModule));
        };
        ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
            var res = [];
            var c = urlTree.root;
            while (true) {
                res = res.concat(c.segments);
                if (c.numberOfChildren === 0) {
                    return rxjs.of(res);
                }
                if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
                    return namedOutletsRedirect(route.redirectTo);
                }
                c = c.children[PRIMARY_OUTLET];
            }
        };
        ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
            return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
        };
        ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
            var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
            return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
        };
        ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
            var res = {};
            forEach(redirectToParams, function (v, k) {
                var copySourceValue = typeof v === 'string' && v.startsWith(':');
                if (copySourceValue) {
                    var sourceName = v.substring(1);
                    res[k] = actualParams[sourceName];
                }
                else {
                    res[k] = v;
                }
            });
            return res;
        };
        ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
            var _this = this;
            var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
            var children = {};
            forEach(group.children, function (child, name) {
                children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
            });
            return new UrlSegmentGroup(updatedSegments, children);
        };
        ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
            var _this = this;
            return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
                _this.findOrReturn(s, actualSegments); });
        };
        ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
            var pos = posParams[redirectToUrlSegment.path.substring(1)];
            if (!pos)
                throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
            return pos;
        };
        ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
            var e_1, _a;
            var idx = 0;
            try {
                for (var actualSegments_1 = __values(actualSegments), actualSegments_1_1 = actualSegments_1.next(); !actualSegments_1_1.done; actualSegments_1_1 = actualSegments_1.next()) {
                    var s = actualSegments_1_1.value;
                    if (s.path === redirectToUrlSegment.path) {
                        actualSegments.splice(idx);
                        return s;
                    }
                    idx++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (actualSegments_1_1 && !actualSegments_1_1.done && (_a = actualSegments_1.return)) _a.call(actualSegments_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return redirectToUrlSegment;
        };
        return ApplyRedirects;
    }());
    function runCanLoadGuard(moduleInjector, route, segments) {
        var canLoad = route.canLoad;
        if (!canLoad || canLoad.length === 0)
            return rxjs.of(true);
        var obs = rxjs.from(canLoad).pipe(operators.map(function (injectionToken) {
            var guard = moduleInjector.get(injectionToken);
            var guardVal;
            if (isCanLoad(guard)) {
                guardVal = guard.canLoad(route, segments);
            }
            else if (isFunction(guard)) {
                guardVal = guard(route, segments);
            }
            else {
                throw new Error('Invalid CanLoad guard');
            }
            return wrapIntoObservable(guardVal);
        }));
        return obs.pipe(operators.concatAll(), operators.every(function (result) { return result === true; }));
    }
    function match(segmentGroup, route, segments) {
        if (route.path === '') {
            if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
                return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
            }
            return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
        }
        var matcher = route.matcher || defaultUrlMatcher;
        var res = matcher(segments, segmentGroup, route);
        if (!res) {
            return {
                matched: false,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {},
            };
        }
        return {
            matched: true,
            consumedSegments: res.consumed,
            lastChild: res.consumed.length,
            positionalParamSegments: res.posParams,
        };
    }
    function split(segmentGroup, consumedSegments, slicedSegments, config) {
        if (slicedSegments.length > 0 &&
            containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
            var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
        }
        if (slicedSegments.length === 0 &&
            containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
            var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
            return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
        }
        return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
    }
    function mergeTrivialChildren(s) {
        if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
            var c = s.children[PRIMARY_OUTLET];
            return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
        }
        return s;
    }
    function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
        var e_2, _a;
        var res = {};
        try {
            for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                var r = routes_1_1.value;
                if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
                    res[getOutlet(r)] = new UrlSegmentGroup([], {});
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return __assign({}, children, res);
    }
    function createChildrenForEmptySegments(routes, primarySegmentGroup) {
        var e_3, _a;
        var res = {};
        res[PRIMARY_OUTLET] = primarySegmentGroup;
        try {
            for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
                var r = routes_2_1.value;
                if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
                    res[getOutlet(r)] = new UrlSegmentGroup([], {});
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    }
    function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
        return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });
    }
    function containsEmptyPathRedirects(segmentGroup, segments, routes) {
        return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });
    }
    function isEmptyPathRedirect(segmentGroup, segments, r) {
        if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
            return false;
        }
        return r.path === '' && r.redirectTo !== undefined;
    }
    function getOutlet(route) {
        return route.outlet || PRIMARY_OUTLET;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {
        return function (source) {
            return source.pipe(operators.switchMap(function (t) { return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config)
                .pipe(operators.map(function (urlAfterRedirects) { return (__assign({}, t, { urlAfterRedirects: urlAfterRedirects })); })); }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var CanActivate = /** @class */ (function () {
        function CanActivate(path) {
            this.path = path;
            this.route = this.path[this.path.length - 1];
        }
        return CanActivate;
    }());
    var CanDeactivate = /** @class */ (function () {
        function CanDeactivate(component, route) {
            this.component = component;
            this.route = route;
        }
        return CanDeactivate;
    }());
    function getAllRouteGuards(future, curr, parentContexts) {
        var futureRoot = future._root;
        var currRoot = curr ? curr._root : null;
        return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
    }
    function getCanActivateChild(p) {
        var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
        if (!canActivateChild || canActivateChild.length === 0)
            return null;
        return { node: p, guards: canActivateChild };
    }
    function getToken(token, snapshot, moduleInjector) {
        var config = getClosestLoadedConfig(snapshot);
        var injector = config ? config.module.injector : moduleInjector;
        return injector.get(token);
    }
    function getClosestLoadedConfig(snapshot) {
        if (!snapshot)
            return null;
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig)
                return route._loadedConfig;
        }
        return null;
    }
    function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks) {
        if (checks === void 0) { checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }; }
        var prevChildren = nodeChildrenAsMap(currNode);
        // Process the children of the future route
        futureNode.children.forEach(function (c) {
            getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
            delete prevChildren[c.value.outlet];
        });
        // Process any children left from the current route (not active for the future route)
        forEach(prevChildren, function (v, k) {
            return deactivateRouteAndItsChildren(v, contexts.getContext(k), checks);
        });
        return checks;
    }
    function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks) {
        if (checks === void 0) { checks = {
            canDeactivateChecks: [],
            canActivateChecks: []
        }; }
        var future = futureNode.value;
        var curr = currNode ? currNode.value : null;
        var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
        // reusing the node
        if (curr && future.routeConfig === curr.routeConfig) {
            var shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
            if (shouldRun) {
                checks.canActivateChecks.push(new CanActivate(futurePath));
            }
            else {
                // we need to set the data
                future.data = curr.data;
                future._resolvedData = curr._resolvedData;
            }
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
            }
            if (shouldRun) {
                var component = context && context.outlet && context.outlet.component || null;
                checks.canDeactivateChecks.push(new CanDeactivate(component, curr));
            }
        }
        else {
            if (curr) {
                deactivateRouteAndItsChildren(currNode, context, checks);
            }
            checks.canActivateChecks.push(new CanActivate(futurePath));
            // If we have a component, we need to go through an outlet.
            if (future.component) {
                getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
                // if we have a componentless route, we recurse but keep the same outlet map.
            }
            else {
                getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
            }
        }
        return checks;
    }
    function shouldRunGuardsAndResolvers(curr, future, mode) {
        if (typeof mode === 'function') {
            return mode(curr, future);
        }
        switch (mode) {
            case 'pathParamsChange':
                return !equalPath(curr.url, future.url);
            case 'pathParamsOrQueryParamsChange':
                return !equalPath(curr.url, future.url) ||
                    !shallowEqual(curr.queryParams, future.queryParams);
            case 'always':
                return true;
            case 'paramsOrQueryParamsChange':
                return !equalParamsAndUrlSegments(curr, future) ||
                    !shallowEqual(curr.queryParams, future.queryParams);
            case 'paramsChange':
            default:
                return !equalParamsAndUrlSegments(curr, future);
        }
    }
    function deactivateRouteAndItsChildren(route, context, checks) {
        var children = nodeChildrenAsMap(route);
        var r = route.value;
        forEach(children, function (node, childName) {
            if (!r.component) {
                deactivateRouteAndItsChildren(node, context, checks);
            }
            else if (context) {
                deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
            }
            else {
                deactivateRouteAndItsChildren(node, null, checks);
            }
        });
        if (!r.component) {
            checks.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
        else if (context && context.outlet && context.outlet.isActivated) {
            checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
        }
        else {
            checks.canDeactivateChecks.push(new CanDeactivate(null, r));
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var INITIAL_VALUE = Symbol('INITIAL_VALUE');
    function prioritizedGuardValue() {
        return operators.switchMap(function (obs) {
            return rxjs.combineLatest.apply(void 0, __spread(obs.map(function (o) { return o.pipe(operators.take(1), operators.startWith(INITIAL_VALUE)); }))).pipe(operators.scan(function (acc, list) {
                var isPending = false;
                return list.reduce(function (innerAcc, val, i) {
                    if (innerAcc !== INITIAL_VALUE)
                        return innerAcc;
                    // Toggle pending flag if any values haven't been set yet
                    if (val === INITIAL_VALUE)
                        isPending = true;
                    // Any other return values are only valid if we haven't yet hit a pending call.
                    // This guarantees that in the case of a guard at the bottom of the tree that
                    // returns a redirect, we will wait for the higher priority guard at the top to
                    // finish before performing the redirect.
                    if (!isPending) {
                        // Early return when we hit a `false` value as that should always cancel
                        // navigation
                        if (val === false)
                            return val;
                        if (i === list.length - 1 || isUrlTree(val)) {
                            return val;
                        }
                    }
                    return innerAcc;
                }, acc);
            }, INITIAL_VALUE), operators.filter(function (item) { return item !== INITIAL_VALUE; }), operators.map(function (item) { return isUrlTree(item) ? item : item === true; }), //
            operators.take(1));
        });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function checkGuards(moduleInjector, forwardEvent) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) {
                var targetSnapshot = t.targetSnapshot, currentSnapshot = t.currentSnapshot, _a = t.guards, canActivateChecks = _a.canActivateChecks, canDeactivateChecks = _a.canDeactivateChecks;
                if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
                    return rxjs.of(__assign({}, t, { guardsResult: true }));
                }
                return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector)
                    .pipe(operators.mergeMap(function (canDeactivate) {
                    return canDeactivate && isBoolean(canDeactivate) ?
                        runCanActivateChecks(targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) :
                        rxjs.of(canDeactivate);
                }), operators.map(function (guardsResult) { return (__assign({}, t, { guardsResult: guardsResult })); }));
            }));
        };
    }
    function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
        return rxjs.from(checks).pipe(operators.mergeMap(function (check) {
            return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);
        }), operators.first(function (result) { return result !== true; }, true));
    }
    function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
        return rxjs.from(checks).pipe(operators.concatMap(function (check) {
            return rxjs.from([
                fireChildActivationStart(check.route.parent, forwardEvent),
                fireActivationStart(check.route, forwardEvent),
                runCanActivateChild(futureSnapshot, check.path, moduleInjector),
                runCanActivate(futureSnapshot, check.route, moduleInjector)
            ])
                .pipe(operators.concatAll(), operators.first(function (result) {
                return result !== true;
            }, true));
        }), operators.first(function (result) { return result !== true; }, true));
    }
    /**
       * This should fire off `ActivationStart` events for each route being activated at this
       * level.
       * In other words, if you're activating `a` and `b` below, `path` will contain the
       * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always
       * return
       * `true` so checks continue to run.
       */
    function fireActivationStart(snapshot, forwardEvent) {
        if (snapshot !== null && forwardEvent) {
            forwardEvent(new ActivationStart(snapshot));
        }
        return rxjs.of(true);
    }
    /**
       * This should fire off `ChildActivationStart` events for each route being activated at this
       * level.
       * In other words, if you're activating `a` and `b` below, `path` will contain the
       * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always
       * return
       * `true` so checks continue to run.
       */
    function fireChildActivationStart(snapshot, forwardEvent) {
        if (snapshot !== null && forwardEvent) {
            forwardEvent(new ChildActivationStart(snapshot));
        }
        return rxjs.of(true);
    }
    function runCanActivate(futureRSS, futureARS, moduleInjector) {
        var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
        if (!canActivate || canActivate.length === 0)
            return rxjs.of(true);
        var canActivateObservables = canActivate.map(function (c) {
            return rxjs.defer(function () {
                var guard = getToken(c, futureARS, moduleInjector);
                var observable;
                if (isCanActivate(guard)) {
                    observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
                }
                else if (isFunction(guard)) {
                    observable = wrapIntoObservable(guard(futureARS, futureRSS));
                }
                else {
                    throw new Error('Invalid CanActivate guard');
                }
                return observable.pipe(operators.first());
            });
        });
        return rxjs.of(canActivateObservables).pipe(prioritizedGuardValue());
    }
    function runCanActivateChild(futureRSS, path, moduleInjector) {
        var futureARS = path[path.length - 1];
        var canActivateChildGuards = path.slice(0, path.length - 1)
            .reverse()
            .map(function (p) { return getCanActivateChild(p); })
            .filter(function (_) { return _ !== null; });
        var canActivateChildGuardsMapped = canActivateChildGuards.map(function (d) {
            return rxjs.defer(function () {
                var guardsMapped = d.guards.map(function (c) {
                    var guard = getToken(c, d.node, moduleInjector);
                    var observable;
                    if (isCanActivateChild(guard)) {
                        observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
                    }
                    else if (isFunction(guard)) {
                        observable = wrapIntoObservable(guard(futureARS, futureRSS));
                    }
                    else {
                        throw new Error('Invalid CanActivateChild guard');
                    }
                    return observable.pipe(operators.first());
                });
                return rxjs.of(guardsMapped).pipe(prioritizedGuardValue());
            });
        });
        return rxjs.of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
    }
    function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
        var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
        if (!canDeactivate || canDeactivate.length === 0)
            return rxjs.of(true);
        var canDeactivateObservables = canDeactivate.map(function (c) {
            var guard = getToken(c, currARS, moduleInjector);
            var observable;
            if (isCanDeactivate(guard)) {
                observable =
                    wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));
            }
            else if (isFunction(guard)) {
                observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
            }
            else {
                throw new Error('Invalid CanDeactivate guard');
            }
            return observable.pipe(operators.first());
        });
        return rxjs.of(canDeactivateObservables).pipe(prioritizedGuardValue());
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NoMatch$1 = /** @class */ (function () {
        function NoMatch() {
        }
        return NoMatch;
    }());
    function recognize(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
        if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
        if (relativeLinkResolution === void 0) { relativeLinkResolution = 'legacy'; }
        return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution)
            .recognize();
    }
    var Recognizer = /** @class */ (function () {
        function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
            this.rootComponentType = rootComponentType;
            this.config = config;
            this.urlTree = urlTree;
            this.url = url;
            this.paramsInheritanceStrategy = paramsInheritanceStrategy;
            this.relativeLinkResolution = relativeLinkResolution;
        }
        Recognizer.prototype.recognize = function () {
            try {
                var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;
                var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
                var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
                var rootNode = new TreeNode(root, children);
                var routeState = new RouterStateSnapshot(this.url, rootNode);
                this.inheritParamsAndData(routeState._root);
                return rxjs.of(routeState);
            }
            catch (e) {
                return new rxjs.Observable(function (obs) { return obs.error(e); });
            }
        };
        Recognizer.prototype.inheritParamsAndData = function (routeNode) {
            var _this = this;
            var route = routeNode.value;
            var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
            route.params = Object.freeze(i.params);
            route.data = Object.freeze(i.data);
            routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });
        };
        Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
            if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
                return this.processChildren(config, segmentGroup);
            }
            return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
        };
        Recognizer.prototype.processChildren = function (config, segmentGroup) {
            var _this = this;
            var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
            checkOutletNameUniqueness(children);
            sortActivatedRouteSnapshots(children);
            return children;
        };
        Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
            var e_1, _a;
            try {
                for (var config_1 = __values(config), config_1_1 = config_1.next(); !config_1_1.done; config_1_1 = config_1.next()) {
                    var r = config_1_1.value;
                    try {
                        return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
                    }
                    catch (e) {
                        if (!(e instanceof NoMatch$1))
                            throw e;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (config_1_1 && !config_1_1.done && (_a = config_1.return)) _a.call(config_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                return [];
            }
            throw new NoMatch$1();
        };
        Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
            return segments.length === 0 && !segmentGroup.children[outlet];
        };
        Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
            if (route.redirectTo)
                throw new NoMatch$1();
            if ((route.outlet || PRIMARY_OUTLET) !== outlet)
                throw new NoMatch$1();
            var snapshot;
            var consumedSegments = [];
            var rawSlicedSegments = [];
            if (route.path === '**') {
                var params = segments.length > 0 ? last(segments).parameters : {};
                snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
            }
            else {
                var result = match$1(rawSegment, route, segments);
                consumedSegments = result.consumedSegments;
                rawSlicedSegments = segments.slice(result.lastChild);
                snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
            }
            var childConfig = getChildConfig(route);
            var _a = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                var children_1 = this.processChildren(childConfig, segmentGroup);
                return [new TreeNode(snapshot, children_1)];
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
                return [new TreeNode(snapshot, [])];
            }
            var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
            return [new TreeNode(snapshot, children)];
        };
        return Recognizer;
    }());
    function sortActivatedRouteSnapshots(nodes) {
        nodes.sort(function (a, b) {
            if (a.value.outlet === PRIMARY_OUTLET)
                return -1;
            if (b.value.outlet === PRIMARY_OUTLET)
                return 1;
            return a.value.outlet.localeCompare(b.value.outlet);
        });
    }
    function getChildConfig(route) {
        if (route.children) {
            return route.children;
        }
        if (route.loadChildren) {
            return route._loadedConfig.routes;
        }
        return [];
    }
    function match$1(segmentGroup, route, segments) {
        if (route.path === '') {
            if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
                throw new NoMatch$1();
            }
            return { consumedSegments: [], lastChild: 0, parameters: {} };
        }
        var matcher = route.matcher || defaultUrlMatcher;
        var res = matcher(segments, segmentGroup, route);
        if (!res)
            throw new NoMatch$1();
        var posParams = {};
        forEach(res.posParams, function (v, k) { posParams[k] = v.path; });
        var parameters = res.consumed.length > 0 ? __assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :
            posParams;
        return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
    }
    function checkOutletNameUniqueness(nodes) {
        var names = {};
        nodes.forEach(function (n) {
            var routeWithSameOutletName = names[n.value.outlet];
            if (routeWithSameOutletName) {
                var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
                var c = n.value.url.map(function (s) { return s.toString(); }).join('/');
                throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
            }
            names[n.value.outlet] = n.value;
        });
    }
    function getSourceSegmentGroup(segmentGroup) {
        var s = segmentGroup;
        while (s._sourceSegment) {
            s = s._sourceSegment;
        }
        return s;
    }
    function getPathIndexShift(segmentGroup) {
        var s = segmentGroup;
        var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
        while (s._sourceSegment) {
            s = s._sourceSegment;
            res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
        }
        return res - 1;
    }
    function split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {
        if (slicedSegments.length > 0 &&
            containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
            var s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
            s_1._sourceSegment = segmentGroup;
            s_1._segmentIndexShift = consumedSegments.length;
            return { segmentGroup: s_1, slicedSegments: [] };
        }
        if (slicedSegments.length === 0 &&
            containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
            var s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));
            s_2._sourceSegment = segmentGroup;
            s_2._segmentIndexShift = consumedSegments.length;
            return { segmentGroup: s_2, slicedSegments: slicedSegments };
        }
        var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
        s._sourceSegment = segmentGroup;
        s._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s, slicedSegments: slicedSegments };
    }
    function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
        var e_2, _a;
        var res = {};
        try {
            for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                var r = routes_1_1.value;
                if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
                    var s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    if (relativeLinkResolution === 'legacy') {
                        s._segmentIndexShift = segmentGroup.segments.length;
                    }
                    else {
                        s._segmentIndexShift = consumedSegments.length;
                    }
                    res[getOutlet$1(r)] = s;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return __assign({}, children, res);
    }
    function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
        var e_3, _a;
        var res = {};
        res[PRIMARY_OUTLET] = primarySegment;
        primarySegment._sourceSegment = segmentGroup;
        primarySegment._segmentIndexShift = consumedSegments.length;
        try {
            for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
                var r = routes_2_1.value;
                if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
                    var s = new UrlSegmentGroup([], {});
                    s._sourceSegment = segmentGroup;
                    s._segmentIndexShift = consumedSegments.length;
                    res[getOutlet$1(r)] = s;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    }
    function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
        return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });
    }
    function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
        return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });
    }
    function emptyPathMatch(segmentGroup, slicedSegments, r) {
        if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
            return false;
        }
        return r.path === '' && r.redirectTo === undefined;
    }
    function getOutlet$1(route) {
        return route.outlet || PRIMARY_OUTLET;
    }
    function getData(route) {
        return route.data || {};
    }
    function getResolve(route) {
        return route.resolve || {};
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) { return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution)
                .pipe(operators.map(function (targetSnapshot) { return (__assign({}, t, { targetSnapshot: targetSnapshot })); })); }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function resolveData(paramsInheritanceStrategy, moduleInjector) {
        return function (source) {
            return source.pipe(operators.mergeMap(function (t) {
                var targetSnapshot = t.targetSnapshot, canActivateChecks = t.guards.canActivateChecks;
                if (!canActivateChecks.length) {
                    return rxjs.of(t);
                }
                return rxjs.from(canActivateChecks)
                    .pipe(operators.concatMap(function (check) { return runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector); }), operators.reduce(function (_, __) { return _; }), operators.map(function (_) { return t; }));
            }));
        };
    }
    function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
        var resolve = futureARS._resolve;
        return resolveNode(resolve, futureARS, futureRSS, moduleInjector)
            .pipe(operators.map(function (resolvedData) {
            futureARS._resolvedData = resolvedData;
            futureARS.data = __assign({}, futureARS.data, inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);
            return null;
        }));
    }
    function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
        var keys = Object.keys(resolve);
        if (keys.length === 0) {
            return rxjs.of({});
        }
        if (keys.length === 1) {
            var key_1 = keys[0];
            return getResolver(resolve[key_1], futureARS, futureRSS, moduleInjector)
                .pipe(operators.map(function (value) {
                var _a;
                return _a = {}, _a[key_1] = value, _a;
            }));
        }
        var data = {};
        var runningResolvers$ = rxjs.from(keys).pipe(operators.mergeMap(function (key) {
            return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)
                .pipe(operators.map(function (value) {
                data[key] = value;
                return value;
            }));
        }));
        return runningResolvers$.pipe(operators.last(), operators.map(function () { return data; }));
    }
    function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
        var resolver = getToken(injectionToken, futureARS, moduleInjector);
        return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :
            wrapIntoObservable(resolver(futureARS, futureRSS));
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Perform a side effect through a switchMap for every emission on the source Observable,
     * but return an Observable that is identical to the source. It's essentially the same as
     * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,
     * it will wait before continuing with the original value.
     */
    function switchTap(next) {
        return function (source) {
            return source.pipe(operators.switchMap(function (v) {
                var nextResult = next(v);
                if (nextResult) {
                    return rxjs.from(nextResult).pipe(operators.map(function () { return v; }));
                }
                return rxjs.from([v]);
            }));
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Provides a way to customize when activated routes get reused.
     *
     * @publicApi
     */
    var RouteReuseStrategy = /** @class */ (function () {
        function RouteReuseStrategy() {
        }
        return RouteReuseStrategy;
    }());
    /**
     * Does not detach any subtrees. Reuses routes as long as their route config is the same.
     */
    var DefaultRouteReuseStrategy = /** @class */ (function () {
        function DefaultRouteReuseStrategy() {
        }
        DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
        DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
        DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
        DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
        DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
            return future.routeConfig === curr.routeConfig;
        };
        return DefaultRouteReuseStrategy;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @docsNotRequired
     * @publicApi
     */
    var ROUTES = new core.InjectionToken('ROUTES');
    var RouterConfigLoader = /** @class */ (function () {
        function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
            this.loader = loader;
            this.compiler = compiler;
            this.onLoadStartListener = onLoadStartListener;
            this.onLoadEndListener = onLoadEndListener;
        }
        RouterConfigLoader.prototype.load = function (parentInjector, route) {
            var _this = this;
            if (this.onLoadStartListener) {
                this.onLoadStartListener(route);
            }
            var moduleFactory$ = this.loadModuleFactory(route.loadChildren);
            return moduleFactory$.pipe(operators.map(function (factory) {
                if (_this.onLoadEndListener) {
                    _this.onLoadEndListener(route);
                }
                var module = factory.create(parentInjector);
                return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);
            }));
        };
        RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
            var _this = this;
            if (typeof loadChildren === 'string') {
                return rxjs.from(this.loader.load(loadChildren));
            }
            else {
                return wrapIntoObservable(loadChildren()).pipe(operators.mergeMap(function (t) {
                    if (t instanceof core.NgModuleFactory) {
                        return rxjs.of(t);
                    }
                    else {
                        return rxjs.from(_this.compiler.compileModuleAsync(t));
                    }
                }));
            }
        };
        return RouterConfigLoader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Provides a way to migrate AngularJS applications to Angular.
     *
     * @publicApi
     */
    var UrlHandlingStrategy = /** @class */ (function () {
        function UrlHandlingStrategy() {
        }
        return UrlHandlingStrategy;
    }());
    /**
     * @publicApi
     */
    var DefaultUrlHandlingStrategy = /** @class */ (function () {
        function DefaultUrlHandlingStrategy() {
        }
        DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
        DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
        DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
        return DefaultUrlHandlingStrategy;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function defaultErrorHandler(error) {
        throw error;
    }
    function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
        return urlSerializer.parse('/');
    }
    /**
     * @internal
     */
    function defaultRouterHook(snapshot, runExtras) {
        return rxjs.of(null);
    }
    /**
     * @description
     *
     * An NgModule that provides navigation and URL manipulation capabilities.
     *
     * @see `Route`.
     * @see [Routing and Navigation Guide](guide/router).
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var Router = /** @class */ (function () {
        /**
         * Creates the router service.
         */
        // TODO: vsavkin make internal after the final is out.
        function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
            var _this = this;
            this.rootComponentType = rootComponentType;
            this.urlSerializer = urlSerializer;
            this.rootContexts = rootContexts;
            this.location = location;
            this.config = config;
            this.lastSuccessfulNavigation = null;
            this.currentNavigation = null;
            this.navigationId = 0;
            this.isNgZoneEnabled = false;
            /**
             * An event stream for routing events in this NgModule.
             */
            this.events = new rxjs.Subject();
            /**
             * A handler for navigation errors in this NgModule.
             */
            this.errorHandler = defaultErrorHandler;
            /**
             * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an
             * error due to containing an invalid character. The most common case would be a `%` sign
             * that's not encoded and is not part of a percent encoded sequence.
             */
            this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
            /**
             * True if at least one navigation event has occurred,
             * false otherwise.
             */
            this.navigated = false;
            this.lastSuccessfulId = -1;
            /**
             * Hooks that enable you to pause navigation,
             * either before or after the preactivation phase.
             * Used by `RouterModule`.
             *
             * @internal
             */
            this.hooks = {
                beforePreactivation: defaultRouterHook,
                afterPreactivation: defaultRouterHook
            };
            /**
             * Extracts and merges URLs. Used for AngularJS to Angular migrations.
             */
            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
            /**
             * The strategy for re-using routes.
             */
            this.routeReuseStrategy = new DefaultRouteReuseStrategy();
            /**
             * How to handle a navigation request to the current URL. One of:
             * - `'ignore'` :  The router ignores the request.
             * - `'reload'` : The router reloads the URL. Use to implement a "refresh" feature.
             */
            this.onSameUrlNavigation = 'ignore';
            /**
             * How to merge parameters, data, and resolved data from parent to child
             * routes. One of:
             *
             * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data
             * for path-less or component-less routes.
             * - `'always'` : Inherit parent parameters, data, and resolved data
             * for all child routes.
             */
            this.paramsInheritanceStrategy = 'emptyOnly';
            /**
             * Defines when the router updates the browser URL. The default behavior is to update after
             * successful navigation. However, some applications may prefer a mode where the URL gets
             * updated at the beginning of navigation. The most common use case would be updating the
             * URL early so if navigation fails, you can show an error message with the URL that failed.
             * Available options are:
             *
             * - `'deferred'`, the default, updates the browser URL after navigation has finished.
             * - `'eager'`, updates browser URL at the beginning of navigation.
             */
            this.urlUpdateStrategy = 'deferred';
            /**
             * See {@link RouterModule} for more information.
             */
            this.relativeLinkResolution = 'legacy';
            var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };
            var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };
            this.ngModule = injector.get(core.NgModuleRef);
            this.console = injector.get(core.ɵConsole);
            var ngZone = injector.get(core.NgZone);
            this.isNgZoneEnabled = ngZone instanceof core.NgZone;
            this.resetConfig(config);
            this.currentUrlTree = createEmptyUrlTree();
            this.rawUrlTree = this.currentUrlTree;
            this.browserUrlTree = this.currentUrlTree;
            this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
            this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
            this.transitions = new rxjs.BehaviorSubject({
                id: 0,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
                urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
                rawUrl: this.currentUrlTree,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(true),
                source: 'imperative',
                restoredState: null,
                currentSnapshot: this.routerState.snapshot,
                targetSnapshot: null,
                currentRouterState: this.routerState,
                targetRouterState: null,
                guards: { canActivateChecks: [], canDeactivateChecks: [] },
                guardsResult: null,
            });
            this.navigations = this.setupNavigations(this.transitions);
            this.processNavigations();
        }
        Router.prototype.setupNavigations = function (transitions) {
            var _this = this;
            var eventsSubject = this.events;
            return transitions.pipe(operators.filter(function (t) { return t.id !== 0; }), 
            // Extract URL
            operators.map(function (t) { return (__assign({}, t, { extractedUrl: _this.urlHandlingStrategy.extract(t.rawUrl) })); }), 
            // Using switchMap so we cancel executing navigations when a new one comes in
            operators.switchMap(function (t) {
                var completed = false;
                var errored = false;
                return rxjs.of(t).pipe(
                // Store the Navigation object
                operators.tap(function (t) {
                    _this.currentNavigation = {
                        id: t.id,
                        initialUrl: t.currentRawUrl,
                        extractedUrl: t.extractedUrl,
                        trigger: t.source,
                        extras: t.extras,
                        previousNavigation: _this.lastSuccessfulNavigation ? __assign({}, _this.lastSuccessfulNavigation, { previousNavigation: null }) :
                            null
                    };
                }), operators.switchMap(function (t) {
                    var urlTransition = !_this.navigated || t.extractedUrl.toString() !== _this.browserUrlTree.toString();
                    var processCurrentUrl = (_this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&
                        _this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);
                    if (processCurrentUrl) {
                        return rxjs.of(t).pipe(
                        // Fire NavigationStart event
                        operators.switchMap(function (t) {
                            var transition = _this.transitions.getValue();
                            eventsSubject.next(new NavigationStart(t.id, _this.serializeUrl(t.extractedUrl), t.source, t.restoredState));
                            if (transition !== _this.transitions.getValue()) {
                                return rxjs.EMPTY;
                            }
                            return [t];
                        }), 
                        // This delay is required to match old behavior that forced navigation to
                        // always be async
                        operators.switchMap(function (t) { return Promise.resolve(t); }), 
                        // ApplyRedirects
                        applyRedirects$1(_this.ngModule.injector, _this.configLoader, _this.urlSerializer, _this.config), 
                        // Update the currentNavigation
                        operators.tap(function (t) {
                            _this.currentNavigation = __assign({}, _this.currentNavigation, { finalUrl: t.urlAfterRedirects });
                        }), 
                        // Recognize
                        recognize$1(_this.rootComponentType, _this.config, function (url) { return _this.serializeUrl(url); }, _this.paramsInheritanceStrategy, _this.relativeLinkResolution), 
                        // Update URL if in `eager` update mode
                        operators.tap(function (t) {
                            if (_this.urlUpdateStrategy === 'eager') {
                                if (!t.extras.skipLocationChange) {
                                    _this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state);
                                }
                                _this.browserUrlTree = t.urlAfterRedirects;
                            }
                        }), 
                        // Fire RoutesRecognized
                        operators.tap(function (t) {
                            var routesRecognized = new RoutesRecognized(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            eventsSubject.next(routesRecognized);
                        }));
                    }
                    else {
                        var processPreviousUrl = urlTransition && _this.rawUrlTree &&
                            _this.urlHandlingStrategy.shouldProcessUrl(_this.rawUrlTree);
                        /* When the current URL shouldn't be processed, but the previous one was, we
                         * handle this "error condition" by navigating to the previously successful URL,
                         * but leaving the URL intact.*/
                        if (processPreviousUrl) {
                            var id = t.id, extractedUrl = t.extractedUrl, source = t.source, restoredState = t.restoredState, extras = t.extras;
                            var navStart = new NavigationStart(id, _this.serializeUrl(extractedUrl), source, restoredState);
                            eventsSubject.next(navStart);
                            var targetSnapshot = createEmptyState(extractedUrl, _this.rootComponentType).snapshot;
                            return rxjs.of(__assign({}, t, { targetSnapshot: targetSnapshot, urlAfterRedirects: extractedUrl, extras: __assign({}, extras, { skipLocationChange: false, replaceUrl: false }) }));
                        }
                        else {
                            /* When neither the current or previous URL can be processed, do nothing other
                             * than update router's internal reference to the current "settled" URL. This
                             * way the next navigation will be coming from the current URL in the browser.
                             */
                            _this.rawUrlTree = t.rawUrl;
                            _this.browserUrlTree = t.urlAfterRedirects;
                            t.resolve(null);
                            return rxjs.EMPTY;
                        }
                    }
                }), 
                // Before Preactivation
                switchTap(function (t) {
                    var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                    return _this.hooks.beforePreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl,
                    });
                }), 
                // --- GUARDS ---
                operators.tap(function (t) {
                    var guardsStart = new GuardsCheckStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                    _this.triggerEvent(guardsStart);
                }), operators.map(function (t) { return (__assign({}, t, { guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, _this.rootContexts) })); }), checkGuards(_this.ngModule.injector, function (evt) { return _this.triggerEvent(evt); }), operators.tap(function (t) {
                    if (isUrlTree(t.guardsResult)) {
                        var error = navigationCancelingError("Redirecting to \"" + _this.serializeUrl(t.guardsResult) + "\"");
                        error.url = t.guardsResult;
                        throw error;
                    }
                }), operators.tap(function (t) {
                    var guardsEnd = new GuardsCheckEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                    _this.triggerEvent(guardsEnd);
                }), operators.filter(function (t) {
                    if (!t.guardsResult) {
                        _this.resetUrlToCurrentUrlTree();
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), '');
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                        return false;
                    }
                    return true;
                }), 
                // --- RESOLVE ---
                switchTap(function (t) {
                    if (t.guards.canActivateChecks.length) {
                        return rxjs.of(t).pipe(operators.tap(function (t) {
                            var resolveStart = new ResolveStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            _this.triggerEvent(resolveStart);
                        }), resolveData(_this.paramsInheritanceStrategy, _this.ngModule.injector), //
                        operators.tap(function (t) {
                            var resolveEnd = new ResolveEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                            _this.triggerEvent(resolveEnd);
                        }));
                    }
                    return undefined;
                }), 
                // --- AFTER PREACTIVATION ---
                switchTap(function (t) {
                    var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                    return _this.hooks.afterPreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl,
                    });
                }), operators.map(function (t) {
                    var targetRouterState = createRouterState(_this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
                    return (__assign({}, t, { targetRouterState: targetRouterState }));
                }), 
                /* Once here, we are about to activate syncronously. The assumption is this will
                   succeed, and user code may read from the Router service. Therefore before
                   activation, we need to update router properties storing the current URL and the
                   RouterState, as well as updated the browser URL. All this should happen *before*
                   activating. */
                operators.tap(function (t) {
                    _this.currentUrlTree = t.urlAfterRedirects;
                    _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, t.rawUrl);
                    _this.routerState = t.targetRouterState;
                    if (_this.urlUpdateStrategy === 'deferred') {
                        if (!t.extras.skipLocationChange) {
                            _this.setBrowserUrl(_this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);
                        }
                        _this.browserUrlTree = t.urlAfterRedirects;
                    }
                }), activateRoutes(_this.rootContexts, _this.routeReuseStrategy, function (evt) { return _this.triggerEvent(evt); }), operators.tap({ next: function () { completed = true; }, complete: function () { completed = true; } }), operators.finalize(function () {
                    /* When the navigation stream finishes either through error or success, we set the
                     * `completed` or `errored` flag. However, there are some situations where we could
                     * get here without either of those being set. For instance, a redirect during
                     * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel
                     * event is fired when a navigation gets cancelled but not caught by other means. */
                    if (!completed && !errored) {
                        // Must reset to current URL tree here to ensure history.state is set. On a fresh
                        // page load, if a new navigation comes in before a successful navigation
                        // completes, there will be nothing in history.state.navigationId. This can cause
                        // sync problems with AngularJS sync code which looks for a value here in order
                        // to determine whether or not to handle a given popstate event or to leave it
                        // to the Angualr router.
                        _this.resetUrlToCurrentUrlTree();
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), "Navigation ID " + t.id + " is not equal to the current navigation id " + _this.navigationId);
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                    }
                    // currentNavigation should always be reset to null here. If navigation was
                    // successful, lastSuccessfulTransition will have already been set. Therefore we
                    // can safely set currentNavigation to null here.
                    _this.currentNavigation = null;
                }), operators.catchError(function (e) {
                    errored = true;
                    /* This error type is issued during Redirect, and is handled as a cancellation
                     * rather than an error. */
                    if (isNavigationCancelingError(e)) {
                        var redirecting = isUrlTree(e.url);
                        if (!redirecting) {
                            // Set property only if we're not redirecting. If we landed on a page and
                            // redirect to `/` route, the new navigation is going to see the `/` isn't
                            // a change from the default currentUrlTree and won't navigate. This is
                            // only applicable with initial navigation, so setting `navigated` only when
                            // not redirecting resolves this scenario.
                            _this.navigated = true;
                            _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                        }
                        var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), e.message);
                        eventsSubject.next(navCancel);
                        t.resolve(false);
                        if (redirecting) {
                            _this.navigateByUrl(e.url);
                        }
                        /* All other errors should reset to the router's internal URL reference to the
                         * pre-error state. */
                    }
                    else {
                        _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                        var navError = new NavigationError(t.id, _this.serializeUrl(t.extractedUrl), e);
                        eventsSubject.next(navError);
                        try {
                            t.resolve(_this.errorHandler(e));
                        }
                        catch (ee) {
                            t.reject(ee);
                        }
                    }
                    return rxjs.EMPTY;
                }));
                // TODO(jasonaden): remove cast once g3 is on updated TypeScript
            }));
        };
        /**
         * @internal
         * TODO: this should be removed once the constructor of the router made internal
         */
        Router.prototype.resetRootComponentType = function (rootComponentType) {
            this.rootComponentType = rootComponentType;
            // TODO: vsavkin router 4.0 should make the root component set to null
            // this will simplify the lifecycle of the router.
            this.routerState.root.component = this.rootComponentType;
        };
        Router.prototype.getTransition = function () {
            var transition = this.transitions.value;
            // This value needs to be set. Other values such as extractedUrl are set on initial navigation
            // but the urlAfterRedirects may not get set if we aren't processing the new URL *and* not
            // processing the previous URL.
            transition.urlAfterRedirects = this.browserUrlTree;
            return transition;
        };
        Router.prototype.setTransition = function (t) {
            this.transitions.next(__assign({}, this.getTransition(), t));
        };
        /**
         * Sets up the location change listener and performs the initial navigation.
         */
        Router.prototype.initialNavigation = function () {
            this.setUpLocationChangeListener();
            if (this.navigationId === 0) {
                this.navigateByUrl(this.location.path(true), { replaceUrl: true });
            }
        };
        /**
         * Sets up the location change listener.
         */
        Router.prototype.setUpLocationChangeListener = function () {
            var _this = this;
            // Don't need to use Zone.wrap any more, because zone.js
            // already patch onPopState, so location change callback will
            // run into ngZone
            if (!this.locationSubscription) {
                this.locationSubscription = this.location.subscribe(function (change) {
                    var rawUrlTree = _this.parseUrl(change['url']);
                    var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
                    // Navigations coming from Angular router have a navigationId state property. When this
                    // exists, restore the state.
                    var state = change.state && change.state.navigationId ? change.state : null;
                    setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true }); }, 0);
                });
            }
        };
        Object.defineProperty(Router.prototype, "url", {
            /** The current URL. */
            get: function () { return this.serializeUrl(this.currentUrlTree); },
            enumerable: true,
            configurable: true
        });
        /** The current Navigation object if one exists */
        Router.prototype.getCurrentNavigation = function () { return this.currentNavigation; };
        /** @internal */
        Router.prototype.triggerEvent = function (event) { this.events.next(event); };
        /**
         * Resets the configuration used for navigation and generating links.
         *
         * @param config The route array for the new configuration.
         *
         * @usageNotes
         *
         * ```
         * router.resetConfig([
         *  { path: 'team/:id', component: TeamCmp, children: [
         *    { path: 'simple', component: SimpleCmp },
         *    { path: 'user/:name', component: UserCmp }
         *  ]}
         * ]);
         * ```
         */
        Router.prototype.resetConfig = function (config) {
            validateConfig(config);
            this.config = config.map(standardizeConfig);
            this.navigated = false;
            this.lastSuccessfulId = -1;
        };
        /** @docsNotRequired */
        Router.prototype.ngOnDestroy = function () { this.dispose(); };
        /** Disposes of the router. */
        Router.prototype.dispose = function () {
            if (this.locationSubscription) {
                this.locationSubscription.unsubscribe();
                this.locationSubscription = null;
            }
        };
        /**
         * Applies an array of commands to the current URL tree and creates a new URL tree.
         *
         * When given an activate route, applies the given commands starting from the route.
         * When not given a route, applies the given command starting from the root.
         *
         * @param commands An array of commands to apply.
         * @param navigationExtras
         * @returns The new URL tree.
         *
         * @usageNotes
         *
         * ```
         * // create /team/33/user/11
         * router.createUrlTree(['/team', 33, 'user', 11]);
         *
         * // create /team/33;expand=true/user/11
         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
         *
         * // you can collapse static segments like this (this works only with the first passed-in value):
         * router.createUrlTree(['/team/33/user', userId]);
         *
         * // If the first segment can contain slashes, and you do not want the router to split it, you
         * // can do the following:
         *
         * router.createUrlTree([{segmentPath: '/one/two'}]);
         *
         * // create /team/33/(user/11//right:chat)
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
         *
         * // remove the right secondary node
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
         *
         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
         *
         * // navigate to /team/33/user/11/details
         * router.createUrlTree(['details'], {relativeTo: route});
         *
         * // navigate to /team/33/user/22
         * router.createUrlTree(['../22'], {relativeTo: route});
         *
         * // navigate to /team/44/user/22
         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
         * ```
         */
        Router.prototype.createUrlTree = function (commands, navigationExtras) {
            if (navigationExtras === void 0) { navigationExtras = {}; }
            var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;
            if (core.isDevMode() && preserveQueryParams && console && console.warn) {
                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
            }
            var a = relativeTo || this.routerState.root;
            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;
            var q = null;
            if (queryParamsHandling) {
                switch (queryParamsHandling) {
                    case 'merge':
                        q = __assign({}, this.currentUrlTree.queryParams, queryParams);
                        break;
                    case 'preserve':
                        q = this.currentUrlTree.queryParams;
                        break;
                    default:
                        q = queryParams || null;
                }
            }
            else {
                q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
            }
            if (q !== null) {
                q = this.removeEmptyProps(q);
            }
            return createUrlTree(a, this.currentUrlTree, commands, q, f);
        };
        /**
         * Navigate based on the provided URL, which must be absolute.
         *
         * @param url An absolute URL. The function does not apply any delta to the current URL.
         * @param extras An object containing properties that modify the navigation strategy.
         * The function ignores any properties in the `NavigationExtras` that would change the
         * provided URL.
         *
         * @returns A Promise that resolves to 'true' when navigation succeeds,
         * to 'false' when navigation fails, or is rejected on error.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigateByUrl("/team/33/user/11");
         *
         * // Navigate without updating the URL
         * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
         * ```
         *
         */
        Router.prototype.navigateByUrl = function (url, extras) {
            if (extras === void 0) { extras = { skipLocationChange: false }; }
            if (core.isDevMode() && this.isNgZoneEnabled && !core.NgZone.isInAngularZone()) {
                this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");
            }
            var urlTree = isUrlTree(url) ? url : this.parseUrl(url);
            var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
            return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
        };
        /**
         * Navigate based on the provided array of commands and a starting point.
         * If no starting route is provided, the navigation is absolute.
         *
         * Returns a promise that:
         * - resolves to 'true' when navigation succeeds,
         * - resolves to 'false' when navigation fails,
         * - is rejected when an error happens.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
         *
         * // Navigate without updating the URL
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
         * ```
         *
         * The first parameter of `navigate()` is a delta to be applied to the current URL
         * or the one provided in the `relativeTo` property of the second parameter (the
         * `NavigationExtras`).
         *
         * In order to affect this browser's `history.state` entry, the `state`
         * parameter can be passed. This must be an object because the router
         * will add the `navigationId` property to this object before creating
         * the new history item.
         */
        Router.prototype.navigate = function (commands, extras) {
            if (extras === void 0) { extras = { skipLocationChange: false }; }
            validateCommands(commands);
            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
        };
        /** Serializes a `UrlTree` into a string */
        Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
        /** Parses a string into a `UrlTree` */
        Router.prototype.parseUrl = function (url) {
            var urlTree;
            try {
                urlTree = this.urlSerializer.parse(url);
            }
            catch (e) {
                urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
            }
            return urlTree;
        };
        /** Returns whether the url is activated */
        Router.prototype.isActive = function (url, exact) {
            if (isUrlTree(url)) {
                return containsTree(this.currentUrlTree, url, exact);
            }
            var urlTree = this.parseUrl(url);
            return containsTree(this.currentUrlTree, urlTree, exact);
        };
        Router.prototype.removeEmptyProps = function (params) {
            return Object.keys(params).reduce(function (result, key) {
                var value = params[key];
                if (value !== null && value !== undefined) {
                    result[key] = value;
                }
                return result;
            }, {});
        };
        Router.prototype.processNavigations = function () {
            var _this = this;
            this.navigations.subscribe(function (t) {
                _this.navigated = true;
                _this.lastSuccessfulId = t.id;
                _this.events
                    .next(new NavigationEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(_this.currentUrlTree)));
                _this.lastSuccessfulNavigation = _this.currentNavigation;
                _this.currentNavigation = null;
                t.resolve(true);
            }, function (e) { _this.console.warn("Unhandled Navigation Error: "); });
        };
        Router.prototype.scheduleNavigation = function (rawUrl, source, restoredState, extras) {
            var lastNavigation = this.getTransition();
            // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
            // and that navigation results in 'replaceState' that leads to the same URL,
            // we should skip those.
            if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a popstate was emitted first.
            if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a hashchange was emitted first.
            if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            var resolve = null;
            var reject = null;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var id = ++this.navigationId;
            this.setTransition({
                id: id,
                source: source,
                restoredState: restoredState,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.rawUrlTree, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState
            });
            // Make sure that the error is propagated even though `processNavigations` catch
            // handler does not rethrow
            return promise.catch(function (e) { return Promise.reject(e); });
        };
        Router.prototype.setBrowserUrl = function (url, replaceUrl, id, state) {
            var path = this.urlSerializer.serialize(url);
            state = state || {};
            if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
                // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.
                this.location.replaceState(path, '', __assign({}, state, { navigationId: id }));
            }
            else {
                this.location.go(path, '', __assign({}, state, { navigationId: id }));
            }
        };
        Router.prototype.resetStateAndUrl = function (storedState, storedUrl, rawUrl) {
            this.routerState = storedState;
            this.currentUrlTree = storedUrl;
            this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
            this.resetUrlToCurrentUrlTree();
        };
        Router.prototype.resetUrlToCurrentUrlTree = function () {
            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', { navigationId: this.lastSuccessfulId });
        };
Router.ɵfac = function Router_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
Router.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: Router });

        return Router;
    }());
    function validateCommands(commands) {
        for (var i = 0; i < commands.length; i++) {
            var cmd = commands[i];
            if (cmd == null) {
                throw new Error("The requested path contains " + cmd + " segment at index " + i);
            }
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Lets you link to specific routes in your app.
     *
     * Consider the following route configuration:
     * `[{ path: 'user/:name', component: UserCmp }]`.
     * When linking to this `user/:name` route, you use the `RouterLink` directive.
     *
     * If the link is static, you can use the directive as follows:
     * `<a routerLink="/user/bob">link to user component</a>`
     *
     * If you use dynamic values to generate the link, you can pass an array of path
     * segments, followed by the params for each segment.
     *
     * For instance `['/team', teamId, 'user', userName, {details: true}]`
     * means that we want to generate a link to `/team/11/user/bob;details=true`.
     *
     * Multiple static segments can be merged into one
     * (e.g., `['/team/11/user', userName, {details: true}]`).
     *
     * The first segment name can be prepended with `/`, `./`, or `../`:
     * * If the first segment begins with `/`, the router will look up the route from the root of the
     *   app.
     * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
     *   instead look in the children of the current activated route.
     * * And if the first segment begins with `../`, the router will go up one level.
     *
     * You can set query params and fragment as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
     *   link to user component
     * </a>
     * ```
     * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
     *
     * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
     * directive to preserve the current query params and fragment:
     *
     * ```
     * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
     *   link to user component
     * </a>
     * ```
     *
     * You can tell the directive how to handle queryParams. Available options are:
     *  - `'merge'`: merge the queryParams into the current queryParams
     *  - `'preserve'`: preserve the current queryParams
     *  - default/`''`: use the queryParams only
     *
     * Same options for {@link NavigationExtras#queryParamsHandling
     * NavigationExtras#queryParamsHandling}.
     *
     * ```
     * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
     *   link to user component
     * </a>
     * ```
     *
     * You can provide a `state` value to be persisted to the browser's History.state
     * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's
     * used as follows:
     *
     * ```
     * <a [routerLink]="['/user/bob']" [state]="{tracingId: 123}">
     *   link to user component
     * </a>
     * ```
     *
     * And later the value can be read from the router through `router.getCurrentNavigation`.
     * For example, to capture the `tracingId` above during the `NavigationStart` event:
     *
     * ```
     * // Get NavigationStart events
     * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {
     *   const navigation = router.getCurrentNavigation();
     *   tracingService.trace({id: navigation.extras.state.tracingId});
     * });
     * ```
     *
     * The router link directive always treats the provided input as a delta to the current url.
     *
     * For instance, if the current url is `/user/(box//aux:team)`.
     *
     * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
     * `/user/(jim//aux:team)`.
     *
     * See {@link Router#createUrlTree createUrlTree} for more information.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLink = /** @class */ (function () {
        function RouterLink(router, route, tabIndex, renderer, el) {
            this.router = router;
            this.route = route;
            this.commands = [];
            if (tabIndex == null) {
                renderer.setAttribute(el.nativeElement, 'tabindex', '0');
            }
        }
        Object.defineProperty(RouterLink.prototype, "routerLink", {
            set: function (commands) {
                if (commands != null) {
                    this.commands = Array.isArray(commands) ? commands : [commands];
                }
                else {
                    this.commands = [];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {
            /**
             * @deprecated 4.0.0 use `queryParamsHandling` instead.
             */
            set: function (value) {
                if (core.isDevMode() && console && console.warn) {
                    console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
                }
                this.preserve = value;
            },
            enumerable: true,
            configurable: true
        });
        RouterLink.prototype.onClick = function () {
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
            };
            this.router.navigateByUrl(this.urlTree, extras);
            return true;
        };
        Object.defineProperty(RouterLink.prototype, "urlTree", {
            get: function () {
                return this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    preserveQueryParams: attrBoolValue(this.preserve),
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouterLink.prototype, "queryParams", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RouterLink.prototype, "fragment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RouterLink.prototype, "queryParamsHandling", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLink.prototype, "preserveFragment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLink.prototype, "skipLocationChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLink.prototype, "replaceUrl", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouterLink.prototype, "state", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RouterLink.prototype, "routerLink", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RouterLink.prototype, "preserveQueryParams", null);
        __decorate([
            core.HostListener('click'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", Boolean)
        ], RouterLink.prototype, "onClick", null);
        RouterLink = __decorate([ __param(2, core.Attribute('tabindex')),
            __metadata("design:paramtypes", [Router, ActivatedRoute, String, core.Renderer2, core.ElementRef])
        ], RouterLink);
RouterLink.ɵfac = function RouterLink_Factory(t) { return new (t || RouterLink)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
RouterLink.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLink, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function RouterLink_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLink_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLink, [{
        type: core.Directive,
        args: [{ selector: ':not(a):not(area)[routerLink]' }]
    }], function () { return [{ type: Router }, { type: ActivatedRoute }, { type: String, decorators: [{
                type: core.Attribute,
                args: ['tabindex']
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { routerLink: [{
            type: core.Input
        }], preserveQueryParams: [{
            type: core.Input
        }], onClick: [{
            type: core.HostListener,
            args: ['click']
        }], queryParams: [{
            type: core.Input
        }], fragment: [{
            type: core.Input
        }], queryParamsHandling: [{
            type: core.Input
        }], preserveFragment: [{
            type: core.Input
        }], skipLocationChange: [{
            type: core.Input
        }], replaceUrl: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }] }); })();
        return RouterLink;
    }());
    /**
     * @description
     *
     * Lets you link to specific routes in your app.
     *
     * See `RouterLink` for more information.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLinkWithHref = /** @class */ (function () {
        function RouterLinkWithHref(router, route, locationStrategy) {
            var _this = this;
            this.router = router;
            this.route = route;
            this.locationStrategy = locationStrategy;
            this.commands = [];
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof NavigationEnd) {
                    _this.updateTargetUrlAndHref();
                }
            });
        }
        Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
            set: function (commands) {
                if (commands != null) {
                    this.commands = Array.isArray(commands) ? commands : [commands];
                }
                else {
                    this.commands = [];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {
            set: function (value) {
                if (core.isDevMode() && console && console.warn) {
                    console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
                }
                this.preserve = value;
            },
            enumerable: true,
            configurable: true
        });
        RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
        RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
            if (button !== 0 || ctrlKey || metaKey || shiftKey) {
                return true;
            }
            if (typeof this.target === 'string' && this.target != '_self') {
                return true;
            }
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
                state: this.state
            };
            this.router.navigateByUrl(this.urlTree, extras);
            return false;
        };
        RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
            this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
        };
        Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
            get: function () {
                return this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    preserveQueryParams: attrBoolValue(this.preserve),
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.HostBinding('attr.target'), core.Input(),
            __metadata("design:type", String)
        ], RouterLinkWithHref.prototype, "target", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouterLinkWithHref.prototype, "queryParams", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RouterLinkWithHref.prototype, "fragment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], RouterLinkWithHref.prototype, "queryParamsHandling", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "preserveFragment", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "skipLocationChange", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean)
        ], RouterLinkWithHref.prototype, "replaceUrl", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouterLinkWithHref.prototype, "state", void 0);
        __decorate([
            core.HostBinding(),
            __metadata("design:type", String)
        ], RouterLinkWithHref.prototype, "href", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RouterLinkWithHref.prototype, "routerLink", null);
        __decorate([
            core.Input(),
            __metadata("design:type", Boolean),
            __metadata("design:paramtypes", [Boolean])
        ], RouterLinkWithHref.prototype, "preserveQueryParams", null);
        __decorate([
            core.HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Number, Boolean, Boolean, Boolean]),
            __metadata("design:returntype", Boolean)
        ], RouterLinkWithHref.prototype, "onClick", null);
        RouterLinkWithHref = __decorate([ __metadata("design:paramtypes", [Router, ActivatedRoute,
                common.LocationStrategy])
        ], RouterLinkWithHref);
RouterLinkWithHref.ɵfac = function RouterLinkWithHref_Factory(t) { return new (t || RouterLinkWithHref)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy)); };
RouterLinkWithHref.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkWithHref, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function RouterLinkWithHref_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkWithHref_click_HostBindingHandler($event) { return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("href", ctx.href, ɵngcc0.ɵɵsanitizeUrl);
        ɵngcc0.ɵɵattribute("target", ctx.target);
    } }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkWithHref, [{
        type: core.Directive,
        args: [{ selector: 'a[routerLink],area[routerLink]' }]
    }], function () { return [{ type: Router }, { type: ActivatedRoute }, { type: ɵngcc1.LocationStrategy }]; }, { routerLink: [{
            type: core.Input
        }], preserveQueryParams: [{
            type: core.Input
        }], onClick: [{
            type: core.HostListener,
            args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]
        }], href: [{
            type: core.HostBinding
        }], target: [{
            type: core.HostBinding,
            args: ['attr.target']
        }, {
            type: core.Input
        }], queryParams: [{
            type: core.Input
        }], fragment: [{
            type: core.Input
        }], queryParamsHandling: [{
            type: core.Input
        }], preserveFragment: [{
            type: core.Input
        }], skipLocationChange: [{
            type: core.Input
        }], replaceUrl: [{
            type: core.Input
        }], state: [{
            type: core.Input
        }] }); })();
        return RouterLinkWithHref;
    }());
    function attrBoolValue(s) {
        return s === '' || !!s;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     *
     * @description
     *
     * Lets you add a CSS class to an element when the link's route becomes active.
     *
     * This directive lets you add a CSS class to an element when the link's route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
     * ```
     *
     * When the url is either '/user' or '/user/bob', the active-link class will
     * be added to the `a` tag. If the url changes, the class will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
     * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
     * ```
     *
     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
     * only when the url matches the link exactly.
     *
     * ```
     * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
     * true}">Bob</a>
     * ```
     *
     * You can assign the RouterLinkActive instance to a template variable and directly check
     * the `isActive` status.
     * ```
     * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
     *   Bob {{ rla.isActive ? '(already open)' : ''}}
     * </a>
     * ```
     *
     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
     *   <a routerLink="/user/jim">Jim</a>
     *   <a routerLink="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either '/user/jim' or
     * '/user/bob'.
     *
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterLinkActive = /** @class */ (function () {
        function RouterLinkActive(router, element, renderer, link, linkWithHref) {
            var _this = this;
            this.router = router;
            this.element = element;
            this.renderer = renderer;
            this.link = link;
            this.linkWithHref = linkWithHref;
            this.classes = [];
            this.isActive = false;
            this.routerLinkActiveOptions = { exact: false };
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof NavigationEnd) {
                    _this.update();
                }
            });
        }
        RouterLinkActive.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.links.changes.subscribe(function (_) { return _this.update(); });
            this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
            this.update();
        };
        Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
            set: function (data) {
                var classes = Array.isArray(data) ? data : data.split(' ');
                this.classes = classes.filter(function (c) { return !!c; });
            },
            enumerable: true,
            configurable: true
        });
        RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
        RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterLinkActive.prototype.update = function () {
            var _this = this;
            if (!this.links || !this.linksWithHrefs || !this.router.navigated)
                return;
            Promise.resolve().then(function () {
                var hasActiveLinks = _this.hasActiveLinks();
                if (_this.isActive !== hasActiveLinks) {
                    _this.isActive = hasActiveLinks;
                    _this.classes.forEach(function (c) {
                        if (hasActiveLinks) {
                            _this.renderer.addClass(_this.element.nativeElement, c);
                        }
                        else {
                            _this.renderer.removeClass(_this.element.nativeElement, c);
                        }
                    });
                }
            });
        };
        RouterLinkActive.prototype.isLinkActive = function (router) {
            var _this = this;
            return function (link) {
                return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);
            };
        };
        RouterLinkActive.prototype.hasActiveLinks = function () {
            var isActiveCheckFn = this.isLinkActive(this.router);
            return this.link && isActiveCheckFn(this.link) ||
                this.linkWithHref && isActiveCheckFn(this.linkWithHref) ||
                this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
        };
        __decorate([
            core.ContentChildren(RouterLink, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], RouterLinkActive.prototype, "links", void 0);
        __decorate([
            core.ContentChildren(RouterLinkWithHref, { descendants: true }),
            __metadata("design:type", core.QueryList)
        ], RouterLinkActive.prototype, "linksWithHrefs", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], RouterLinkActive.prototype, "routerLinkActiveOptions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Object])
        ], RouterLinkActive.prototype, "routerLinkActive", null);
        RouterLinkActive = __decorate([ __param(3, core.Optional()),
            __param(4, core.Optional()),
            __metadata("design:paramtypes", [Router, core.ElementRef, core.Renderer2,
                RouterLink,
                RouterLinkWithHref])
        ], RouterLinkActive);
RouterLinkActive.ɵfac = function RouterLinkActive_Factory(t) { return new (t || RouterLinkActive)(ɵngcc0.ɵɵdirectiveInject(Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(RouterLink, 8), ɵngcc0.ɵɵdirectiveInject(RouterLinkWithHref, 8)); };
RouterLinkActive.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterLinkActive, selectors: [["", "routerLinkActive", ""]], contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLink, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkWithHref, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);
    } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterLinkActive, [{
        type: core.Directive,
        args: [{
                selector: '[routerLinkActive]',
                exportAs: 'routerLinkActive'
            }]
    }], function () { return [{ type: Router }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: RouterLink, decorators: [{
                type: core.Optional
            }] }, { type: RouterLinkWithHref, decorators: [{
                type: core.Optional
            }] }]; }, { routerLinkActiveOptions: [{
            type: core.Input
        }], routerLinkActive: [{
            type: core.Input
        }], links: [{
            type: core.ContentChildren,
            args: [RouterLink, { descendants: true }]
        }], linksWithHrefs: [{
            type: core.ContentChildren,
            args: [RouterLinkWithHref, { descendants: true }]
        }] }); })();
        return RouterLinkActive;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Store contextual information about a `RouterOutlet`
     *
     * @publicApi
     */
    var OutletContext = /** @class */ (function () {
        function OutletContext() {
            this.outlet = null;
            this.route = null;
            this.resolver = null;
            this.children = new ChildrenOutletContexts();
            this.attachRef = null;
        }
        return OutletContext;
    }());
    /**
     * Store contextual information about the children (= nested) `RouterOutlet`
     *
     * @publicApi
     */
    var ChildrenOutletContexts = /** @class */ (function () {
        function ChildrenOutletContexts() {
            // contexts for child outlets, by name.
            this.contexts = new Map();
        }
        /** Called when a `RouterOutlet` directive is instantiated */
        ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {
            var context = this.getOrCreateContext(childName);
            context.outlet = outlet;
            this.contexts.set(childName, context);
        };
        /**
         * Called when a `RouterOutlet` directive is destroyed.
         * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
         * re-created later.
         */
        ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {
            var context = this.getContext(childName);
            if (context) {
                context.outlet = null;
            }
        };
        /**
         * Called when the corresponding route is deactivated during navigation.
         * Because the component get destroyed, all children outlet are destroyed.
         */
        ChildrenOutletContexts.prototype.onOutletDeactivated = function () {
            var contexts = this.contexts;
            this.contexts = new Map();
            return contexts;
        };
        ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };
        ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {
            var context = this.getContext(childName);
            if (!context) {
                context = new OutletContext();
                this.contexts.set(childName, context);
            }
            return context;
        };
        ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };
        return ChildrenOutletContexts;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Acts as a placeholder that Angular dynamically fills based on the current router state.
     *
     * ```
     * <router-outlet></router-outlet>
     * <router-outlet name='left'></router-outlet>
     * <router-outlet name='right'></router-outlet>
     * ```
     *
     * A router outlet will emit an activate event any time a new component is being instantiated,
     * and a deactivate event when it is being destroyed.
     *
     * ```
     * <router-outlet
     *   (activate)='onActivate($event)'
     *   (deactivate)='onDeactivate($event)'></router-outlet>
     * ```
     * @ngModule RouterModule
     *
     * @publicApi
     */
    var RouterOutlet = /** @class */ (function () {
        function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
            this.parentContexts = parentContexts;
            this.location = location;
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.activated = null;
            this._activatedRoute = null;
            this.activateEvents = new core.EventEmitter();
            this.deactivateEvents = new core.EventEmitter();
            this.name = name || PRIMARY_OUTLET;
            parentContexts.onChildOutletCreated(this.name, this);
        }
        RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };
        RouterOutlet.prototype.ngOnInit = function () {
            if (!this.activated) {
                // If the outlet was not instantiated at the time the route got activated we need to populate
                // the outlet when it is initialized (ie inside a NgIf)
                var context = this.parentContexts.getContext(this.name);
                if (context && context.route) {
                    if (context.attachRef) {
                        // `attachRef` is populated when there is an existing component to mount
                        this.attach(context.attachRef, context.route);
                    }
                    else {
                        // otherwise the component defined in the configuration is created
                        this.activateWith(context.route, context.resolver || null);
                    }
                }
            }
        };
        Object.defineProperty(RouterOutlet.prototype, "isActivated", {
            get: function () { return !!this.activated; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "component", {
            get: function () {
                if (!this.activated)
                    throw new Error('Outlet is not activated');
                return this.activated.instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
            get: function () {
                if (!this.activated)
                    throw new Error('Outlet is not activated');
                return this._activatedRoute;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {
            get: function () {
                if (this._activatedRoute) {
                    return this._activatedRoute.snapshot.data;
                }
                return {};
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         */
        RouterOutlet.prototype.detach = function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            this.location.detach();
            var cmp = this.activated;
            this.activated = null;
            this._activatedRoute = null;
            return cmp;
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         */
        RouterOutlet.prototype.attach = function (ref, activatedRoute) {
            this.activated = ref;
            this._activatedRoute = activatedRoute;
            this.location.insert(ref.hostView);
        };
        RouterOutlet.prototype.deactivate = function () {
            if (this.activated) {
                var c = this.component;
                this.activated.destroy();
                this.activated = null;
                this._activatedRoute = null;
                this.deactivateEvents.emit(c);
            }
        };
        RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
            if (this.isActivated) {
                throw new Error('Cannot activate an already activated outlet');
            }
            this._activatedRoute = activatedRoute;
            var snapshot = activatedRoute._futureSnapshot;
            var component = snapshot.routeConfig.component;
            resolver = resolver || this.resolver;
            var factory = resolver.resolveComponentFactory(component);
            var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
            var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
            this.activated = this.location.createComponent(factory, this.location.length, injector);
            // Calling `markForCheck` to make sure we will run the change detection when the
            // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
            this.changeDetector.markForCheck();
            this.activateEvents.emit(this.activated.instance);
        };
        __decorate([
            core.Output('activate'),
            __metadata("design:type", Object)
        ], RouterOutlet.prototype, "activateEvents", void 0);
        __decorate([
            core.Output('deactivate'),
            __metadata("design:type", Object)
        ], RouterOutlet.prototype, "deactivateEvents", void 0);
        RouterOutlet = __decorate([ __param(3, core.Attribute('name')),
            __metadata("design:paramtypes", [ChildrenOutletContexts, core.ViewContainerRef,
                core.ComponentFactoryResolver, String, core.ChangeDetectorRef])
        ], RouterOutlet);
RouterOutlet.ɵfac = function RouterOutlet_Factory(t) { return new (t || RouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
RouterOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterOutlet, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterOutlet, [{
        type: core.Directive,
        args: [{ selector: 'router-outlet', exportAs: 'outlet' }]
    }], function () { return [{ type: ChildrenOutletContexts }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: String, decorators: [{
                type: core.Attribute,
                args: ['name']
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { activateEvents: [{
            type: core.Output,
            args: ['activate']
        }], deactivateEvents: [{
            type: core.Output,
            args: ['deactivate']
        }] }); })();
        return RouterOutlet;
    }());
    var OutletInjector = /** @class */ (function () {
        function OutletInjector(route, childContexts, parent) {
            this.route = route;
            this.childContexts = childContexts;
            this.parent = parent;
        }
        OutletInjector.prototype.get = function (token, notFoundValue) {
            if (token === ActivatedRoute) {
                return this.route;
            }
            if (token === ChildrenOutletContexts) {
                return this.childContexts;
            }
            return this.parent.get(token, notFoundValue);
        };
        return OutletInjector;
    }());

    /**
    *@license
    *Copyright Google Inc. All Rights Reserved.
    *
    *Use of this source code is governed by an MIT-style license that can be
    *found in the LICENSE file at https://angular.io/license
    */
    /**
     * @description
     *
     * Provides a preloading strategy.
     *
     * @publicApi
     */
    var PreloadingStrategy = /** @class */ (function () {
        function PreloadingStrategy() {
        }
        return PreloadingStrategy;
    }());
    /**
     * @description
     *
     * Provides a preloading strategy that preloads all modules as quickly as possible.
     *
     * ```
     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
     * ```
     *
     * @publicApi
     */
    var PreloadAllModules = /** @class */ (function () {
        function PreloadAllModules() {
        }
        PreloadAllModules.prototype.preload = function (route, fn) {
            return fn().pipe(operators.catchError(function () { return rxjs.of(null); }));
        };
        return PreloadAllModules;
    }());
    /**
     * @description
     *
     * Provides a preloading strategy that does not preload any modules.
     *
     * This strategy is enabled by default.
     *
     * @publicApi
     */
    var NoPreloading = /** @class */ (function () {
        function NoPreloading() {
        }
        NoPreloading.prototype.preload = function (route, fn) { return rxjs.of(null); };
        return NoPreloading;
    }());
    /**
     * The preloader optimistically loads all router configurations to
     * make navigations into lazily-loaded sections of the application faster.
     *
     * The preloader runs in the background. When the router bootstraps, the preloader
     * starts listening to all navigation events. After every such event, the preloader
     * will check if any configurations can be loaded lazily.
     *
     * If a route is protected by `canLoad` guards, the preloaded will not load it.
     *
     * @publicApi
     */
    var RouterPreloader = /** @class */ (function () {
        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
            this.router = router;
            this.injector = injector;
            this.preloadingStrategy = preloadingStrategy;
            var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };
            var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };
            this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
        }
        RouterPreloader.prototype.setUpPreloading = function () {
            var _this = this;
            this.subscription =
                this.router.events
                    .pipe(operators.filter(function (e) { return e instanceof NavigationEnd; }), operators.concatMap(function () { return _this.preload(); }))
                    .subscribe(function () { });
        };
        RouterPreloader.prototype.preload = function () {
            var ngModule = this.injector.get(core.NgModuleRef);
            return this.processRoutes(ngModule, this.router.config);
        };
        // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If
        // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This
        // should be refactored.
        RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
        RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
            var e_1, _a;
            var res = [];
            try {
                for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                    var route = routes_1_1.value;
                    // we already have the config loaded, just recurse
                    if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                        var childConfig = route._loadedConfig;
                        res.push(this.processRoutes(childConfig.module, childConfig.routes));
                        // no config loaded, fetch the config
                    }
                    else if (route.loadChildren && !route.canLoad) {
                        res.push(this.preloadConfig(ngModule, route));
                        // recurse into children
                    }
                    else if (route.children) {
                        res.push(this.processRoutes(ngModule, route.children));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return rxjs.from(res).pipe(operators.mergeAll(), operators.map(function (_) { return void 0; }));
        };
        RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
            var _this = this;
            return this.preloadingStrategy.preload(route, function () {
                var loaded$ = _this.loader.load(ngModule.injector, route);
                return loaded$.pipe(operators.mergeMap(function (config) {
                    route._loadedConfig = config;
                    return _this.processRoutes(config.module, config.routes);
                }));
            });
        };
        RouterPreloader = __decorate([ __metadata("design:paramtypes", [Router, core.NgModuleFactoryLoader, core.Compiler,
                core.Injector, PreloadingStrategy])
        ], RouterPreloader);
RouterPreloader.ɵfac = function RouterPreloader_Factory(t) { return new (t || RouterPreloader)(ɵngcc0.ɵɵinject(Router), ɵngcc0.ɵɵinject(ɵngcc0.NgModuleFactoryLoader), ɵngcc0.ɵɵinject(ɵngcc0.Compiler), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(PreloadingStrategy)); };
RouterPreloader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterPreloader, factory: function (t) { return RouterPreloader.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterPreloader, [{
        type: core.Injectable
    }], function () { return [{ type: Router }, { type: ɵngcc0.NgModuleFactoryLoader }, { type: ɵngcc0.Compiler }, { type: ɵngcc0.Injector }, { type: PreloadingStrategy }]; }, null); })();
        return RouterPreloader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var RouterScroller = /** @class */ (function () {
        function RouterScroller(router, 
        /** @docsNotRequired */ viewportScroller, options) {
            if (options === void 0) { options = {}; }
            this.router = router;
            this.viewportScroller = viewportScroller;
            this.options = options;
            this.lastId = 0;
            this.lastSource = 'imperative';
            this.restoredId = 0;
            this.store = {};
            // Default both options to 'disabled'
            options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
            options.anchorScrolling = options.anchorScrolling || 'disabled';
        }
        RouterScroller.prototype.init = function () {
            // we want to disable the automatic scrolling because having two places
            // responsible for scrolling results race conditions, especially given
            // that browser don't implement this behavior consistently
            if (this.options.scrollPositionRestoration !== 'disabled') {
                this.viewportScroller.setHistoryScrollRestoration('manual');
            }
            this.routerEventsSubscription = this.createScrollEvents();
            this.scrollEventsSubscription = this.consumeScrollEvents();
        };
        RouterScroller.prototype.createScrollEvents = function () {
            var _this = this;
            return this.router.events.subscribe(function (e) {
                if (e instanceof NavigationStart) {
                    // store the scroll position of the current stable navigations.
                    _this.store[_this.lastId] = _this.viewportScroller.getScrollPosition();
                    _this.lastSource = e.navigationTrigger;
                    _this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
                }
                else if (e instanceof NavigationEnd) {
                    _this.lastId = e.id;
                    _this.scheduleScrollEvent(e, _this.router.parseUrl(e.urlAfterRedirects).fragment);
                }
            });
        };
        RouterScroller.prototype.consumeScrollEvents = function () {
            var _this = this;
            return this.router.events.subscribe(function (e) {
                if (!(e instanceof Scroll))
                    return;
                // a popstate event. The pop state event will always ignore anchor scrolling.
                if (e.position) {
                    if (_this.options.scrollPositionRestoration === 'top') {
                        _this.viewportScroller.scrollToPosition([0, 0]);
                    }
                    else if (_this.options.scrollPositionRestoration === 'enabled') {
                        _this.viewportScroller.scrollToPosition(e.position);
                    }
                    // imperative navigation "forward"
                }
                else {
                    if (e.anchor && _this.options.anchorScrolling === 'enabled') {
                        _this.viewportScroller.scrollToAnchor(e.anchor);
                    }
                    else if (_this.options.scrollPositionRestoration !== 'disabled') {
                        _this.viewportScroller.scrollToPosition([0, 0]);
                    }
                }
            });
        };
        RouterScroller.prototype.scheduleScrollEvent = function (routerEvent, anchor) {
            this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));
        };
        RouterScroller.prototype.ngOnDestroy = function () {
            if (this.routerEventsSubscription) {
                this.routerEventsSubscription.unsubscribe();
            }
            if (this.scrollEventsSubscription) {
                this.scrollEventsSubscription.unsubscribe();
            }
        };
RouterScroller.ɵfac = function RouterScroller_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
RouterScroller.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: RouterScroller });

        return RouterScroller;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Contains a list of directives
     *
     *
     */
    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, ɵEmptyOutletComponent];
    /**
     * @description
     *
     * Is used in DI to configure the router.
     *
     * @publicApi
     */
    var ROUTER_CONFIGURATION = new core.InjectionToken('ROUTER_CONFIGURATION');
    /**
     * @docsNotRequired
     */
    var ROUTER_FORROOT_GUARD = new core.InjectionToken('ROUTER_FORROOT_GUARD');
    var ɵ0 = { enableTracing: false };
    var ROUTER_PROVIDERS = [
        common.Location,
        { provide: UrlSerializer, useClass: DefaultUrlSerializer },
        {
            provide: Router,
            useFactory: setupRouter,
            deps: [
                core.ApplicationRef, UrlSerializer, ChildrenOutletContexts, common.Location, core.Injector,
                core.NgModuleFactoryLoader, core.Compiler, ROUTES, ROUTER_CONFIGURATION,
                [UrlHandlingStrategy, new core.Optional()], [RouteReuseStrategy, new core.Optional()]
            ]
        },
        ChildrenOutletContexts,
        { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
        { provide: core.NgModuleFactoryLoader, useClass: core.SystemJsNgModuleLoader },
        RouterPreloader,
        NoPreloading,
        PreloadAllModules,
        { provide: ROUTER_CONFIGURATION, useValue: ɵ0 },
    ];
    function routerNgProbeToken() {
        return new core.NgProbeToken('Router', Router);
    }
    /**
     * @usageNotes
     *
     * RouterModule can be imported multiple times: once per lazily-loaded bundle.
     * Since the router deals with a global shared resource--location, we cannot have
     * more than one router service active.
     *
     * That is why there are two ways to create the module: `RouterModule.forRoot` and
     * `RouterModule.forChild`.
     *
     * * `forRoot` creates a module that contains all the directives, the given routes, and the router
     *   service itself.
     * * `forChild` creates a module that contains all the directives and the given routes, but does not
     *   include the router service.
     *
     * When registered at the root, the module should be used as follows
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forRoot(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * For submodules and lazy loaded submodules the module should be used as follows:
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @description
     *
     * Adds router directives and providers.
     *
     * Managing state transitions is one of the hardest parts of building applications. This is
     * especially true on the web, where you also need to ensure that the state is reflected in the URL.
     * In addition, we often want to split applications into multiple bundles and load them on demand.
     * Doing this transparently is not trivial.
     *
     * The Angular router solves these problems. Using the router, you can declaratively specify
     * application states, manage state transitions while taking care of the URL, and load bundles on
     * demand.
     *
     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
     * overview of how the router should be used.
     *
     * @publicApi
     */
    var RouterModule = /** @class */ (function () {
        // Note: We are injecting the Router so it gets created eagerly...
        function RouterModule(guard, router) {
        }
        RouterModule_1 = RouterModule;
        /**
         * Creates a module with all the router providers and directives. It also optionally sets up an
         * application listener to perform an initial navigation.
         *
         * Configuration Options:
         *
         * * `enableTracing` Toggles whether the router should log all navigation events to the console.
         * * `useHash` Enables the location strategy that uses the URL fragment instead of the history
         * API.
         * * `initialNavigation` Disables the initial navigation.
         * * `errorHandler` Defines a custom error handler for failed navigations.
         * * `preloadingStrategy` Configures a preloading strategy. See `PreloadAllModules`.
         * * `onSameUrlNavigation` Define what the router should do if it receives a navigation request to
         * the current URL.
         * * `scrollPositionRestoration` Configures if the scroll position needs to be restored when
         * navigating back.
         * * `anchorScrolling` Configures if the router should scroll to the element when the url has a
         * fragment.
         * * `scrollOffset` Configures the scroll offset the router will use when scrolling to an element.
         * * `paramsInheritanceStrategy` Defines how the router merges params, data and resolved data from
         * parent to child routes.
         * * `malformedUriErrorHandler` Defines a custom malformed uri error handler function. This
         * handler is invoked when encodedURI contains invalid character sequences.
         * * `urlUpdateStrategy` Defines when the router updates the browser URL. The default behavior is
         * to update after successful navigation.
         * * `relativeLinkResolution` Enables the correct relative link resolution in components with
         * empty paths.
         *
         * See `ExtraOptions` for more details about the above options.
        */
        RouterModule.forRoot = function (routes, config) {
            return {
                ngModule: RouterModule_1,
                providers: [
                    ROUTER_PROVIDERS,
                    provideRoutes(routes),
                    {
                        provide: ROUTER_FORROOT_GUARD,
                        useFactory: provideForRootGuard,
                        deps: [[Router, new core.Optional(), new core.SkipSelf()]]
                    },
                    { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
                    {
                        provide: common.LocationStrategy,
                        useFactory: provideLocationStrategy,
                        deps: [
                            common.PlatformLocation, [new core.Inject(common.APP_BASE_HREF), new core.Optional()], ROUTER_CONFIGURATION
                        ]
                    },
                    {
                        provide: RouterScroller,
                        useFactory: createRouterScroller,
                        deps: [Router, common.ViewportScroller, ROUTER_CONFIGURATION]
                    },
                    {
                        provide: PreloadingStrategy,
                        useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
                            NoPreloading
                    },
                    { provide: core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },
                    provideRouterInitializer(),
                ],
            };
        };
        /**
         * Creates a module with all the router directives and a provider registering routes.
         */
        RouterModule.forChild = function (routes) {
            return { ngModule: RouterModule_1, providers: [provideRoutes(routes)] };
        };
        var RouterModule_1;
        RouterModule = RouterModule_1 = __decorate([ __param(0, core.Optional()), __param(0, core.Inject(ROUTER_FORROOT_GUARD)), __param(1, core.Optional()),
            __metadata("design:paramtypes", [Object, Router])
        ], RouterModule);
RouterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RouterModule });
RouterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RouterModule_Factory(t) { return new (t || RouterModule)(ɵngcc0.ɵɵinject(ROUTER_FORROOT_GUARD, 8), ɵngcc0.ɵɵinject(Router, 8)); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RouterModule, { declarations: [RouterOutlet,
        RouterLink,
        RouterLinkWithHref,
        RouterLinkActive,
        ɵEmptyOutletComponent], exports: [RouterOutlet,
        RouterLink,
        RouterLinkWithHref,
        RouterLinkActive,
        ɵEmptyOutletComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterModule, [{
        type: core.NgModule,
        args: [{
                declarations: ROUTER_DIRECTIVES,
                exports: ROUTER_DIRECTIVES,
                entryComponents: [ɵEmptyOutletComponent]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [ROUTER_FORROOT_GUARD]
            }] }, { type: Router, decorators: [{
                type: core.Optional
            }] }]; }, null); })();
        return RouterModule;
    }());
    function createRouterScroller(router, viewportScroller, config) {
        if (config.scrollOffset) {
            viewportScroller.setOffset(config.scrollOffset);
        }
        return new RouterScroller(router, viewportScroller, config);
    }
    function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
        if (options === void 0) { options = {}; }
        return options.useHash ? new common.HashLocationStrategy(platformLocationStrategy, baseHref) :
            new common.PathLocationStrategy(platformLocationStrategy, baseHref);
    }
    function provideForRootGuard(router) {
        if (router) {
            throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
        }
        return 'guarded';
    }
    /**
     * @description
     *
     * Registers routes.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)],
     *   providers: [provideRoutes(EXTRA_ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @publicApi
     */
    function provideRoutes(routes) {
        return [
            { provide: core.ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
            { provide: ROUTES, multi: true, useValue: routes },
        ];
    }
    function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
        if (opts === void 0) { opts = {}; }
        var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
        if (urlHandlingStrategy) {
            router.urlHandlingStrategy = urlHandlingStrategy;
        }
        if (routeReuseStrategy) {
            router.routeReuseStrategy = routeReuseStrategy;
        }
        if (opts.errorHandler) {
            router.errorHandler = opts.errorHandler;
        }
        if (opts.malformedUriErrorHandler) {
            router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
        }
        if (opts.enableTracing) {
            var dom_1 = platformBrowser.ɵgetDOM();
            router.events.subscribe(function (e) {
                dom_1.logGroup("Router Event: " + e.constructor.name);
                dom_1.log(e.toString());
                dom_1.log(e);
                dom_1.logGroupEnd();
            });
        }
        if (opts.onSameUrlNavigation) {
            router.onSameUrlNavigation = opts.onSameUrlNavigation;
        }
        if (opts.paramsInheritanceStrategy) {
            router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
        }
        if (opts.urlUpdateStrategy) {
            router.urlUpdateStrategy = opts.urlUpdateStrategy;
        }
        if (opts.relativeLinkResolution) {
            router.relativeLinkResolution = opts.relativeLinkResolution;
        }
        return router;
    }
    function rootRoute(router) {
        return router.routerState.root;
    }
    /**
     * To initialize the router properly we need to do in two steps:
     *
     * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
     * a resolver or a guards executes asynchronously. Second, we need to actually run
     * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
     * hook provided by the router to do that.
     *
     * The router navigation starts, reaches the point when preactivation is done, and then
     * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
     */
    var RouterInitializer = /** @class */ (function () {
        function RouterInitializer(injector) {
            this.injector = injector;
            this.initNavigation = false;
            this.resultOfPreactivationDone = new rxjs.Subject();
        }
        RouterInitializer.prototype.appInitializer = function () {
            var _this = this;
            var p = this.injector.get(common.LOCATION_INITIALIZED, Promise.resolve(null));
            return p.then(function () {
                var resolve = null;
                var res = new Promise(function (r) { return resolve = r; });
                var router = _this.injector.get(Router);
                var opts = _this.injector.get(ROUTER_CONFIGURATION);
                if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
                    resolve(true);
                }
                else if (opts.initialNavigation === 'disabled') {
                    router.setUpLocationChangeListener();
                    resolve(true);
                }
                else if (opts.initialNavigation === 'enabled') {
                    router.hooks.afterPreactivation = function () {
                        // only the initial navigation should be delayed
                        if (!_this.initNavigation) {
                            _this.initNavigation = true;
                            resolve(true);
                            return _this.resultOfPreactivationDone;
                            // subsequent navigations should not be delayed
                        }
                        else {
                            return rxjs.of(null);
                        }
                    };
                    router.initialNavigation();
                }
                else {
                    throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
                }
                return res;
            });
        };
        RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
            var opts = this.injector.get(ROUTER_CONFIGURATION);
            var preloader = this.injector.get(RouterPreloader);
            var routerScroller = this.injector.get(RouterScroller);
            var router = this.injector.get(Router);
            var ref = this.injector.get(core.ApplicationRef);
            if (bootstrappedComponentRef !== ref.components[0]) {
                return;
            }
            if (this.isLegacyEnabled(opts)) {
                router.initialNavigation();
            }
            else if (this.isLegacyDisabled(opts)) {
                router.setUpLocationChangeListener();
            }
            preloader.setUpPreloading();
            routerScroller.init();
            router.resetRootComponentType(ref.componentTypes[0]);
            this.resultOfPreactivationDone.next(null);
            this.resultOfPreactivationDone.complete();
        };
        RouterInitializer.prototype.isLegacyEnabled = function (opts) {
            return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
                opts.initialNavigation === undefined;
        };
        RouterInitializer.prototype.isLegacyDisabled = function (opts) {
            return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
        };
        RouterInitializer = __decorate([ __metadata("design:paramtypes", [core.Injector])
        ], RouterInitializer);
RouterInitializer.ɵfac = function RouterInitializer_Factory(t) { return new (t || RouterInitializer)(ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
RouterInitializer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RouterInitializer, factory: function (t) { return RouterInitializer.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RouterInitializer, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc0.Injector }]; }, null); })();
        return RouterInitializer;
    }());
    function getAppInitializer(r) {
        return r.appInitializer.bind(r);
    }
    function getBootstrapListener(r) {
        return r.bootstrapListener.bind(r);
    }
    /**
     * A token for the router initializer that will be called after the app is bootstrapped.
     *
     * @publicApi
     */
    var ROUTER_INITIALIZER = new core.InjectionToken('Router Initializer');
    function provideRouterInitializer() {
        return [
            RouterInitializer,
            {
                provide: core.APP_INITIALIZER,
                multi: true,
                useFactory: getAppInitializer,
                deps: [RouterInitializer]
            },
            { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
            { provide: core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
        ];
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @publicApi
     */
    var VERSION = new core.Version('8.0.0');

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var AngularFireAuthGuard = (function () {
        function AngularFireAuthGuard(afAuth, router) {
            this.afAuth = afAuth;
            this.router = router;
        }
        AngularFireAuthGuard.prototype.canActivate = function (next, state) {
            var _this = this;
            var authPipeFactory = next.data.authGuardPipe || (function () { return loggedIn; });
            return this.afAuth.user.pipe(operators.take(1), authPipeFactory(next, state), operators.map(function (canActivate) { return typeof canActivate == "boolean" ? canActivate : _this.router.createUrlTree(canActivate); }));
        };
        AngularFireAuthGuard = __decorate$1([ __metadata$1("design:paramtypes", [auth.AngularFireAuth, Router])
        ], AngularFireAuthGuard);
AngularFireAuthGuard.ɵfac = function AngularFireAuthGuard_Factory(t) { return new (t || AngularFireAuthGuard)(ɵngcc0.ɵɵinject(ɵngcc2.AngularFireAuth), ɵngcc0.ɵɵinject(Router)); };
AngularFireAuthGuard.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AngularFireAuthGuard, factory: function (t) { return AngularFireAuthGuard.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireAuthGuard, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc2.AngularFireAuth }, { type: Router }]; }, null); })();
        return AngularFireAuthGuard;
    }());
    var canActivate = function (pipe) { return ({
        canActivate: [AngularFireAuthGuard], data: { authGuardPipe: pipe.name === "" ? pipe : function () { return pipe; } }
    }); };
    var ɵ0$1 = function (user) { return !!user; };
    var loggedIn = operators.map(ɵ0$1);
    var ɵ1 = function (user) { return !!user && !user.isAnonymous; };
    var isNotAnonymous = operators.map(ɵ1);
    var ɵ2 = function (user) { return user ? user.getIdTokenResult() : rxjs.of(null); };
    var idTokenResult = operators.switchMap(ɵ2);
    var ɵ3 = function (user) { return !!user && user.emailVerified; };
    var emailVerified = operators.map(ɵ3);
    var ɵ4 = function (idTokenResult) { return idTokenResult ? idTokenResult.claims : []; };
    var customClaims = rxjs.pipe(idTokenResult, operators.map(ɵ4));
    var hasCustomClaim = function (claim) { return rxjs.pipe(customClaims, operators.map(function (claims) { return claims.hasOwnProperty(claim); })); };
    var redirectUnauthorizedTo = function (redirect) { return rxjs.pipe(loggedIn, operators.map(function (loggedIn) { return loggedIn || redirect; })); };
    var redirectLoggedInTo = function (redirect) { return rxjs.pipe(loggedIn, operators.map(function (loggedIn) { return loggedIn && redirect || true; })); };

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AngularFireAuthGuardModule = (function () {
        function AngularFireAuthGuardModule() {
        }
AngularFireAuthGuardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFireAuthGuardModule });
AngularFireAuthGuardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFireAuthGuardModule_Factory(t) { return new (t || AngularFireAuthGuardModule)(); }, providers: [AngularFireAuthGuard] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFireAuthGuardModule, [{
        type: core.NgModule,
        args: [{
                providers: [AngularFireAuthGuard]
            }]
    }], function () { return []; }, null); })();
        return AngularFireAuthGuardModule;
    }());

    exports.AngularFireAuthGuard = AngularFireAuthGuard;
    exports.canActivate = canActivate;
    exports.loggedIn = loggedIn;
    exports.isNotAnonymous = isNotAnonymous;
    exports.idTokenResult = idTokenResult;
    exports.emailVerified = emailVerified;
    exports.customClaims = customClaims;
    exports.hasCustomClaim = hasCustomClaim;
    exports.redirectUnauthorizedTo = redirectUnauthorizedTo;
    exports.redirectLoggedInTo = redirectLoggedInTo;
    exports.ɵ0 = ɵ0$1;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵ3 = ɵ3;
    exports.ɵ4 = ɵ4;
    exports.AngularFireAuthGuardModule = AngularFireAuthGuardModule;

    Object.defineProperty(exports, '__esModule', { value: true });
exports.RouterOutlet = RouterOutlet;
exports.RouterLink = RouterLink;
exports.RouterLinkWithHref = RouterLinkWithHref;
exports.RouterLinkActive = RouterLinkActive;
exports.ɵEmptyOutletComponent = ɵEmptyOutletComponent;

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC1ndWFyZC51bWQuanMiLCJzb3VyY2VzIjpbImF1dGgtZ3VhcmQudW1kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkpBQTJFO0FBQzNFLGdIQUF5RDtBQUN6RCxpRUFBYTtBQUNiLHdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2dEQUdrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUVXO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FFVztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FLVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBRVc7QUFDWDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztvQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUVXO0FBQ1g7QUFDQTs7Ozs7NExBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFNVztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FFVztBQUNYOzs7Ozt5RUFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUVXO0FBQ1g7Ozs7O2tHQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Z0RBS3VDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7c0RBQWtFO0FBQ2xFO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcycpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9ycycpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2ZpcmUvYXV0aCcpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb21tb24nLCAnQGFuZ3VsYXIvY29yZScsICdyeGpzJywgJ3J4anMvb3BlcmF0b3JzJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInLCAnQGFuZ3VsYXIvZmlyZS9hdXRoJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLmFuZ3VsYXJmaXJlMiA9IGdsb2JhbC5hbmd1bGFyZmlyZTIgfHwge30sIGdsb2JhbC5hbmd1bGFyZmlyZTIuYXV0aF9ndWFyZCA9IHt9KSxnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5yeGpzLGdsb2JhbC5yeGpzLm9wZXJhdG9ycyxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLGdsb2JhbC5hbmd1bGFyZmlyZTIuYXV0aCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsY29tbW9uLGNvcmUscnhqcyxvcGVyYXRvcnMscGxhdGZvcm1Ccm93c2VyLGF1dGgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlIEFuZ3VsYXIgdjguMC4wXG4gICAgICogKGMpIDIwMTAtMjAxOSBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gICAgICogTGljZW5zZTogTUlUXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBCYXNlIGZvciBldmVudHMgdGhlIFJvdXRlciBnb2VzIHRocm91Z2gsIGFzIG9wcG9zZWQgdG8gZXZlbnRzIHRpZWQgdG8gYSBzcGVjaWZpY1xuICAgICAqIFJvdXRlLiBgUm91dGVyRXZlbnRgcyB3aWxsIG9ubHkgYmUgZmlyZWQgb25lIHRpbWUgZm9yIGFueSBnaXZlbiBuYXZpZ2F0aW9uLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIE15U2VydmljZSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgcm91dGVyOiBSb3V0ZXIsIGxvZ2dlcjogTG9nZ2VyKSB7XG4gICAgICogICAgIHJvdXRlci5ldmVudHMucGlwZShcbiAgICAgKiAgICAgICBmaWx0ZXIoZSA9PiBlIGluc3RhbmNlb2YgUm91dGVyRXZlbnQpXG4gICAgICogICAgICkuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAqICAgICAgIGxvZ2dlci5sb2coZS5pZCwgZS51cmwpO1xuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlckV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJFdmVudChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSb3V0ZXJFdmVudDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gc3RhcnRzLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBOYXZpZ2F0aW9uU3RhcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uU3RhcnQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25TdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBuYXZpZ2F0aW9uVHJpZ2dlciwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHJlc3RvcmVkU3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0aW9uVHJpZ2dlciA9PT0gdm9pZCAwKSB7IG5hdmlnYXRpb25UcmlnZ2VyID0gJ2ltcGVyYXRpdmUnOyB9XG4gICAgICAgICAgICBpZiAocmVzdG9yZWRTdGF0ZSA9PT0gdm9pZCAwKSB7IHJlc3RvcmVkU3RhdGUgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubmF2aWdhdGlvblRyaWdnZXIgPSBuYXZpZ2F0aW9uVHJpZ2dlcjtcbiAgICAgICAgICAgIF90aGlzLnJlc3RvcmVkU3RhdGUgPSByZXN0b3JlZFN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIE5hdmlnYXRpb25TdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5hdmlnYXRpb25TdGFydChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicpXCI7IH07XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gZW5kcyBzdWNjZXNzZnVsbHkuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIE5hdmlnYXRpb25FbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uRW5kLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uRW5kKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBpZCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybEFmdGVyUmVkaXJlY3RzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgPSB1cmxBZnRlclJlZGlyZWN0cztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBOYXZpZ2F0aW9uRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5hdmlnYXRpb25FbmQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCB1cmxBZnRlclJlZGlyZWN0czogJ1wiICsgdGhpcy51cmxBZnRlclJlZGlyZWN0cyArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5hdmlnYXRpb25FbmQ7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIG5hdmlnYXRpb24gaXMgY2FuY2VsZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIE5hdmlnYXRpb25DYW5jZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uQ2FuY2VsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uQ2FuY2VsKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBpZCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHJlYXNvbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBOYXZpZ2F0aW9uQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiTmF2aWdhdGlvbkNhbmNlbChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicpXCI7IH07XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uQ2FuY2VsO1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIGZhaWxzIGR1ZSB0byBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBOYXZpZ2F0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhOYXZpZ2F0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5hdmlnYXRpb25FcnJvcihcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBlcnJvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgTmF2aWdhdGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk5hdmlnYXRpb25FcnJvcihpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIGVycm9yOiBcIiArIHRoaXMuZXJyb3IgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5hdmlnYXRpb25FcnJvcjtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHJvdXRlcyBhcmUgcmVjb2duaXplZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVzUmVjb2duaXplZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJvdXRlc1JlY29nbml6ZWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlc1JlY29nbml6ZWQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsQWZ0ZXJSZWRpcmVjdHMsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIFJvdXRlc1JlY29nbml6ZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUm91dGVzUmVjb2duaXplZChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb3V0ZXNSZWNvZ25pemVkO1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIHRoZSBHdWFyZCBwaGFzZSBvZiByb3V0aW5nLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBHdWFyZHNDaGVja1N0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoR3VhcmRzQ2hlY2tTdGFydCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gR3VhcmRzQ2hlY2tTdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpZCwgdXJsKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgPSB1cmxBZnRlclJlZGlyZWN0cztcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgR3VhcmRzQ2hlY2tTdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJHdWFyZHNDaGVja1N0YXJ0KGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEd1YXJkc0NoZWNrU3RhcnQ7XG4gICAgfShSb3V0ZXJFdmVudCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoZSBHdWFyZCBwaGFzZSBvZiByb3V0aW5nLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBHdWFyZHNDaGVja0VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEd1YXJkc0NoZWNrRW5kLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBHdWFyZHNDaGVja0VuZChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgaWQsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmwsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICB1cmxBZnRlclJlZGlyZWN0cywgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHN0YXRlLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc2hvdWxkQWN0aXZhdGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIF90aGlzLnNob3VsZEFjdGl2YXRlID0gc2hvdWxkQWN0aXZhdGU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgR3VhcmRzQ2hlY2tFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiR3VhcmRzQ2hlY2tFbmQoaWQ6IFwiICsgdGhpcy5pZCArIFwiLCB1cmw6ICdcIiArIHRoaXMudXJsICsgXCInLCB1cmxBZnRlclJlZGlyZWN0czogJ1wiICsgdGhpcy51cmxBZnRlclJlZGlyZWN0cyArIFwiJywgc3RhdGU6IFwiICsgdGhpcy5zdGF0ZSArIFwiLCBzaG91bGRBY3RpdmF0ZTogXCIgKyB0aGlzLnNob3VsZEFjdGl2YXRlICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBHdWFyZHNDaGVja0VuZDtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiB0aGUgUmVzb2x2ZSBwaGFzZSBvZiByb3V0aW5nLiBUaGUgdGltaW5nIG9mIHRoaXNcbiAgICAgKiBldmVudCBtYXkgY2hhbmdlLCB0aHVzIGl0J3MgZXhwZXJpbWVudGFsLiBJbiB0aGUgY3VycmVudCBpdGVyYXRpb24gaXQgd2lsbCBydW5cbiAgICAgKiBpbiB0aGUgXCJyZXNvbHZlXCIgcGhhc2Ugd2hldGhlciB0aGVyZSdzIHRoaW5ncyB0byByZXNvbHZlIG9yIG5vdC4gSW4gdGhlIGZ1dHVyZSB0aGlzXG4gICAgICogYmVoYXZpb3IgbWF5IGNoYW5nZSB0byBvbmx5IHJ1biB3aGVuIHRoZXJlIGFyZSB0aGluZ3MgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJlc29sdmVTdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlc29sdmVTdGFydCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUmVzb2x2ZVN0YXJ0KFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBpZCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHVybEFmdGVyUmVkaXJlY3RzLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGlkLCB1cmwpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy51cmxBZnRlclJlZGlyZWN0cyA9IHVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBSZXNvbHZlU3RhcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUmVzb2x2ZVN0YXJ0KGlkOiBcIiArIHRoaXMuaWQgKyBcIiwgdXJsOiAnXCIgKyB0aGlzLnVybCArIFwiJywgdXJsQWZ0ZXJSZWRpcmVjdHM6ICdcIiArIHRoaXMudXJsQWZ0ZXJSZWRpcmVjdHMgKyBcIicsIHN0YXRlOiBcIiArIHRoaXMuc3RhdGUgKyBcIilcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVTdGFydDtcbiAgICB9KFJvdXRlckV2ZW50KSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAgICAgKiBgUmVzb2x2ZVN0YXJ0YCBmb3IgdXNlIG9mIHRoaXMgZXhwZXJpbWVudGFsIEFQSS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUmVzb2x2ZUVuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJlc29sdmVFbmQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVFbmQoXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIGlkLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgdXJsQWZ0ZXJSZWRpcmVjdHMsIFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaWQsIHVybCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnVybEFmdGVyUmVkaXJlY3RzID0gdXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFJlc29sdmVFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUmVzb2x2ZUVuZChpZDogXCIgKyB0aGlzLmlkICsgXCIsIHVybDogJ1wiICsgdGhpcy51cmwgKyBcIicsIHVybEFmdGVyUmVkaXJlY3RzOiAnXCIgKyB0aGlzLnVybEFmdGVyUmVkaXJlY3RzICsgXCInLCBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXNvbHZlRW5kO1xuICAgIH0oUm91dGVyRXZlbnQpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIGJlZm9yZSBsYXp5IGxvYWRpbmcgYSByb3V0ZSBjb25maWcuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlQ29uZmlnTG9hZFN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZUNvbmZpZ0xvYWRTdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgcm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZUNvbmZpZ0xvYWRTdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlJvdXRlQ29uZmlnTG9hZFN0YXJ0KHBhdGg6IFwiICsgdGhpcy5yb3V0ZS5wYXRoICsgXCIpXCI7IH07XG4gICAgICAgIHJldHVybiBSb3V0ZUNvbmZpZ0xvYWRTdGFydDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHJvdXRlIGhhcyBiZWVuIGxhenkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZUNvbmZpZ0xvYWRFbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlQ29uZmlnTG9hZEVuZChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgcm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZUNvbmZpZ0xvYWRFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJSb3V0ZUNvbmZpZ0xvYWRFbmQocGF0aDogXCIgKyB0aGlzLnJvdXRlLnBhdGggKyBcIilcIjsgfTtcbiAgICAgICAgcmV0dXJuIFJvdXRlQ29uZmlnTG9hZEVuZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgZW5kIG9mIHRoZSBSZXNvbHZlIHBoYXNlIG9mIHJvdXRpbmcuIFNlZSBub3RlIG9uXG4gICAgICogYENoaWxkQWN0aXZhdGlvbkVuZGAgZm9yIHVzZSBvZiB0aGlzIGV4cGVyaW1lbnRhbCBBUEkuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIENoaWxkQWN0aXZhdGlvblN0YXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGlsZEFjdGl2YXRpb25TdGFydChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICBDaGlsZEFjdGl2YXRpb25TdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuc25hcHNob3Qucm91dGVDb25maWcgJiYgdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZy5wYXRoIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiQ2hpbGRBY3RpdmF0aW9uU3RhcnQocGF0aDogJ1wiICsgcGF0aCArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENoaWxkQWN0aXZhdGlvblN0YXJ0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAgICAgKiBgQ2hpbGRBY3RpdmF0aW9uU3RhcnRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBDaGlsZEFjdGl2YXRpb25FbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoaWxkQWN0aXZhdGlvbkVuZChcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgICAgfVxuICAgICAgICBDaGlsZEFjdGl2YXRpb25FbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBcIkNoaWxkQWN0aXZhdGlvbkVuZChwYXRoOiAnXCIgKyBwYXRoICsgXCInKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2hpbGRBY3RpdmF0aW9uRW5kO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGFydCBvZiBlbmQgb2YgdGhlIFJlc29sdmUgcGhhc2Ugb2Ygcm91dGluZy4gU2VlIG5vdGUgb25cbiAgICAgKiBgQWN0aXZhdGlvbkVuZGAgZm9yIHVzZSBvZiB0aGlzIGV4cGVyaW1lbnRhbCBBUEkuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIEFjdGl2YXRpb25TdGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGlvblN0YXJ0KFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIEFjdGl2YXRpb25TdGFydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuc25hcHNob3Qucm91dGVDb25maWcgJiYgdGhpcy5zbmFwc2hvdC5yb3V0ZUNvbmZpZy5wYXRoIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiQWN0aXZhdGlvblN0YXJ0KHBhdGg6ICdcIiArIHBhdGggKyBcIicpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY3RpdmF0aW9uU3RhcnQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGVuZCBvZiB0aGUgUmVzb2x2ZSBwaGFzZSBvZiByb3V0aW5nLiBTZWUgbm90ZSBvblxuICAgICAqIGBBY3RpdmF0aW9uU3RhcnRgIGZvciB1c2Ugb2YgdGhpcyBleHBlcmltZW50YWwgQVBJLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBBY3RpdmF0aW9uRW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0aW9uRW5kKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBzbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIEFjdGl2YXRpb25FbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnNuYXBzaG90LnJvdXRlQ29uZmlnICYmIHRoaXMuc25hcHNob3Qucm91dGVDb25maWcucGF0aCB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBcIkFjdGl2YXRpb25FbmQocGF0aDogJ1wiICsgcGF0aCArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRpb25FbmQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBzY3JvbGxpbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFNjcm9sbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2Nyb2xsKFxuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICByb3V0ZXJFdmVudCwgXG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIHBvc2l0aW9uLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi9cbiAgICAgICAgYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlckV2ZW50ID0gcm91dGVyRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgfVxuICAgICAgICBTY3JvbGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24gPyB0aGlzLnBvc2l0aW9uWzBdICsgXCIsIFwiICsgdGhpcy5wb3NpdGlvblsxXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gXCJTY3JvbGwoYW5jaG9yOiAnXCIgKyB0aGlzLmFuY2hvciArIFwiJywgcG9zaXRpb246ICdcIiArIHBvcyArIFwiJylcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjcm9sbDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgaW50ZXJuYWxseSB3aXRoaW4gdGhlIHJvdXRlciB0byBiZSBhIHBsYWNlaG9sZGVyIHdoZW4gYW4gZW1wdHlcbiAgICAgKiByb3V0ZXItb3V0bGV0IGlzIG5lZWRlZC4gRm9yIGV4YW1wbGUsIHdpdGggYSBjb25maWcgc3VjaCBhczpcbiAgICAgKlxuICAgICAqIGB7cGF0aDogJ3BhcmVudCcsIG91dGxldDogJ25hdicsIGNoaWxkcmVuOiBbLi4uXX1gXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byByZW5kZXIsIHRoZXJlIG5lZWRzIHRvIGJlIGEgY29tcG9uZW50IG9uIHRoaXMgY29uZmlnLCB3aGljaCB3aWxsIGRlZmF1bHRcbiAgICAgKiB0byB0aGlzIGBFbXB0eU91dGxldENvbXBvbmVudGAuXG4gICAgICovXG4gICAgdmFyIMm1RW1wdHlPdXRsZXRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIMm1RW1wdHlPdXRsZXRDb21wb25lbnQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgybVFbXB0eU91dGxldENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5Db21wb25lbnQoeyB0ZW1wbGF0ZTogXCI8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XCIgfSlcbiAgICAgICAgXSwgybVFbXB0eU91dGxldENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiDJtUVtcHR5T3V0bGV0Q29tcG9uZW50O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBOYW1lIG9mIHRoZSBwcmltYXJ5IG91dGxldC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUFJJTUFSWV9PVVRMRVQgPSAncHJpbWFyeSc7XG4gICAgdmFyIFBhcmFtc0FzTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQYXJhbXNBc01hcChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSk7IH07XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbMF0gOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBhcmFtc0FzTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhbXNBc01hcC5wcm90b3R5cGUsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGFyYW1zKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJhbXNBc01hcDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBgUGFyYW1zYCBpbnN0YW5jZSB0byBhIGBQYXJhbU1hcGAuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFRvUGFyYW1NYXAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1zQXNNYXAocGFyYW1zKTtcbiAgICB9XG4gICAgdmFyIE5BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SID0gJ25nTmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yJztcbiAgICBmdW5jdGlvbiBuYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBFcnJvcignTmF2aWdhdGlvbkNhbmNlbGluZ0Vycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIGVycm9yW05BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yICYmIGVycm9yW05BVklHQVRJT05fQ0FOQ0VMSU5HX0VSUk9SXTtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyB0aGUgcm91dGUgY29uZmlndXJhdGlvbiAoYHJvdXRlYCkgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTCAoYHNlZ21lbnRzYCkuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFVybE1hdGNoZXIoc2VnbWVudHMsIHNlZ21lbnRHcm91cCwgcm91dGUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcm91dGUucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGUgYWN0dWFsIFVSTCBpcyBzaG9ydGVyIHRoYW4gdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5wYXRoTWF0Y2ggPT09ICdmdWxsJyAmJlxuICAgICAgICAgICAgKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHBhcnRzLmxlbmd0aCA8IHNlZ21lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb25maWcgaXMgbG9uZ2VyIHRoYW4gdGhlIGFjdHVhbCBVUkwgYnV0IHdlIGFyZSBsb29raW5nIGZvciBhIGZ1bGwgbWF0Y2gsIHJldHVybiBudWxsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zUGFyYW1zID0ge307XG4gICAgICAgIC8vIENoZWNrIGVhY2ggY29uZmlnIHBhcnQgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFydHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGlzUGFyYW1ldGVyID0gcGFydC5zdGFydHNXaXRoKCc6Jyk7XG4gICAgICAgICAgICBpZiAoaXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICBwb3NQYXJhbXNbcGFydC5zdWJzdHJpbmcoMSldID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQgIT09IHNlZ21lbnQucGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgVVJMIHBhcnQgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbmZpZywgbm8gbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogc2VnbWVudHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoKSwgcG9zUGFyYW1zOiBwb3NQYXJhbXMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIExvYWRlZFJvdXRlckNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9hZGVkUm91dGVyQ29uZmlnKHJvdXRlcywgbW9kdWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlcyA9IHJvdXRlcztcbiAgICAgICAgICAgIHRoaXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb2FkZWRSb3V0ZXJDb25maWc7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhjb25maWcsIHBhcmVudFBhdGgpIHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkgeyBwYXJlbnRQYXRoID0gJyc7IH1cbiAgICAgICAgLy8gZm9yRWFjaCBkb2Vzbid0IGl0ZXJhdGUgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvdXRlID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgdmFyIGZ1bGxQYXRoID0gZ2V0RnVsbFBhdGgocGFyZW50UGF0aCwgcm91dGUpO1xuICAgICAgICAgICAgdmFsaWRhdGVOb2RlKHJvdXRlLCBmdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVOb2RlKHJvdXRlLCBmdWxsUGF0aCkge1xuICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgZnVsbFBhdGggKyBcIic6IEVuY291bnRlcmVkIHVuZGVmaW5lZCByb3V0ZS5cXG4gICAgICBUaGUgcmVhc29uIG1pZ2h0IGJlIGFuIGV4dHJhIGNvbW1hLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuICAgICAgY29uc3Qgcm91dGVzOiBSb3V0ZXMgPSBbXFxuICAgICAgICB7IHBhdGg6ICcnLCByZWRpcmVjdFRvOiAnL2Rhc2hib2FyZCcsIHBhdGhNYXRjaDogJ2Z1bGwnIH0sXFxuICAgICAgICB7IHBhdGg6ICdkYXNoYm9hcmQnLCAgY29tcG9uZW50OiBEYXNoYm9hcmRDb21wb25lbnQgfSwsIDw8IHR3byBjb21tYXNcXG4gICAgICAgIHsgcGF0aDogJ2RldGFpbC86aWQnLCBjb21wb25lbnQ6IEhlcm9EZXRhaWxDb21wb25lbnQgfVxcbiAgICAgIF07XFxuICAgIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogQXJyYXkgY2Fubm90IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlLmNvbXBvbmVudCAmJiAhcm91dGUuY2hpbGRyZW4gJiYgIXJvdXRlLmxvYWRDaGlsZHJlbiAmJlxuICAgICAgICAgICAgKHJvdXRlLm91dGxldCAmJiByb3V0ZS5vdXRsZXQgIT09IFBSSU1BUllfT1VUTEVUKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBhIGNvbXBvbmVudGxlc3Mgcm91dGUgd2l0aG91dCBjaGlsZHJlbiBvciBsb2FkQ2hpbGRyZW4gY2Fubm90IGhhdmUgYSBuYW1lZCBvdXRsZXQgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gb2Ygcm91dGUgJ1wiICsgZnVsbFBhdGggKyBcIic6IHJlZGlyZWN0VG8gYW5kIGNoaWxkcmVuIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBsb2FkQ2hpbGRyZW4gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBjaGlsZHJlbiBhbmQgbG9hZENoaWxkcmVuIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICYmIHJvdXRlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByZWRpcmVjdFRvIGFuZCBjb21wb25lbnQgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlLnBhdGggJiYgcm91dGUubWF0Y2hlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBwYXRoIGFuZCBtYXRjaGVyIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvID09PSB2b2lkIDAgJiYgIXJvdXRlLmNvbXBvbmVudCAmJiAhcm91dGUuY2hpbGRyZW4gJiYgIXJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBtdXN0IGJlIHByb3ZpZGVkOiBjb21wb25lbnQsIHJlZGlyZWN0VG8sIGNoaWxkcmVuIG9yIGxvYWRDaGlsZHJlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gdm9pZCAwICYmIHJvdXRlLm1hdGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiByb3V0ZXMgbXVzdCBoYXZlIGVpdGhlciBhIHBhdGggb3IgYSBtYXRjaGVyIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdXRlLnBhdGggPT09ICdzdHJpbmcnICYmIHJvdXRlLnBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBvZiByb3V0ZSAnXCIgKyBmdWxsUGF0aCArIFwiJzogcGF0aCBjYW5ub3Qgc3RhcnQgd2l0aCBhIHNsYXNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5wYXRoID09PSAnJyAmJiByb3V0ZS5yZWRpcmVjdFRvICE9PSB2b2lkIDAgJiYgcm91dGUucGF0aE1hdGNoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBcIlRoZSBkZWZhdWx0IHZhbHVlIG9mICdwYXRoTWF0Y2gnIGlzICdwcmVmaXgnLCBidXQgb2Z0ZW4gdGhlIGludGVudCBpcyB0byB1c2UgJ2Z1bGwnLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICd7cGF0aDogXFxcIlwiICsgZnVsbFBhdGggKyBcIlxcXCIsIHJlZGlyZWN0VG86IFxcXCJcIiArIHJvdXRlLnJlZGlyZWN0VG8gKyBcIlxcXCJ9JzogcGxlYXNlIHByb3ZpZGUgJ3BhdGhNYXRjaCcuIFwiICsgZXhwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUucGF0aE1hdGNoICE9PSB2b2lkIDAgJiYgcm91dGUucGF0aE1hdGNoICE9PSAnZnVsbCcgJiYgcm91dGUucGF0aE1hdGNoICE9PSAncHJlZml4Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIG9mIHJvdXRlICdcIiArIGZ1bGxQYXRoICsgXCInOiBwYXRoTWF0Y2ggY2FuIG9ubHkgYmUgc2V0IHRvICdwcmVmaXgnIG9yICdmdWxsJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29uZmlnKHJvdXRlLmNoaWxkcmVuLCBmdWxsUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RnVsbFBhdGgocGFyZW50UGF0aCwgY3VycmVudFJvdXRlKSB7XG4gICAgICAgIGlmICghY3VycmVudFJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50UGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudFBhdGggJiYgIWN1cnJlbnRSb3V0ZS5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50UGF0aCAmJiAhY3VycmVudFJvdXRlLnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRQYXRoICsgXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXBhcmVudFBhdGggJiYgY3VycmVudFJvdXRlLnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Um91dGUucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRQYXRoICsgXCIvXCIgKyBjdXJyZW50Um91dGUucGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhlIGNvbmZpZyBhbmQgYWRkcyBhbnkgZGVmYXVsdCByZXF1aXJlZCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YW5kYXJkaXplQ29uZmlnKHIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gci5jaGlsZHJlbiAmJiByLmNoaWxkcmVuLm1hcChzdGFuZGFyZGl6ZUNvbmZpZyk7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW4gPyBfX2Fzc2lnbih7fSwgciwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgOiBfX2Fzc2lnbih7fSwgcik7XG4gICAgICAgIGlmICghYy5jb21wb25lbnQgJiYgKGNoaWxkcmVuIHx8IGMubG9hZENoaWxkcmVuKSAmJiAoYy5vdXRsZXQgJiYgYy5vdXRsZXQgIT09IFBSSU1BUllfT1VUTEVUKSkge1xuICAgICAgICAgICAgYy5jb21wb25lbnQgPSDJtUVtcHR5T3V0bGV0Q29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGFsbG93RXF1YWxBcnJheXMoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghc2hhbGxvd0VxdWFsKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKGEsIGIpIHtcbiAgICAgICAgLy8gQ2FzdGluZyBPYmplY3Qua2V5cyByZXR1cm4gdmFsdWVzIHRvIGluY2x1ZGUgYHVuZGVmaW5lZGAgYXMgdGhlcmUgYXJlIHNvbWUgY2FzZXNcbiAgICAgICAgLy8gaW4gSUUgMTEgd2hlcmUgdGhpcyBjYW4gaGFwcGVuLiBDYW5ub3QgcHJvdmlkZSBhIHRlc3QgYmVjYXVzZSB0aGUgYmVoYXZpb3Igb25seVxuICAgICAgICAvLyBleGlzdHMgaW4gY2VydGFpbiBjaXJjdW1zdGFuY2VzIGluIElFIDExLCB0aGVyZWZvcmUgZG9pbmcgdGhpcyBjYXN0IGVuc3VyZXMgdGhlXG4gICAgICAgIC8vIGxvZ2ljIGlzIGNvcnJlY3QgZm9yIHdoZW4gdGhpcyBlZGdlIGNhc2UgaXMgaGl0LlxuICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGlmICghazEgfHwgIWsyIHx8IGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgc2luZ2xlLWxldmVsIG5lc3RlZCBhcnJheXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnIpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYSkge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPiAwID8gYVthLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yRWFjaChtYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gbWFwKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobWFwW3Byb3BdLCBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWl0Rm9yTWFwKG9iaiwgZm4pIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5vZih7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhaXRIZWFkID0gW107XG4gICAgICAgIHZhciB3YWl0VGFpbCA9IFtdO1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIGZvckVhY2gob2JqLCBmdW5jdGlvbiAoYSwgaykge1xuICAgICAgICAgICAgdmFyIG1hcHBlZCA9IGZuKGssIGEpLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzW2tdID0gcjsgfSkpO1xuICAgICAgICAgICAgaWYgKGsgPT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgd2FpdEhlYWQucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FpdFRhaWwucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xvc3VyZSBjb21waWxlciBoYXMgcHJvYmxlbSB3aXRoIHVzaW5nIHNwcmVhZCBvcGVyYXRvciBoZXJlLiBTbyBqdXN0IHVzaW5nIEFycmF5LmNvbmNhdC5cbiAgICAgICAgcmV0dXJuIHJ4anMub2YuYXBwbHkobnVsbCwgd2FpdEhlYWQuY29uY2F0KHdhaXRUYWlsKSkucGlwZShvcGVyYXRvcnMuY29uY2F0QWxsKCksIG9wZXJhdG9ycy5sYXN0KCksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzOyB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXBJbnRvT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoY29yZS7JtWlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29yZS7JtWlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIFVzZSBgUHJvbWlzZS5yZXNvbHZlKClgIHRvIHdyYXAgcHJvbWlzZS1saWtlIGluc3RhbmNlcy5cbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGllIHdoZW4gYSBSZXNvbHZlciByZXR1cm5zIGEgQW5ndWxhckpTIGAkcWAgcHJvbWlzZSB0byBjb3JyZWN0bHkgdHJpZ2dlciB0aGVcbiAgICAgICAgICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gcnhqcy5mcm9tKFByb21pc2UucmVzb2x2ZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByeGpzLm9mKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRW1wdHlVcmxUcmVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVybFRyZWUobmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pLCB7fSwgbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zVHJlZShjb250YWluZXIsIGNvbnRhaW5lZSwgZXhhY3QpIHtcbiAgICAgICAgaWYgKGV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXF1YWxRdWVyeVBhcmFtcyhjb250YWluZXIucXVlcnlQYXJhbXMsIGNvbnRhaW5lZS5xdWVyeVBhcmFtcykgJiZcbiAgICAgICAgICAgICAgICBlcXVhbFNlZ21lbnRHcm91cHMoY29udGFpbmVyLnJvb3QsIGNvbnRhaW5lZS5yb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbnNRdWVyeVBhcmFtcyhjb250YWluZXIucXVlcnlQYXJhbXMsIGNvbnRhaW5lZS5xdWVyeVBhcmFtcykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zU2VnbWVudEdyb3VwKGNvbnRhaW5lci5yb290LCBjb250YWluZWUucm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFsUXVlcnlQYXJhbXMoY29udGFpbmVyLCBjb250YWluZWUpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBkb2VzIG5vdCBoYW5kbGUgYXJyYXkgcGFyYW1zIGNvcnJlY3RseS5cbiAgICAgICAgcmV0dXJuIHNoYWxsb3dFcXVhbChjb250YWluZXIsIGNvbnRhaW5lZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFsU2VnbWVudEdyb3Vwcyhjb250YWluZXIsIGNvbnRhaW5lZSkge1xuICAgICAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIuc2VnbWVudHMsIGNvbnRhaW5lZS5zZWdtZW50cykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjb250YWluZXIubnVtYmVyT2ZDaGlsZHJlbiAhPT0gY29udGFpbmVlLm51bWJlck9mQ2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGMgaW4gY29udGFpbmVlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5jaGlsZHJlbltjXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWVxdWFsU2VnbWVudEdyb3Vwcyhjb250YWluZXIuY2hpbGRyZW5bY10sIGNvbnRhaW5lZS5jaGlsZHJlbltjXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1F1ZXJ5UGFyYW1zKGNvbnRhaW5lciwgY29udGFpbmVlKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZG9lcyBub3QgaGFuZGxlIGFycmF5IHBhcmFtcyBjb3JyZWN0bHkuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb250YWluZWUpLmxlbmd0aCA8PSBPYmplY3Qua2V5cyhjb250YWluZXIpLmxlbmd0aCAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGFpbmVlKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb250YWluZWVba2V5XSA9PT0gY29udGFpbmVyW2tleV07IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1NlZ21lbnRHcm91cChjb250YWluZXIsIGNvbnRhaW5lZSkge1xuICAgICAgICByZXR1cm4gY29udGFpbnNTZWdtZW50R3JvdXBIZWxwZXIoY29udGFpbmVyLCBjb250YWluZWUsIGNvbnRhaW5lZS5zZWdtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zU2VnbWVudEdyb3VwSGVscGVyKGNvbnRhaW5lciwgY29udGFpbmVlLCBjb250YWluZWVQYXRocykge1xuICAgICAgICBpZiAoY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCA+IGNvbnRhaW5lZVBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuc2VnbWVudHMuc2xpY2UoMCwgY29udGFpbmVlUGF0aHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxQYXRoKGN1cnJlbnQsIGNvbnRhaW5lZVBhdGhzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVlLmhhc0NoaWxkcmVuKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCA9PT0gY29udGFpbmVlUGF0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIuc2VnbWVudHMsIGNvbnRhaW5lZVBhdGhzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBjIGluIGNvbnRhaW5lZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyLmNoaWxkcmVuW2NdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluc1NlZ21lbnRHcm91cChjb250YWluZXIuY2hpbGRyZW5bY10sIGNvbnRhaW5lZS5jaGlsZHJlbltjXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZWVQYXRocy5zbGljZSgwLCBjb250YWluZXIuc2VnbWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY29udGFpbmVlUGF0aHMuc2xpY2UoY29udGFpbmVyLnNlZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsUGF0aChjb250YWluZXIuc2VnbWVudHMsIGN1cnJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNTZWdtZW50R3JvdXBIZWxwZXIoY29udGFpbmVyLmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSwgY29udGFpbmVlLCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHBhcnNlZCBVUkwuXG4gICAgICpcbiAgICAgKiBTaW5jZSBhIHJvdXRlciBzdGF0ZSBpcyBhIHRyZWUsIGFuZCB0aGUgVVJMIGlzIG5vdGhpbmcgYnV0IGEgc2VyaWFsaXplZCBzdGF0ZSwgdGhlIFVSTCBpcyBhXG4gICAgICogc2VyaWFsaXplZCB0cmVlLlxuICAgICAqIFVybFRyZWUgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IHByb3ZpZGVzIGEgbG90IG9mIGFmZm9yZGFuY2VzIGluIGRlYWxpbmcgd2l0aCBVUkxzXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICAgICAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyKSB7XG4gICAgICogICAgIGNvbnN0IHRyZWU6IFVybFRyZWUgPVxuICAgICAqICAgICAgIHJvdXRlci5wYXJzZVVybCgnL3RlYW0vMzMvKHVzZXIvdmljdG9yLy9zdXBwb3J0OmhlbHApP2RlYnVnPXRydWUjZnJhZ21lbnQnKTtcbiAgICAgKiAgICAgY29uc3QgZiA9IHRyZWUuZnJhZ21lbnQ7IC8vIHJldHVybiAnZnJhZ21lbnQnXG4gICAgICogICAgIGNvbnN0IHEgPSB0cmVlLnF1ZXJ5UGFyYW1zOyAvLyByZXR1cm5zIHtkZWJ1ZzogJ3RydWUnfVxuICAgICAqICAgICBjb25zdCBnOiBVcmxTZWdtZW50R3JvdXAgPSB0cmVlLnJvb3QuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdO1xuICAgICAqICAgICBjb25zdCBzOiBVcmxTZWdtZW50W10gPSBnLnNlZ21lbnRzOyAvLyByZXR1cm5zIDIgc2VnbWVudHMgJ3RlYW0nIGFuZCAnMzMnXG4gICAgICogICAgIGcuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdLnNlZ21lbnRzOyAvLyByZXR1cm5zIDIgc2VnbWVudHMgJ3VzZXInIGFuZCAndmljdG9yJ1xuICAgICAqICAgICBnLmNoaWxkcmVuWydzdXBwb3J0J10uc2VnbWVudHM7IC8vIHJldHVybiAxIHNlZ21lbnQgJ2hlbHAnXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBVcmxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIGZ1bmN0aW9uIFVybFRyZWUoXG4gICAgICAgIC8qKiBUaGUgcm9vdCBzZWdtZW50IGdyb3VwIG9mIHRoZSBVUkwgdHJlZSAqL1xuICAgICAgICByb290LCBcbiAgICAgICAgLyoqIFRoZSBxdWVyeSBwYXJhbXMgb2YgdGhlIFVSTCAqL1xuICAgICAgICBxdWVyeVBhcmFtcywgXG4gICAgICAgIC8qKiBUaGUgZnJhZ21lbnQgb2YgdGhlIFVSTCAqL1xuICAgICAgICBmcmFnbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsVHJlZS5wcm90b3R5cGUsIFwicXVlcnlQYXJhbU1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3F1ZXJ5UGFyYW1NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbU1hcCA9IGNvbnZlcnRUb1BhcmFtTWFwKHRoaXMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnlQYXJhbU1hcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBVcmxUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERFRkFVTFRfU0VSSUFMSVpFUi5zZXJpYWxpemUodGhpcyk7IH07XG4gICAgICAgIHJldHVybiBVcmxUcmVlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBwYXJzZWQgVVJMIHNlZ21lbnQgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBTZWUgYFVybFRyZWVgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBVcmxTZWdtZW50R3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFVybFNlZ21lbnRHcm91cChcbiAgICAgICAgLyoqIFRoZSBVUkwgc2VnbWVudHMgb2YgdGhpcyBncm91cC4gU2VlIGBVcmxTZWdtZW50YCBmb3IgbW9yZSBpbmZvcm1hdGlvbiAqL1xuICAgICAgICBzZWdtZW50cywgXG4gICAgICAgIC8qKiBUaGUgbGlzdCBvZiBjaGlsZHJlbiBvZiB0aGlzIGdyb3VwICovXG4gICAgICAgIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgLyoqIFRoZSBwYXJlbnQgbm9kZSBpbiB0aGUgdXJsIHRyZWUgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiB2LnBhcmVudCA9IF90aGlzOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogV2hldGhlciB0aGUgc2VnbWVudCBoYXMgY2hpbGQgc2VnbWVudHMgKi9cbiAgICAgICAgVXJsU2VnbWVudEdyb3VwLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubnVtYmVyT2ZDaGlsZHJlbiA+IDA7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmxTZWdtZW50R3JvdXAucHJvdG90eXBlLCBcIm51bWJlck9mQ2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgLyoqIE51bWJlciBvZiBjaGlsZCBzZWdtZW50cyAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNoaWxkcmVuKS5sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBVcmxTZWdtZW50R3JvdXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VyaWFsaXplUGF0aHModGhpcyk7IH07XG4gICAgICAgIHJldHVybiBVcmxTZWdtZW50R3JvdXA7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgVVJMIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBBIFVybFNlZ21lbnQgaXMgYSBwYXJ0IG9mIGEgVVJMIGJldHdlZW4gdGhlIHR3byBzbGFzaGVzLiBJdCBjb250YWlucyBhIHBhdGggYW5kIHRoZSBtYXRyaXhcbiAgICAgKiBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2VnbWVudC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICrCoCMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICAgICAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyKSB7XG4gICAgICogICAgIGNvbnN0IHRyZWU6IFVybFRyZWUgPSByb3V0ZXIucGFyc2VVcmwoJy90ZWFtO2lkPTMzJyk7XG4gICAgICogICAgIGNvbnN0IGc6IFVybFNlZ21lbnRHcm91cCA9IHRyZWUucm9vdC5jaGlsZHJlbltQUklNQVJZX09VVExFVF07XG4gICAgICogICAgIGNvbnN0IHM6IFVybFNlZ21lbnRbXSA9IGcuc2VnbWVudHM7XG4gICAgICogICAgIHNbMF0ucGF0aDsgLy8gcmV0dXJucyAndGVhbSdcbiAgICAgKiAgICAgc1swXS5wYXJhbWV0ZXJzOyAvLyByZXR1cm5zIHtpZDogMzN9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBVcmxTZWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcmxTZWdtZW50KFxuICAgICAgICAvKiogVGhlIHBhdGggcGFydCBvZiBhIFVSTCBzZWdtZW50ICovXG4gICAgICAgIHBhdGgsIFxuICAgICAgICAvKiogVGhlIG1hdHJpeCBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBhIHNlZ21lbnQgKi9cbiAgICAgICAgcGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybFNlZ21lbnQucHJvdG90eXBlLCBcInBhcmFtZXRlck1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhcmFtZXRlck1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbWV0ZXJNYXAgPSBjb252ZXJ0VG9QYXJhbU1hcCh0aGlzLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyTWFwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAZG9jc05vdFJlcXVpcmVkICovXG4gICAgICAgIFVybFNlZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VyaWFsaXplUGF0aCh0aGlzKTsgfTtcbiAgICAgICAgcmV0dXJuIFVybFNlZ21lbnQ7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBlcXVhbFNlZ21lbnRzKGFzLCBicykge1xuICAgICAgICByZXR1cm4gZXF1YWxQYXRoKGFzLCBicykgJiYgYXMuZXZlcnkoZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIHNoYWxsb3dFcXVhbChhLnBhcmFtZXRlcnMsIGJzW2ldLnBhcmFtZXRlcnMpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxQYXRoKGFzLCBicykge1xuICAgICAgICBpZiAoYXMubGVuZ3RoICE9PSBicy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBhcy5ldmVyeShmdW5jdGlvbiAoYSwgaSkgeyByZXR1cm4gYS5wYXRoID09PSBic1tpXS5wYXRoOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwQ2hpbGRyZW5JbnRvQXJyYXkoc2VnbWVudCwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKHNlZ21lbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRPdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGZuKGNoaWxkLCBjaGlsZE91dGxldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkT3V0bGV0KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRPdXRsZXQgIT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChmbihjaGlsZCwgY2hpbGRPdXRsZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogU2VyaWFsaXplcyBhbmQgZGVzZXJpYWxpemVzIGEgVVJMIHN0cmluZyBpbnRvIGEgVVJMIHRyZWUuXG4gICAgICpcbiAgICAgKiBUaGUgdXJsIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kgaXMgY3VzdG9taXphYmxlLiBZb3UgY2FuXG4gICAgICogbWFrZSBhbGwgVVJMcyBjYXNlIGluc2Vuc2l0aXZlIGJ5IHByb3ZpZGluZyBhIGN1c3RvbSBVcmxTZXJpYWxpemVyLlxuICAgICAqXG4gICAgICogU2VlIGBEZWZhdWx0VXJsU2VyaWFsaXplcmAgZm9yIGFuIGV4YW1wbGUgb2YgYSBVUkwgc2VyaWFsaXplci5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgVXJsU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVXJsU2VyaWFsaXplcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXJsU2VyaWFsaXplcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBgVXJsU2VyaWFsaXplcmAuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIFVSTHM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvaW5ib3gvMzMocG9wdXA6Y29tcG9zZSlcbiAgICAgKiAvaW5ib3gvMzM7b3Blbj10cnVlL21lc3NhZ2VzLzQ0XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBEZWZhdWx0VXJsU2VyaWFsaXplciB1c2VzIHBhcmVudGhlc2VzIHRvIHNlcmlhbGl6ZSBzZWNvbmRhcnkgc2VnbWVudHMgKGUuZy4sIHBvcHVwOmNvbXBvc2UpLCB0aGVcbiAgICAgKiBjb2xvbiBzeW50YXggdG8gc3BlY2lmeSB0aGUgb3V0bGV0LCBhbmQgdGhlICc7cGFyYW1ldGVyPXZhbHVlJyBzeW50YXggKGUuZy4sIG9wZW49dHJ1ZSkgdG9cbiAgICAgKiBzcGVjaWZ5IHJvdXRlIHNwZWNpZmljIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRVcmxTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0VXJsU2VyaWFsaXplcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKiogUGFyc2VzIGEgdXJsIGludG8gYSBgVXJsVHJlZWAgKi9cbiAgICAgICAgRGVmYXVsdFVybFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgVXJsUGFyc2VyKHVybCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFRyZWUocC5wYXJzZVJvb3RTZWdtZW50KCksIHAucGFyc2VRdWVyeVBhcmFtcygpLCBwLnBhcnNlRnJhZ21lbnQoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDb252ZXJ0cyBhIGBVcmxUcmVlYCBpbnRvIGEgdXJsICovXG4gICAgICAgIERlZmF1bHRVcmxTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAodHJlZSkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBcIi9cIiArIHNlcmlhbGl6ZVNlZ21lbnQodHJlZS5yb290LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHRyZWUucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdHlwZW9mIHRyZWUuZnJhZ21lbnQgPT09IFwic3RyaW5nXCIgPyBcIiNcIiArIGVuY29kZVVyaUZyYWdtZW50KHRyZWUuZnJhZ21lbnQpIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHNlZ21lbnQgKyBxdWVyeSArIGZyYWdtZW50O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdFVybFNlcmlhbGl6ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgREVGQVVMVF9TRVJJQUxJWkVSID0gbmV3IERlZmF1bHRVcmxTZXJpYWxpemVyKCk7XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplUGF0aHMoc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudC5zZWdtZW50cy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHNlcmlhbGl6ZVBhdGgocCk7IH0pLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplU2VnbWVudChzZWdtZW50LCByb290KSB7XG4gICAgICAgIGlmICghc2VnbWVudC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUGF0aHMoc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBwcmltYXJ5ID0gc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0gP1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZVNlZ21lbnQoc2VnbWVudC5jaGlsZHJlbltQUklNQVJZX09VVExFVF0sIGZhbHNlKSA6XG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IFtdO1xuICAgICAgICAgICAgZm9yRWFjaChzZWdtZW50LmNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIGlmIChrICE9PSBQUklNQVJZX09VVExFVCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbl8xLnB1c2goayArIFwiOlwiICsgc2VyaWFsaXplU2VnbWVudCh2LCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuXzEubGVuZ3RoID4gMCA/IHByaW1hcnkgKyBcIihcIiArIGNoaWxkcmVuXzEuam9pbignLy8nKSArIFwiKVwiIDogcHJpbWFyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG1hcENoaWxkcmVuSW50b0FycmF5KHNlZ21lbnQsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2VyaWFsaXplU2VnbWVudChzZWdtZW50LmNoaWxkcmVuW1BSSU1BUllfT1VUTEVUXSwgZmFsc2UpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrICsgXCI6XCIgKyBzZXJpYWxpemVTZWdtZW50KHYsIGZhbHNlKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVQYXRocyhzZWdtZW50KSArIFwiLyhcIiArIGNoaWxkcmVuLmpvaW4oJy8vJykgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgVVJJIHN0cmluZyB3aXRoIHRoZSBkZWZhdWx0IGVuY29kaW5nLiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBldmVyIGJlIGNhbGxlZCBmcm9tXG4gICAgICogYGVuY29kZVVyaVF1ZXJ5YCBvciBgZW5jb2RlVXJpU2VnbWVudGAgYXMgaXQncyB0aGUgYmFzZSBzZXQgb2YgZW5jb2RpbmdzIHRvIGJlIHVzZWQuIFdlIG5lZWRcbiAgICAgKiBhIGN1c3RvbSBlbmNvZGluZyBiZWNhdXNlIGVuY29kZVVSSUNvbXBvbmVudCBpcyB0b28gYWdncmVzc2l2ZSBhbmQgZW5jb2RlcyBzdHVmZiB0aGF0IGRvZXNuJ3RcbiAgICAgKiBoYXZlIHRvIGJlIGVuY29kZWQgcGVyIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlTdHJpbmcocykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHMpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTQwL2csICdAJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvZ2ksICc6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lMjQvZywgJyQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUyQy9naSwgJywnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgYm90aCBrZXlzIGFuZCB2YWx1ZXMgaW4gYSBxdWVyeSBzdHJpbmcga2V5L3ZhbHVlLiBJblxuICAgICAqIHRoZSBmb2xsb3dpbmcgVVJMLCB5b3UgbmVlZCB0byBjYWxsIGVuY29kZVVyaVF1ZXJ5IG9uIFwia1wiIGFuZCBcInZcIjpcbiAgICAgKlxuICAgICAqIGh0dHA6Ly93d3cuc2l0ZS5vcmcvaHRtbDttaz1tdj9rPXYjZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZVVyaVF1ZXJ5KHMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVyaVN0cmluZyhzKS5yZXBsYWNlKC8lM0IvZ2ksICc7Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGEgVVJMIGZyYWdtZW50LiBJbiB0aGUgZm9sbG93aW5nIFVSTCwgeW91IG5lZWQgdG8gY2FsbFxuICAgICAqIGVuY29kZVVyaUZyYWdtZW50IG9uIFwiZlwiOlxuICAgICAqXG4gICAgICogaHR0cDovL3d3dy5zaXRlLm9yZy9odG1sO21rPW12P2s9diNmXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlVXJpRnJhZ21lbnQocykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJKHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBydW4gb24gYW55IFVSSSBzZWdtZW50IGFzIHdlbGwgYXMgdGhlIGtleSBhbmQgdmFsdWUgaW4gYSBrZXkvdmFsdWVcbiAgICAgKiBwYWlyIGZvciBtYXRyaXggcGFyYW1zLiBJbiB0aGUgZm9sbG93aW5nIFVSTCwgeW91IG5lZWQgdG8gY2FsbCBlbmNvZGVVcmlTZWdtZW50IG9uIFwiaHRtbFwiLFxuICAgICAqIFwibWtcIiwgYW5kIFwibXZcIjpcbiAgICAgKlxuICAgICAqIGh0dHA6Ly93d3cuc2l0ZS5vcmcvaHRtbDttaz1tdj9rPXYjZlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZVVyaVNlZ21lbnQocykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVXJpU3RyaW5nKHMpLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKS5yZXBsYWNlKC8lMjYvZ2ksICcmJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocyk7XG4gICAgfVxuICAgIC8vIFF1ZXJ5IGtleXMvdmFsdWVzIHNob3VsZCBoYXZlIHRoZSBcIitcIiByZXBsYWNlZCBmaXJzdCwgYXMgXCIrXCIgaW4gYSBxdWVyeSBzdHJpbmcgaXMgXCIgXCIuXG4gICAgLy8gZGVjb2RlVVJJQ29tcG9uZW50IGZ1bmN0aW9uIHdpbGwgbm90IGRlY29kZSBcIitcIiBhcyBhIHNwYWNlLlxuICAgIGZ1bmN0aW9uIGRlY29kZVF1ZXJ5KHMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZShzLnJlcGxhY2UoL1xcKy9nLCAnJTIwJykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBlbmNvZGVVcmlTZWdtZW50KHBhdGgucGF0aCkgKyBzZXJpYWxpemVNYXRyaXhQYXJhbXMocGF0aC5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTWF0cml4UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBcIjtcIiArIGVuY29kZVVyaVNlZ21lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVXJpU2VnbWVudChwYXJhbXNba2V5XSk7IH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHBhcmFtcykge1xuICAgICAgICB2YXIgc3RyUGFyYW1zID0gT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/XG4gICAgICAgICAgICAgICAgdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBlbmNvZGVVcmlRdWVyeShuYW1lKSArIFwiPVwiICsgZW5jb2RlVXJpUXVlcnkodik7IH0pLmpvaW4oJyYnKSA6XG4gICAgICAgICAgICAgICAgZW5jb2RlVXJpUXVlcnkobmFtZSkgKyBcIj1cIiArIGVuY29kZVVyaVF1ZXJ5KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJQYXJhbXMubGVuZ3RoID8gXCI/XCIgKyBzdHJQYXJhbXMuam9pbihcIiZcIikgOiAnJztcbiAgICB9XG4gICAgdmFyIFNFR01FTlRfUkUgPSAvXlteXFwvKCk/Oz0jXSsvO1xuICAgIGZ1bmN0aW9uIG1hdGNoU2VnbWVudHMoc3RyKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChTRUdNRU5UX1JFKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgICB9XG4gICAgdmFyIFFVRVJZX1BBUkFNX1JFID0gL15bXj0/JiNdKy87XG4gICAgLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBxdWVyeSBwYXJhbSBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZyBvciBhbiBlbXB0eSBzdHJpbmdcbiAgICBmdW5jdGlvbiBtYXRjaFF1ZXJ5UGFyYW1zKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goUVVFUllfUEFSQU1fUkUpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH1cbiAgICB2YXIgUVVFUllfUEFSQU1fVkFMVUVfUkUgPSAvXltePyYjXSsvO1xuICAgIC8vIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHF1ZXJ5IHBhcmFtIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nIG9yIGFuIGVtcHR5IHN0cmluZ1xuICAgIGZ1bmN0aW9uIG1hdGNoVXJsUXVlcnlQYXJhbVZhbHVlKHN0cikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goUVVFUllfUEFSQU1fVkFMVUVfUkUpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH1cbiAgICB2YXIgVXJsUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcmxQYXJzZXIodXJsKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VSb290U2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZU9wdGlvbmFsKCcvJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcgPT09ICcnIHx8IHRoaXMucGVla1N0YXJ0c1dpdGgoJz8nKSB8fCB0aGlzLnBlZWtTdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIHJvb3Qgc2VnbWVudCBncm91cCBuZXZlciBoYXMgc2VnbWVudHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB0aGlzLnBhcnNlQ2hpbGRyZW4oKSk7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGFyc2VRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbCgnPycpKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUXVlcnlQYXJhbShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsKCcmJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfTtcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZU9wdGlvbmFsKCcjJykgPyBkZWNvZGVVUklDb21wb25lbnQodGhpcy5yZW1haW5pbmcpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVtYWluaW5nID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZU9wdGlvbmFsKCcvJyk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wZWVrU3RhcnRzV2l0aCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh0aGlzLnBhcnNlU2VnbWVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlZWtTdGFydHNXaXRoKCcvJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8vJykgJiYgIXRoaXMucGVla1N0YXJ0c1dpdGgoJy8oJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUoJy8nKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHRoaXMucGFyc2VTZWdtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aCgnLygnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnLycpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wYXJzZVBhcmVucyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtTdGFydHNXaXRoKCcoJykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlUGFyZW5zKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAwIHx8IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzW1BSSU1BUllfT1VUTEVUXSA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudHMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBhcnNlIGEgc2VnbWVudCB3aXRoIGl0cyBtYXRyaXggcGFyYW1ldGVyc1xuICAgICAgICAvLyBpZSBgbmFtZTtrMT12MTtrMmBcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG1hdGNoU2VnbWVudHModGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgaWYgKHBhdGggPT09ICcnICYmIHRoaXMucGVla1N0YXJ0c1dpdGgoJzsnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHBhdGggdXJsIHNlZ21lbnQgY2Fubm90IGhhdmUgcGFyYW1ldGVyczogJ1wiICsgdGhpcy5yZW1haW5pbmcgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50KGRlY29kZShwYXRoKSwgdGhpcy5wYXJzZU1hdHJpeFBhcmFtcygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1hdHJpeFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbCgnOycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVBhcmFtKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9O1xuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUGFyYW0gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbWF0Y2hTZWdtZW50cyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZShrZXkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWwoJz0nKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hTZWdtZW50cyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZU1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtc1tkZWNvZGUoa2V5KV0gPSBkZWNvZGUodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBQYXJzZSBhIHNpbmdsZSBxdWVyeSBwYXJhbWV0ZXIgYG5hbWVbPXZhbHVlXWBcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5wYXJzZVF1ZXJ5UGFyYW0gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbWF0Y2hRdWVyeVBhcmFtcyh0aGlzLnJlbWFpbmluZyk7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZShrZXkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWwoJz0nKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU1hdGNoID0gbWF0Y2hVcmxRdWVyeVBhcmFtVmFsdWUodGhpcy5yZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVjb2RlZEtleSA9IGRlY29kZVF1ZXJ5KGtleSk7XG4gICAgICAgICAgICB2YXIgZGVjb2RlZFZhbCA9IGRlY29kZVF1ZXJ5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoZGVjb2RlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdG8gZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSBwYXJhbXNbZGVjb2RlZEtleV07XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWwgPSBbY3VycmVudFZhbF07XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGVkS2V5XSA9IGN1cnJlbnRWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWwucHVzaChkZWNvZGVkVmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGVkS2V5XSA9IGRlY29kZWRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBhcnNlIGAoYS9iLy9vdXRsZXRfbmFtZTpjL2QpYFxuICAgICAgICBVcmxQYXJzZXIucHJvdG90eXBlLnBhcnNlUGFyZW5zID0gZnVuY3Rpb24gKGFsbG93UHJpbWFyeSkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0ge307XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUoJygnKTtcbiAgICAgICAgICAgIHdoaWxlICghdGhpcy5jb25zdW1lT3B0aW9uYWwoJyknKSAmJiB0aGlzLnJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBtYXRjaFNlZ21lbnRzKHRoaXMucmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMucmVtYWluaW5nW3BhdGgubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAvLyBpZiBpcyBpcyBub3Qgb25lIG9mIHRoZXNlIGNoYXJhY3RlcnMsIHRoZW4gdGhlIHNlZ21lbnQgd2FzIHVuZXNjYXBlZFxuICAgICAgICAgICAgICAgIC8vIG9yIHRoZSBncm91cCB3YXMgbm90IGNsb3NlZFxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLycgJiYgbmV4dCAhPT0gJyknICYmIG5leHQgIT09ICc7Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdXJsICdcIiArIHRoaXMudXJsICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgb3V0bGV0TmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRsZXROYW1lID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5pbmRleE9mKCc6JykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUob3V0bGV0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSgnOicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGxvd1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0bGV0TmFtZSA9IFBSSU1BUllfT1VUTEVUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnNlQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tvdXRsZXROYW1lXSA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5sZW5ndGggPT09IDEgPyBjaGlsZHJlbltQUklNQVJZX09VVExFVF0gOlxuICAgICAgICAgICAgICAgICAgICBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWwoJy8vJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUucGVla1N0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiB0aGlzLnJlbWFpbmluZy5zdGFydHNXaXRoKHN0cik7IH07XG4gICAgICAgIC8vIENvbnN1bWVzIHRoZSBwcmVmaXggd2hlbiBpdCBpcyBwcmVzZW50IGFuZCByZXR1cm5zIHdoZXRoZXIgaXQgaGFzIGJlZW4gY29uc3VtZWRcbiAgICAgICAgVXJsUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lT3B0aW9uYWwgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrU3RhcnRzV2l0aChzdHIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHJpbmcoc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFVybFBhcnNlci5wcm90b3R5cGUuY2FwdHVyZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdW1lT3B0aW9uYWwoc3RyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHN0ciArIFwiXFxcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBVcmxQYXJzZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJlZShyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhGcm9tUm9vdCh0KTtcbiAgICAgICAgICAgIHJldHVybiBwLmxlbmd0aCA+IDEgPyBwW3AubGVuZ3RoIC0gMl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IGZpbmROb2RlKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIG4gPyBuLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC52YWx1ZTsgfSkgOiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IGZpbmROb2RlKHQsIHRoaXMuX3Jvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIG4gJiYgbi5jaGlsZHJlbi5sZW5ndGggPiAwID8gbi5jaGlsZHJlblswXS52YWx1ZSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnNpYmxpbmdzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBwID0gZmluZFBhdGgodCwgdGhpcy5fcm9vdCk7XG4gICAgICAgICAgICBpZiAocC5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIHZhciBjID0gcFtwLmxlbmd0aCAtIDJdLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52YWx1ZTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gYy5maWx0ZXIoZnVuY3Rpb24gKGNjKSB7IHJldHVybiBjYyAhPT0gdDsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnBhdGhGcm9tUm9vdCA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmaW5kUGF0aCh0LCB0aGlzLl9yb290KS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudmFsdWU7IH0pOyB9O1xuICAgICAgICByZXR1cm4gVHJlZTtcbiAgICB9KCkpO1xuICAgIC8vIERGUyBmb3IgdGhlIG5vZGUgbWF0Y2hpbmcgdGhlIHZhbHVlXG4gICAgZnVuY3Rpb24gZmluZE5vZGUodmFsdWUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbm9kZS52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2RlLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBub2RlXzEgPSBmaW5kTm9kZSh2YWx1ZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlXzEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBwYXRoIHRvIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHVzaW5nIERGU1xuICAgIGZ1bmN0aW9uIGZpbmRQYXRoKHZhbHVlLCBub2RlKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAodmFsdWUgPT09IG5vZGUudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2RlLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZmluZFBhdGgodmFsdWUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBUcmVlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJlZU5vZGUodmFsdWUsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUcmVlTm9kZShcIiArIHRoaXMudmFsdWUgKyBcIilcIjsgfTtcbiAgICAgICAgcmV0dXJuIFRyZWVOb2RlO1xuICAgIH0oKSk7XG4gICAgLy8gUmV0dXJuIHRoZSBsaXN0IG9mIFQgaW5kZXhlZCBieSBvdXRsZXQgbmFtZVxuICAgIGZ1bmN0aW9uIG5vZGVDaGlsZHJlbkFzTWFwKG5vZGUpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gbWFwW2NoaWxkLnZhbHVlLm91dGxldF0gPSBjaGlsZDsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgcm91dGVyLlxuICAgICAqXG4gICAgICogUm91dGVyU3RhdGUgaXMgYSB0cmVlIG9mIGFjdGl2YXRlZCByb3V0ZXMuIEV2ZXJ5IG5vZGUgaW4gdGhpcyB0cmVlIGtub3dzIGFib3V0IHRoZSBcImNvbnN1bWVkXCIgVVJMXG4gICAgICogc2VnbWVudHMsIHRoZSBleHRyYWN0ZWQgcGFyYW1ldGVycywgYW5kIHRoZSByZXNvbHZlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7dGVtcGxhdGVVcmw6J3RlbXBsYXRlLmh0bWwnfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlcikge1xuICAgICAqICAgICBjb25zdCBzdGF0ZTogUm91dGVyU3RhdGUgPSByb3V0ZXIucm91dGVyU3RhdGU7XG4gICAgICogICAgIGNvbnN0IHJvb3Q6IEFjdGl2YXRlZFJvdXRlID0gc3RhdGUucm9vdDtcbiAgICAgKiAgICAgY29uc3QgY2hpbGQgPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICogICAgIGNvbnN0IGlkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSBjaGlsZC5wYXJhbXMubWFwKHAgPT4gcC5pZCk7XG4gICAgICogICAgIC8vLi4uXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGBBY3RpdmF0ZWRSb3V0ZWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUm91dGVyU3RhdGUsIF9zdXBlcik7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZnVuY3Rpb24gUm91dGVyU3RhdGUocm9vdCwgXG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBzbmFwc2hvdCBvZiB0aGUgcm91dGVyIHN0YXRlICovXG4gICAgICAgIHNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290KSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICAgICAgICAgIHNldFJvdXRlclN0YXRlKF90aGlzLCByb290KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNuYXBzaG90LnRvU3RyaW5nKCk7IH07XG4gICAgICAgIHJldHVybiBSb3V0ZXJTdGF0ZTtcbiAgICB9KFRyZWUpKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVFbXB0eVN0YXRlKHVybFRyZWUsIHJvb3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gY3JlYXRlRW1wdHlTdGF0ZVNuYXBzaG90KHVybFRyZWUsIHJvb3RDb21wb25lbnQpO1xuICAgICAgICB2YXIgZW1wdHlVcmwgPSBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3QoW25ldyBVcmxTZWdtZW50KCcnLCB7fSldKTtcbiAgICAgICAgdmFyIGVtcHR5UGFyYW1zID0gbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICAgICAgdmFyIGVtcHR5RGF0YSA9IG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgICAgIHZhciBlbXB0eVF1ZXJ5UGFyYW1zID0gbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KCcnKTtcbiAgICAgICAgdmFyIGFjdGl2YXRlZCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZShlbXB0eVVybCwgZW1wdHlQYXJhbXMsIGVtcHR5UXVlcnlQYXJhbXMsIGZyYWdtZW50LCBlbXB0eURhdGEsIFBSSU1BUllfT1VUTEVULCByb290Q29tcG9uZW50LCBzbmFwc2hvdC5yb290KTtcbiAgICAgICAgYWN0aXZhdGVkLnNuYXBzaG90ID0gc25hcHNob3Qucm9vdDtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTdGF0ZShuZXcgVHJlZU5vZGUoYWN0aXZhdGVkLCBbXSksIHNuYXBzaG90KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRW1wdHlTdGF0ZVNuYXBzaG90KHVybFRyZWUsIHJvb3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGVtcHR5UGFyYW1zID0ge307XG4gICAgICAgIHZhciBlbXB0eURhdGEgPSB7fTtcbiAgICAgICAgdmFyIGVtcHR5UXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gJyc7XG4gICAgICAgIHZhciBhY3RpdmF0ZWQgPSBuZXcgQWN0aXZhdGVkUm91dGVTbmFwc2hvdChbXSwgZW1wdHlQYXJhbXMsIGVtcHR5UXVlcnlQYXJhbXMsIGZyYWdtZW50LCBlbXB0eURhdGEsIFBSSU1BUllfT1VUTEVULCByb290Q29tcG9uZW50LCBudWxsLCB1cmxUcmVlLnJvb3QsIC0xLCB7fSk7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGVyU3RhdGVTbmFwc2hvdCgnJywgbmV3IFRyZWVOb2RlKGFjdGl2YXRlZCwgW10pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYSByb3V0ZSBhc3NvY2lhdGVkIHdpdGggYSBjb21wb25lbnQgbG9hZGVkIGluIGFuXG4gICAgICogb3V0bGV0LiAgQW4gYEFjdGl2YXRlZFJvdXRlYCBjYW4gYWxzbyBiZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSByb3V0ZXIgc3RhdGUgdHJlZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSByb3V0ZXIvYWN0aXZhdGVkLXJvdXRlL21vZHVsZS50cyByZWdpb249XCJhY3RpdmF0ZWQtcm91dGVcIlxuICAgICAqICAgICBoZWFkZXI9XCJhY3RpdmF0ZWQtcm91dGUuY29tcG9uZW50LnRzXCIgbGluZW51bXM9XCJmYWxzZVwifVxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBBY3RpdmF0ZWRSb3V0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0ZWRSb3V0ZShcbiAgICAgICAgLyoqIEFuIG9ic2VydmFibGUgb2YgdGhlIFVSTCBzZWdtZW50cyBtYXRjaGVkIGJ5IHRoaXMgcm91dGUgKi9cbiAgICAgICAgdXJsLCBcbiAgICAgICAgLyoqIEFuIG9ic2VydmFibGUgb2YgdGhlIG1hdHJpeCBwYXJhbWV0ZXJzIHNjb3BlZCB0byB0aGlzIHJvdXRlICovXG4gICAgICAgIHBhcmFtcywgXG4gICAgICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgICAgICBxdWVyeVBhcmFtcywgXG4gICAgICAgIC8qKiBBbiBvYnNlcnZhYmxlIG9mIHRoZSBVUkwgZnJhZ21lbnQgc2hhcmVkIGJ5IGFsbCB0aGUgcm91dGVzICovXG4gICAgICAgIGZyYWdtZW50LCBcbiAgICAgICAgLyoqIEFuIG9ic2VydmFibGUgb2YgdGhlIHN0YXRpYyBhbmQgcmVzb2x2ZWQgZGF0YSBvZiB0aGlzIHJvdXRlLiAqL1xuICAgICAgICBkYXRhLCBcbiAgICAgICAgLyoqIFRoZSBvdXRsZXQgbmFtZSBvZiB0aGUgcm91dGUuIEl0J3MgYSBjb25zdGFudCAqL1xuICAgICAgICBvdXRsZXQsIFxuICAgICAgICAvKiogVGhlIGNvbXBvbmVudCBvZiB0aGUgcm91dGUuIEl0J3MgYSBjb25zdGFudCAqL1xuICAgICAgICAvLyBUT0RPKHZzYXZraW4pOiByZW1vdmUgfHN0cmluZ1xuICAgICAgICBjb21wb25lbnQsIGZ1dHVyZVNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMub3V0bGV0ID0gb3V0bGV0O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLl9mdXR1cmVTbmFwc2hvdCA9IGZ1dHVyZVNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicm91dGVDb25maWdcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWF0Y2ggdGhpcyByb3V0ZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mdXR1cmVTbmFwc2hvdC5yb3V0ZUNvbmZpZzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIHJvb3Qgb2YgdGhlIHJvdXRlciBzdGF0ZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5yb290OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSBwYXJlbnQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUucGFyZW50KHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlLnByb3RvdHlwZSwgXCJmaXJzdENoaWxkXCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgZmlyc3QgY2hpbGQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUuZmlyc3RDaGlsZCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgLyoqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIHJvdXRlIGluIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5jaGlsZHJlbih0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicGF0aEZyb21Sb290XCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSB0byB0aGlzIHJvdXRlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnBhdGhGcm9tUm9vdCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicGFyYW1NYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJhbU1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbU1hcCA9IHRoaXMucGFyYW1zLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gY29udmVydFRvUGFyYW1NYXAocCk7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtTWFwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZS5wcm90b3R5cGUsIFwicXVlcnlQYXJhbU1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3F1ZXJ5UGFyYW1NYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlQYXJhbU1hcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gY29udmVydFRvUGFyYW1NYXAocCk7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1NYXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQWN0aXZhdGVkUm91dGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc25hcHNob3QgPyB0aGlzLnNuYXBzaG90LnRvU3RyaW5nKCkgOiBcIkZ1dHVyZShcIiArIHRoaXMuX2Z1dHVyZVNuYXBzaG90ICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBY3RpdmF0ZWRSb3V0ZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluaGVyaXRlZCBwYXJhbXMsIGRhdGEsIGFuZCByZXNvbHZlIGZvciBhIGdpdmVuIHJvdXRlLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgb25seSBpbmhlcml0cyB2YWx1ZXMgdXAgdG8gdGhlIG5lYXJlc3QgcGF0aC1sZXNzIG9yIGNvbXBvbmVudC1sZXNzIHJvdXRlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRlZFBhcmFtc0RhdGFSZXNvbHZlKHJvdXRlLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5KSB7XG4gICAgICAgIGlmIChwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID09PSB2b2lkIDApIHsgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9ICdlbXB0eU9ubHknOyB9XG4gICAgICAgIHZhciBwYXRoRnJvbVJvb3QgPSByb3V0ZS5wYXRoRnJvbVJvb3Q7XG4gICAgICAgIHZhciBpbmhlcml0aW5nU3RhcnRpbmdGcm9tID0gMDtcbiAgICAgICAgaWYgKHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgIT09ICdhbHdheXMnKSB7XG4gICAgICAgICAgICBpbmhlcml0aW5nU3RhcnRpbmdGcm9tID0gcGF0aEZyb21Sb290Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoRnJvbVJvb3RbaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbV07XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gcGF0aEZyb21Sb290W2luaGVyaXRpbmdTdGFydGluZ0Zyb20gLSAxXTtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHJvdXRlIGlzIGFuIGVtcHR5IHBhdGggPT4gaW5oZXJpdHMgaXRzIHBhcmVudCdzIHBhcmFtcyBhbmQgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJvdXRlQ29uZmlnICYmIGN1cnJlbnQucm91dGVDb25maWcucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGluZ1N0YXJ0aW5nRnJvbS0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMgY29tcG9uZW50bGVzcyA9PiBjdXJyZW50IHJvdXRlIHNob3VsZCBpbmhlcml0IGl0cyBwYXJhbXMgYW5kIGRhdGFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXBhcmVudF8xLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpbmhlcml0aW5nU3RhcnRpbmdGcm9tLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5Jbmhlcml0ZWQocGF0aEZyb21Sb290LnNsaWNlKGluaGVyaXRpbmdTdGFydGluZ0Zyb20pKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5Jbmhlcml0ZWQocGF0aEZyb21Sb290KSB7XG4gICAgICAgIHJldHVybiBwYXRoRnJvbVJvb3QucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGN1cnIpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfX2Fzc2lnbih7fSwgcmVzLnBhcmFtcywgY3Vyci5wYXJhbXMpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfX2Fzc2lnbih7fSwgcmVzLmRhdGEsIGN1cnIuZGF0YSk7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IF9fYXNzaWduKHt9LCByZXMucmVzb2x2ZSwgY3Vyci5fcmVzb2x2ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBkYXRhOiBkYXRhLCByZXNvbHZlOiByZXNvbHZlIH07XG4gICAgICAgIH0sIHsgcGFyYW1zOiB7fSwgZGF0YToge30sIHJlc29sdmU6IHt9IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhIHJvdXRlIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudCBsb2FkZWQgaW4gYW5cbiAgICAgKiBvdXRsZXQgYXQgYSBwYXJ0aWN1bGFyIG1vbWVudCBpbiB0aW1lLiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IGNhbiBhbHNvIGJlIHVzZWQgdG9cbiAgICAgKiB0cmF2ZXJzZSB0aGUgcm91dGVyIHN0YXRlIHRyZWUuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDonLi9teS1jb21wb25lbnQuaHRtbCd9KVxuICAgICAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSkge1xuICAgICAqICAgICBjb25zdCBpZDogc3RyaW5nID0gcm91dGUuc25hcHNob3QucGFyYW1zLmlkO1xuICAgICAqICAgICBjb25zdCB1cmw6IHN0cmluZyA9IHJvdXRlLnNuYXBzaG90LnVybC5qb2luKCcnKTtcbiAgICAgKiAgICAgY29uc3QgdXNlciA9IHJvdXRlLnNuYXBzaG90LmRhdGEudXNlcjtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGVkUm91dGVTbmFwc2hvdChcbiAgICAgICAgLyoqIFRoZSBVUkwgc2VnbWVudHMgbWF0Y2hlZCBieSB0aGlzIHJvdXRlICovXG4gICAgICAgIHVybCwgXG4gICAgICAgIC8qKiBUaGUgbWF0cml4IHBhcmFtZXRlcnMgc2NvcGVkIHRvIHRoaXMgcm91dGUgKi9cbiAgICAgICAgcGFyYW1zLCBcbiAgICAgICAgLyoqIFRoZSBxdWVyeSBwYXJhbWV0ZXJzIHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgICAgICBxdWVyeVBhcmFtcywgXG4gICAgICAgIC8qKiBUaGUgVVJMIGZyYWdtZW50IHNoYXJlZCBieSBhbGwgdGhlIHJvdXRlcyAqL1xuICAgICAgICBmcmFnbWVudCwgXG4gICAgICAgIC8qKiBUaGUgc3RhdGljIGFuZCByZXNvbHZlZCBkYXRhIG9mIHRoaXMgcm91dGUgKi9cbiAgICAgICAgZGF0YSwgXG4gICAgICAgIC8qKiBUaGUgb3V0bGV0IG5hbWUgb2YgdGhlIHJvdXRlICovXG4gICAgICAgIG91dGxldCwgXG4gICAgICAgIC8qKiBUaGUgY29tcG9uZW50IG9mIHRoZSByb3V0ZSAqL1xuICAgICAgICBjb21wb25lbnQsIHJvdXRlQ29uZmlnLCB1cmxTZWdtZW50LCBsYXN0UGF0aEluZGV4LCByZXNvbHZlKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMub3V0bGV0ID0gb3V0bGV0O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLnJvdXRlQ29uZmlnID0gcm91dGVDb25maWc7XG4gICAgICAgICAgICB0aGlzLl91cmxTZWdtZW50ID0gdXJsU2VnbWVudDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQYXRoSW5kZXggPSBsYXN0UGF0aEluZGV4O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSByb290IG9mIHRoZSByb3V0ZXIgc3RhdGUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUucm9vdDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSBwYXJlbnQgb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUucGFyZW50KHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcImZpcnN0Q2hpbGRcIiwge1xuICAgICAgICAgICAgLyoqIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGlzIHJvdXRlIGluIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJTdGF0ZS5maXJzdENoaWxkKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyByb3V0ZSBpbiB0aGUgcm91dGVyIHN0YXRlIHRyZWUgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyU3RhdGUuY2hpbGRyZW4odGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUsIFwicGF0aEZyb21Sb290XCIsIHtcbiAgICAgICAgICAgIC8qKiBUaGUgcGF0aCBmcm9tIHRoZSByb290IG9mIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSB0byB0aGlzIHJvdXRlICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclN0YXRlLnBhdGhGcm9tUm9vdCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnByb3RvdHlwZSwgXCJwYXJhbU1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtTWFwID0gY29udmVydFRvUGFyYW1NYXAodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1NYXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFjdGl2YXRlZFJvdXRlU25hcHNob3QucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1NYXBcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWVyeVBhcmFtTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5UGFyYW1NYXAgPSBjb252ZXJ0VG9QYXJhbU1hcCh0aGlzLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1NYXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQWN0aXZhdGVkUm91dGVTbmFwc2hvdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7IHJldHVybiBzZWdtZW50LnRvU3RyaW5nKCk7IH0pLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gdGhpcy5yb3V0ZUNvbmZpZyA/IHRoaXMucm91dGVDb25maWcucGF0aCA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiUm91dGUodXJsOidcIiArIHVybCArIFwiJywgcGF0aDonXCIgKyBtYXRjaGVkICsgXCInKVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHJvdXRlciBhdCBhIG1vbWVudCBpbiB0aW1lLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIHRyZWUgb2YgYWN0aXZhdGVkIHJvdXRlIHNuYXBzaG90cy4gRXZlcnkgbm9kZSBpbiB0aGlzIHRyZWUga25vd3MgYWJvdXRcbiAgICAgKiB0aGUgXCJjb25zdW1lZFwiIFVSTCBzZWdtZW50cywgdGhlIGV4dHJhY3RlZCBwYXJhbWV0ZXJzLCBhbmQgdGhlIHJlc29sdmVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHt0ZW1wbGF0ZVVybDondGVtcGxhdGUuaHRtbCd9KVxuICAgICAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogUm91dGVyKSB7XG4gICAgICogICAgIGNvbnN0IHN0YXRlOiBSb3V0ZXJTdGF0ZSA9IHJvdXRlci5yb3V0ZXJTdGF0ZTtcbiAgICAgKiAgICAgY29uc3Qgc25hcHNob3Q6IFJvdXRlclN0YXRlU25hcHNob3QgPSBzdGF0ZS5zbmFwc2hvdDtcbiAgICAgKiAgICAgY29uc3Qgcm9vdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCA9IHNuYXBzaG90LnJvb3Q7XG4gICAgICogICAgIGNvbnN0IGNoaWxkID0gcm9vdC5maXJzdENoaWxkO1xuICAgICAqICAgICBjb25zdCBpZDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gY2hpbGQucGFyYW1zLm1hcChwID0+IHAuaWQpO1xuICAgICAqICAgICAvLy4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyU3RhdGVTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFJvdXRlclN0YXRlU25hcHNob3QsIF9zdXBlcik7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZnVuY3Rpb24gUm91dGVyU3RhdGVTbmFwc2hvdChcbiAgICAgICAgLyoqIFRoZSB1cmwgZnJvbSB3aGljaCB0aGlzIHNuYXBzaG90IHdhcyBjcmVhdGVkICovXG4gICAgICAgIHVybCwgcm9vdCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHNldFJvdXRlclN0YXRlKF90aGlzLCByb290KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJTdGF0ZVNuYXBzaG90LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZU5vZGUodGhpcy5fcm9vdCk7IH07XG4gICAgICAgIHJldHVybiBSb3V0ZXJTdGF0ZVNuYXBzaG90O1xuICAgIH0oVHJlZSkpO1xuICAgIGZ1bmN0aW9uIHNldFJvdXRlclN0YXRlKHN0YXRlLCBub2RlKSB7XG4gICAgICAgIG5vZGUudmFsdWUuX3JvdXRlclN0YXRlID0gc3RhdGU7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gc2V0Um91dGVyU3RhdGUoc3RhdGUsIGMpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBjID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwID8gXCIgeyBcIiArIG5vZGUuY2hpbGRyZW4ubWFwKHNlcmlhbGl6ZU5vZGUpLmpvaW4oJywgJykgKyBcIiB9IFwiIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiICsgbm9kZS52YWx1ZSArIGM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHRoZSBhY3RpdmF0ZSByb3V0ZSBpcyBjcmVhdGVkIHdpdGggdGhlIHJpZ2h0IHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqIFNvIHdlIHB1c2ggbmV3IHZhbHVlcyBpbnRvIHRoZSBvYnNlcnZhYmxlcyBvbmx5IHdoZW4gdGhleSBhcmUgbm90IHRoZSBpbml0aWFsIHZhbHVlcy5cbiAgICAgKiBBbmQgd2UgZGV0ZWN0IHRoYXQgYnkgY2hlY2tpbmcgaWYgdGhlIHNuYXBzaG90IGZpZWxkIGlzIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZHZhbmNlQWN0aXZhdGVkUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHJvdXRlLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNuYXBzaG90ID0gcm91dGUuc25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgbmV4dFNuYXBzaG90ID0gcm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICAgICAgcm91dGUuc25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChjdXJyZW50U25hcHNob3QucXVlcnlQYXJhbXMsIG5leHRTbmFwc2hvdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICByb3V0ZS5xdWVyeVBhcmFtcy5uZXh0KG5leHRTbmFwc2hvdC5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFNuYXBzaG90LmZyYWdtZW50ICE9PSBuZXh0U25hcHNob3QuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICByb3V0ZS5mcmFnbWVudC5uZXh0KG5leHRTbmFwc2hvdC5mcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3dFcXVhbChjdXJyZW50U25hcHNob3QucGFyYW1zLCBuZXh0U25hcHNob3QucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlLnBhcmFtcy5uZXh0KG5leHRTbmFwc2hvdC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWxBcnJheXMoY3VycmVudFNuYXBzaG90LnVybCwgbmV4dFNuYXBzaG90LnVybCkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZS51cmwubmV4dChuZXh0U25hcHNob3QudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hhbGxvd0VxdWFsKGN1cnJlbnRTbmFwc2hvdC5kYXRhLCBuZXh0U25hcHNob3QuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZS5kYXRhLm5leHQobmV4dFNuYXBzaG90LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm91dGUuc25hcHNob3QgPSByb3V0ZS5fZnV0dXJlU25hcHNob3Q7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGZvciByZXNvbHZlZCBkYXRhXG4gICAgICAgICAgICByb3V0ZS5kYXRhLm5leHQocm91dGUuX2Z1dHVyZVNuYXBzaG90LmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoYSwgYikge1xuICAgICAgICB2YXIgZXF1YWxVcmxQYXJhbXMgPSBzaGFsbG93RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKSAmJiBlcXVhbFNlZ21lbnRzKGEudXJsLCBiLnVybCk7XG4gICAgICAgIHZhciBwYXJlbnRzTWlzbWF0Y2ggPSAhYS5wYXJlbnQgIT09ICFiLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGVxdWFsVXJsUGFyYW1zICYmICFwYXJlbnRzTWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICghYS5wYXJlbnQgfHwgZXF1YWxQYXJhbXNBbmRVcmxTZWdtZW50cyhhLnBhcmVudCwgYi5wYXJlbnQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91dGVyU3RhdGUocm91dGVSZXVzZVN0cmF0ZWd5LCBjdXJyLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBjcmVhdGVOb2RlKHJvdXRlUmV1c2VTdHJhdGVneSwgY3Vyci5fcm9vdCwgcHJldlN0YXRlID8gcHJldlN0YXRlLl9yb290IDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTdGF0ZShyb290LCBjdXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGN1cnIsIHByZXZTdGF0ZSkge1xuICAgICAgICAvLyByZXVzZSBhbiBhY3RpdmF0ZWQgcm91dGUgdGhhdCBpcyBjdXJyZW50bHkgZGlzcGxheWVkIG9uIHRoZSBzY3JlZW5cbiAgICAgICAgaWYgKHByZXZTdGF0ZSAmJiByb3V0ZVJldXNlU3RyYXRlZ3kuc2hvdWxkUmV1c2VSb3V0ZShjdXJyLnZhbHVlLCBwcmV2U3RhdGUudmFsdWUuc25hcHNob3QpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcmV2U3RhdGUudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZS5fZnV0dXJlU25hcHNob3QgPSBjdXJyLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3JlYXRlT3JSZXVzZUNoaWxkcmVuKHJvdXRlUmV1c2VTdHJhdGVneSwgY3VyciwgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodmFsdWUsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIC8vIHJldHJpZXZlIGFuIGFjdGl2YXRlZCByb3V0ZSB0aGF0IGlzIHVzZWQgdG8gYmUgZGlzcGxheWVkLCBidXQgaXMgbm90IGN1cnJlbnRseSBkaXNwbGF5ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZFJvdXRlSGFuZGxlID0gcm91dGVSZXVzZVN0cmF0ZWd5LnJldHJpZXZlKGN1cnIudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRldGFjaGVkUm91dGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJlZSA9IGRldGFjaGVkUm91dGVIYW5kbGUucm91dGU7XG4gICAgICAgICAgICAgICAgc2V0RnV0dXJlU25hcHNob3RzT2ZBY3RpdmF0ZWRSb3V0ZXMoY3VyciwgdHJlZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjcmVhdGVBY3RpdmF0ZWRSb3V0ZShjdXJyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGMpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RnV0dXJlU25hcHNob3RzT2ZBY3RpdmF0ZWRSb3V0ZXMoY3VyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChjdXJyLnZhbHVlLnJvdXRlQ29uZmlnICE9PSByZXN1bHQudmFsdWUucm91dGVDb25maWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYXR0YWNoIEFjdGl2YXRlZFJvdXRlU25hcHNob3QgY3JlYXRlZCBmcm9tIGEgZGlmZmVyZW50IHJvdXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnIuY2hpbGRyZW4ubGVuZ3RoICE9PSByZXN1bHQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWF0dGFjaCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IHdpdGggYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGNoaWxkcmVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnZhbHVlLl9mdXR1cmVTbmFwc2hvdCA9IGN1cnIudmFsdWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vyci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgc2V0RnV0dXJlU25hcHNob3RzT2ZBY3RpdmF0ZWRSb3V0ZXMoY3Vyci5jaGlsZHJlbltpXSwgcmVzdWx0LmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVPclJldXNlQ2hpbGRyZW4ocm91dGVSZXVzZVN0cmF0ZWd5LCBjdXJyLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMocHJldlN0YXRlLmNoaWxkcmVuKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVSZXVzZVN0cmF0ZWd5LnNob3VsZFJldXNlUm91dGUocC52YWx1ZS5zbmFwc2hvdCwgY2hpbGQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTm9kZShyb3V0ZVJldXNlU3RyYXRlZ3ksIGNoaWxkLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlKHJvdXRlUmV1c2VTdHJhdGVneSwgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZhdGVkUm91dGUoYykge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2YXRlZFJvdXRlKG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdChjLnVybCksIG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdChjLnBhcmFtcyksIG5ldyByeGpzLkJlaGF2aW9yU3ViamVjdChjLnF1ZXJ5UGFyYW1zKSwgbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KGMuZnJhZ21lbnQpLCBuZXcgcnhqcy5CZWhhdmlvclN1YmplY3QoYy5kYXRhKSwgYy5vdXRsZXQsIGMuY29tcG9uZW50LCBjKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVXJsVHJlZShyb3V0ZSwgdXJsVHJlZSwgY29tbWFuZHMsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCkge1xuICAgICAgICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZSh1cmxUcmVlLnJvb3QsIHVybFRyZWUucm9vdCwgdXJsVHJlZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF2ID0gY29tcHV0ZU5hdmlnYXRpb24oY29tbWFuZHMpO1xuICAgICAgICBpZiAobmF2LnRvUm9vdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZSh1cmxUcmVlLnJvb3QsIG5ldyBVcmxTZWdtZW50R3JvdXAoW10sIHt9KSwgdXJsVHJlZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRpbmdQb3NpdGlvbiA9IGZpbmRTdGFydGluZ1Bvc2l0aW9uKG5hdiwgdXJsVHJlZSwgcm91dGUpO1xuICAgICAgICB2YXIgc2VnbWVudEdyb3VwID0gc3RhcnRpbmdQb3NpdGlvbi5wcm9jZXNzQ2hpbGRyZW4gP1xuICAgICAgICAgICAgdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oc3RhcnRpbmdQb3NpdGlvbi5zZWdtZW50R3JvdXAsIHN0YXJ0aW5nUG9zaXRpb24uaW5kZXgsIG5hdi5jb21tYW5kcykgOlxuICAgICAgICAgICAgdXBkYXRlU2VnbWVudEdyb3VwKHN0YXJ0aW5nUG9zaXRpb24uc2VnbWVudEdyb3VwLCBzdGFydGluZ1Bvc2l0aW9uLmluZGV4LCBuYXYuY29tbWFuZHMpO1xuICAgICAgICByZXR1cm4gdHJlZShzdGFydGluZ1Bvc2l0aW9uLnNlZ21lbnRHcm91cCwgc2VnbWVudEdyb3VwLCB1cmxUcmVlLCBxdWVyeVBhcmFtcywgZnJhZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc01hdHJpeFBhcmFtcyhjb21tYW5kKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29tbWFuZCA9PT0gJ29iamVjdCcgJiYgY29tbWFuZCAhPSBudWxsICYmICFjb21tYW5kLm91dGxldHMgJiYgIWNvbW1hbmQuc2VnbWVudFBhdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyZWUob2xkU2VnbWVudEdyb3VwLCBuZXdTZWdtZW50R3JvdXAsIHVybFRyZWUsIHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCkge1xuICAgICAgICB2YXIgcXAgPSB7fTtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHF1ZXJ5UGFyYW1zLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBxcFtuYW1lXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlwiICsgdjsgfSkgOiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsVHJlZS5yb290ID09PSBvbGRTZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsVHJlZShuZXdTZWdtZW50R3JvdXAsIHFwLCBmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVcmxUcmVlKHJlcGxhY2VTZWdtZW50KHVybFRyZWUucm9vdCwgb2xkU2VnbWVudEdyb3VwLCBuZXdTZWdtZW50R3JvdXApLCBxcCwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBsYWNlU2VnbWVudChjdXJyZW50LCBvbGRTZWdtZW50LCBuZXdTZWdtZW50KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHt9O1xuICAgICAgICBmb3JFYWNoKGN1cnJlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uIChjLCBvdXRsZXROYW1lKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gb2xkU2VnbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW291dGxldE5hbWVdID0gbmV3U2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW291dGxldE5hbWVdID0gcmVwbGFjZVNlZ21lbnQoYywgb2xkU2VnbWVudCwgbmV3U2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChjdXJyZW50LnNlZ21lbnRzLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHZhciBOYXZpZ2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0aW9uKGlzQWJzb2x1dGUsIG51bWJlck9mRG91YmxlRG90cywgY29tbWFuZHMpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mRG91YmxlRG90cyA9IG51bWJlck9mRG91YmxlRG90cztcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlICYmIGNvbW1hbmRzLmxlbmd0aCA+IDAgJiYgaXNNYXRyaXhQYXJhbXMoY29tbWFuZHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IHNlZ21lbnQgY2Fubm90IGhhdmUgbWF0cml4IHBhcmFtZXRlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbWRXaXRoT3V0bGV0ID0gY29tbWFuZHMuZmluZChmdW5jdGlvbiAoYykgeyByZXR1cm4gdHlwZW9mIGMgPT09ICdvYmplY3QnICYmIGMgIT0gbnVsbCAmJiBjLm91dGxldHM7IH0pO1xuICAgICAgICAgICAgaWYgKGNtZFdpdGhPdXRsZXQgJiYgY21kV2l0aE91dGxldCAhPT0gbGFzdChjb21tYW5kcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3tvdXRsZXRzOnt9fSBoYXMgdG8gYmUgdGhlIGxhc3QgY29tbWFuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE5hdmlnYXRpb24ucHJvdG90eXBlLnRvUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWJzb2x1dGUgJiYgdGhpcy5jb21tYW5kcy5sZW5ndGggPT09IDEgJiYgdGhpcy5jb21tYW5kc1swXSA9PSAnLyc7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOYXZpZ2F0aW9uO1xuICAgIH0oKSk7XG4gICAgLyoqIFRyYW5zZm9ybXMgY29tbWFuZHMgdG8gYSBub3JtYWxpemVkIGBOYXZpZ2F0aW9uYCAqL1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVOYXZpZ2F0aW9uKGNvbW1hbmRzKSB7XG4gICAgICAgIGlmICgodHlwZW9mIGNvbW1hbmRzWzBdID09PSAnc3RyaW5nJykgJiYgY29tbWFuZHMubGVuZ3RoID09PSAxICYmIGNvbW1hbmRzWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdGlvbih0cnVlLCAwLCBjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlck9mRG91YmxlRG90cyA9IDA7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHZhciByZXMgPSBjb21tYW5kcy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgY21kLCBjbWRJZHgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY21kID09PSAnb2JqZWN0JyAmJiBjbWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjbWQub3V0bGV0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0bGV0c18xID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2goY21kLm91dGxldHMsIGZ1bmN0aW9uIChjb21tYW5kcywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGV0c18xW25hbWVdID0gdHlwZW9mIGNvbW1hbmRzID09PSAnc3RyaW5nJyA/IGNvbW1hbmRzLnNwbGl0KCcvJykgOiBjb21tYW5kcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChyZXMsIFt7IG91dGxldHM6IG91dGxldHNfMSB9XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbWQuc2VnbWVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkKHJlcywgW2NtZC5zZWdtZW50UGF0aF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBjbWQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChyZXMsIFtjbWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbWRJZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjbWQuc3BsaXQoJy8nKS5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQYXJ0LCBwYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA9PSAwICYmIHVybFBhcnQgPT09ICcuJykgO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0SW5kZXggPT0gMCAmJiB1cmxQYXJ0ID09PSAnJykgeyAvLyAgJy9hJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUGFydCA9PT0gJy4uJykgeyAvLyAgJy4uL2EnXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkRvdWJsZURvdHMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmxQYXJ0ICE9ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh1cmxQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWQocmVzLCBbY21kXSk7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uKGlzQWJzb2x1dGUsIG51bWJlck9mRG91YmxlRG90cywgcmVzKTtcbiAgICB9XG4gICAgdmFyIFBvc2l0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQb3NpdGlvbihzZWdtZW50R3JvdXAsIHByb2Nlc3NDaGlsZHJlbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudEdyb3VwID0gc2VnbWVudEdyb3VwO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ2hpbGRyZW4gPSBwcm9jZXNzQ2hpbGRyZW47XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZmluZFN0YXJ0aW5nUG9zaXRpb24obmF2LCB0cmVlLCByb3V0ZSkge1xuICAgICAgICBpZiAobmF2LmlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odHJlZS5yb290LCB0cnVlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUuc25hcHNob3QuX2xhc3RQYXRoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJvdXRlLnNuYXBzaG90Ll91cmxTZWdtZW50LCB0cnVlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kaWZpZXIgPSBpc01hdHJpeFBhcmFtcyhuYXYuY29tbWFuZHNbMF0pID8gMCA6IDE7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdXRlLnNuYXBzaG90Ll9sYXN0UGF0aEluZGV4ICsgbW9kaWZpZXI7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3NpdGlvbkFwcGx5aW5nRG91YmxlRG90cyhyb3V0ZS5zbmFwc2hvdC5fdXJsU2VnbWVudCwgaW5kZXgsIG5hdi5udW1iZXJPZkRvdWJsZURvdHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkFwcGx5aW5nRG91YmxlRG90cyhncm91cCwgaW5kZXgsIG51bWJlck9mRG91YmxlRG90cykge1xuICAgICAgICB2YXIgZyA9IGdyb3VwO1xuICAgICAgICB2YXIgY2kgPSBpbmRleDtcbiAgICAgICAgdmFyIGRkID0gbnVtYmVyT2ZEb3VibGVEb3RzO1xuICAgICAgICB3aGlsZSAoZGQgPiBjaSkge1xuICAgICAgICAgICAgZGQgLT0gY2k7XG4gICAgICAgICAgICBnID0gZy5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIWcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIFxcJy4uL1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2kgPSBnLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGcsIGZhbHNlLCBjaSAtIGRkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGF0aChjb21tYW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gJ29iamVjdCcgJiYgY29tbWFuZCAhPSBudWxsICYmIGNvbW1hbmQub3V0bGV0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQub3V0bGV0c1tQUklNQVJZX09VVExFVF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCIgKyBjb21tYW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsZXRzKGNvbW1hbmRzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghKHR5cGVvZiBjb21tYW5kc1swXSA9PT0gJ29iamVjdCcpKVxuICAgICAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW1BSSU1BUllfT1VUTEVUXSA9IGNvbW1hbmRzLCBfYTtcbiAgICAgICAgaWYgKGNvbW1hbmRzWzBdLm91dGxldHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBfYiA9IHt9LCBfYltQUklNQVJZX09VVExFVF0gPSBjb21tYW5kcywgX2I7XG4gICAgICAgIHJldHVybiBjb21tYW5kc1swXS5vdXRsZXRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcykge1xuICAgICAgICBpZiAoIXNlZ21lbnRHcm91cCkge1xuICAgICAgICAgICAgc2VnbWVudEdyb3VwID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoID09PSAwICYmIHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBwcmVmaXhlZFdpdGgoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgICAgIHZhciBzbGljZWRDb21tYW5kcyA9IGNvbW1hbmRzLnNsaWNlKG0uY29tbWFuZEluZGV4KTtcbiAgICAgICAgaWYgKG0ubWF0Y2ggJiYgbS5wYXRoSW5kZXggPCBzZWdtZW50R3JvdXAuc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZyA9IG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLnNsaWNlKDAsIG0ucGF0aEluZGV4KSwge30pO1xuICAgICAgICAgICAgZy5jaGlsZHJlbltQUklNQVJZX09VVExFVF0gPVxuICAgICAgICAgICAgICAgIG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLnNsaWNlKG0ucGF0aEluZGV4KSwgc2VnbWVudEdyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihnLCAwLCBzbGljZWRDb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5tYXRjaCAmJiBzbGljZWRDb21tYW5kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0ubWF0Y2ggJiYgIXNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3U2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0ubWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTZWdtZW50R3JvdXBDaGlsZHJlbihzZWdtZW50R3JvdXAsIDAsIHNsaWNlZENvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlU2VnbWVudEdyb3VwQ2hpbGRyZW4oc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcykge1xuICAgICAgICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRsZXRzXzIgPSBnZXRPdXRsZXRzKGNvbW1hbmRzKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbl8xID0ge307XG4gICAgICAgICAgICBmb3JFYWNoKG91dGxldHNfMiwgZnVuY3Rpb24gKGNvbW1hbmRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5fMVtvdXRsZXRdID0gdXBkYXRlU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5jaGlsZHJlbltvdXRsZXRdLCBzdGFydEluZGV4LCBjb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JFYWNoKHNlZ21lbnRHcm91cC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZE91dGxldCkge1xuICAgICAgICAgICAgICAgIGlmIChvdXRsZXRzXzJbY2hpbGRPdXRsZXRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5fMVtjaGlsZE91dGxldF0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywgY2hpbGRyZW5fMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZml4ZWRXaXRoKHNlZ21lbnRHcm91cCwgc3RhcnRJbmRleCwgY29tbWFuZHMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDb21tYW5kSW5kZXggPSAwO1xuICAgICAgICB2YXIgY3VycmVudFBhdGhJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIHZhciBub01hdGNoID0geyBtYXRjaDogZmFsc2UsIHBhdGhJbmRleDogMCwgY29tbWFuZEluZGV4OiAwIH07XG4gICAgICAgIHdoaWxlIChjdXJyZW50UGF0aEluZGV4IDwgc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb21tYW5kSW5kZXggPj0gY29tbWFuZHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBzZWdtZW50R3JvdXAuc2VnbWVudHNbY3VycmVudFBhdGhJbmRleF07XG4gICAgICAgICAgICB2YXIgY3VyciA9IGdldFBhdGgoY29tbWFuZHNbY3VycmVudENvbW1hbmRJbmRleF0pO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Q29tbWFuZEluZGV4IDwgY29tbWFuZHMubGVuZ3RoIC0gMSA/IGNvbW1hbmRzW2N1cnJlbnRDb21tYW5kSW5kZXggKyAxXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhdGhJbmRleCA+IDAgJiYgY3VyciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGN1cnIgJiYgbmV4dCAmJiAodHlwZW9mIG5leHQgPT09ICdvYmplY3QnKSAmJiBuZXh0Lm91dGxldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShjdXJyLCBuZXh0LCBwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2g7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1hbmRJbmRleCArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKGN1cnIsIHt9LCBwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2g7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbW1hbmRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFBhdGhJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hdGNoOiB0cnVlLCBwYXRoSW5kZXg6IGN1cnJlbnRQYXRoSW5kZXgsIGNvbW1hbmRJbmRleDogY3VycmVudENvbW1hbmRJbmRleCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOZXdTZWdtZW50R3JvdXAoc2VnbWVudEdyb3VwLCBzdGFydEluZGV4LCBjb21tYW5kcykge1xuICAgICAgICB2YXIgcGF0aHMgPSBzZWdtZW50R3JvdXAuc2VnbWVudHMuc2xpY2UoMCwgc3RhcnRJbmRleCk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZHNbaV0gPT09ICdvYmplY3QnICYmIGNvbW1hbmRzW2ldLm91dGxldHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNyZWF0ZU5ld1NlZ21lbnRDaGlsZHJlbihjb21tYW5kc1tpXS5vdXRsZXRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChwYXRocywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc3RhcnQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCwgd2UgbmVlZCB0byByZXVzZSB0aGUgcGF0aCBwYXJ0IGZyb20gdGhlIHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIGlzTWF0cml4UGFyYW1zKGNvbW1hbmRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzW3N0YXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3IFVybFNlZ21lbnQocC5wYXRoLCBjb21tYW5kc1swXSkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyID0gZ2V0UGF0aChjb21tYW5kc1tpXSk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IChpIDwgY29tbWFuZHMubGVuZ3RoIC0gMSkgPyBjb21tYW5kc1tpICsgMV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnIgJiYgbmV4dCAmJiBpc01hdHJpeFBhcmFtcyhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gobmV3IFVybFNlZ21lbnQoY3Vyciwgc3RyaW5naWZ5KG5leHQpKSk7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChuZXcgVXJsU2VnbWVudChjdXJyLCB7fSkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChwYXRocywge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOZXdTZWdtZW50Q2hpbGRyZW4ob3V0bGV0cykge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgZm9yRWFjaChvdXRsZXRzLCBmdW5jdGlvbiAoY29tbWFuZHMsIG91dGxldCkge1xuICAgICAgICAgICAgaWYgKGNvbW1hbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5bb3V0bGV0XSA9IGNyZWF0ZU5ld1NlZ21lbnRHcm91cChuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSksIDAsIGNvbW1hbmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHBhcmFtcykge1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIGZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcmVzW2tdID0gXCJcIiArIHY7IH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKHBhdGgsIHBhcmFtcywgc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gcGF0aCA9PSBzZWdtZW50LnBhdGggJiYgc2hhbGxvd0VxdWFsKHBhcmFtcywgc2VnbWVudC5wYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGFjdGl2YXRlUm91dGVzID0gZnVuY3Rpb24gKHJvb3RDb250ZXh0cywgcm91dGVSZXVzZVN0cmF0ZWd5LCBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIG5ldyBBY3RpdmF0ZVJvdXRlcyhyb3V0ZVJldXNlU3RyYXRlZ3ksIHQudGFyZ2V0Um91dGVyU3RhdGUsIHQuY3VycmVudFJvdXRlclN0YXRlLCBmb3J3YXJkRXZlbnQpXG4gICAgICAgICAgICAgICAgLmFjdGl2YXRlKHJvb3RDb250ZXh0cyk7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgQWN0aXZhdGVSb3V0ZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFjdGl2YXRlUm91dGVzKHJvdXRlUmV1c2VTdHJhdGVneSwgZnV0dXJlU3RhdGUsIGN1cnJTdGF0ZSwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlUmV1c2VTdHJhdGVneSA9IHJvdXRlUmV1c2VTdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuZnV0dXJlU3RhdGUgPSBmdXR1cmVTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuY3VyclN0YXRlID0gY3VyclN0YXRlO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkRXZlbnQgPSBmb3J3YXJkRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHBhcmVudENvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgZnV0dXJlUm9vdCA9IHRoaXMuZnV0dXJlU3RhdGUuX3Jvb3Q7XG4gICAgICAgICAgICB2YXIgY3VyclJvb3QgPSB0aGlzLmN1cnJTdGF0ZSA/IHRoaXMuY3VyclN0YXRlLl9yb290IDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZVJvb3QsIGN1cnJSb290LCBwYXJlbnRDb250ZXh0cyk7XG4gICAgICAgICAgICBhZHZhbmNlQWN0aXZhdGVkUm91dGUodGhpcy5mdXR1cmVTdGF0ZS5yb290KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBEZS1hY3RpdmF0ZSB0aGUgY2hpbGQgcm91dGUgdGhhdCBhcmUgbm90IHJlLXVzZWQgZm9yIHRoZSBmdXR1cmUgc3RhdGVcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRlYWN0aXZhdGVDaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgICAgICAvLyBSZWN1cnNlIG9uIHRoZSByb3V0ZXMgYWN0aXZlIGluIHRoZSBmdXR1cmUgc3RhdGUgdG8gZGUtYWN0aXZhdGUgZGVlcGVyIGNoaWxkcmVuXG4gICAgICAgICAgICBmdXR1cmVOb2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGZ1dHVyZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkT3V0bGV0TmFtZSA9IGZ1dHVyZUNoaWxkLnZhbHVlLm91dGxldDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWFjdGl2YXRlUm91dGVzKGZ1dHVyZUNoaWxkLCBjaGlsZHJlbltjaGlsZE91dGxldE5hbWVdLCBjb250ZXh0cyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkcmVuW2NoaWxkT3V0bGV0TmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIERlLWFjdGl2YXRlIHRoZSByb3V0ZXMgdGhhdCB3aWxsIG5vdCBiZSByZS11c2VkXG4gICAgICAgICAgICBmb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAodiwgY2hpbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4odiwgY29udGV4dHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFjdGl2YXRlUm91dGVzLnByb3RvdHlwZS5kZWFjdGl2YXRlUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjdXJyID0gY3Vyck5vZGUgPyBjdXJyTm9kZS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZnV0dXJlID09PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV1c2luZyB0aGUgbm9kZSwgY2hlY2sgdG8gc2VlIGlmIHRoZSBjaGlsZHJlbiBuZWVkIHRvIGJlIGRlLWFjdGl2YXRlZFxuICAgICAgICAgICAgICAgIGlmIChmdXR1cmUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBub3JtYWwgcm91dGUsIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBhbiBvdXRsZXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50Q29udGV4dC5nZXRDb250ZXh0KGZ1dHVyZS5vdXRsZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgY3VycmVudCByb3V0ZSB3aGljaCB3aWxsIG5vdCBiZSByZS11c2VkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4oY3Vyck5vZGUsIHBhcmVudENvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuID0gZnVuY3Rpb24gKHJvdXRlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5LnNob3VsZERldGFjaChyb3V0ZS52YWx1ZS5zbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEFuZFN0b3JlUm91dGVTdWJ0cmVlKHJvdXRlLCBwYXJlbnRDb250ZXh0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVSb3V0ZUFuZE91dGxldChyb3V0ZSwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuZGV0YWNoQW5kU3RvcmVSb3V0ZVN1YnRyZWUgPSBmdW5jdGlvbiAocm91dGUsIHBhcmVudENvbnRleHRzKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzLmdldENvbnRleHQocm91dGUudmFsdWUub3V0bGV0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbnRleHQub3V0bGV0LmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IGNvbnRleHQuY2hpbGRyZW4ub25PdXRsZXREZWFjdGl2YXRlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5LnN0b3JlKHJvdXRlLnZhbHVlLnNuYXBzaG90LCB7IGNvbXBvbmVudFJlZjogY29tcG9uZW50UmVmLCByb3V0ZTogcm91dGUsIGNvbnRleHRzOiBjb250ZXh0cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmRlYWN0aXZhdGVSb3V0ZUFuZE91dGxldCA9IGZ1bmN0aW9uIChyb3V0ZSwgcGFyZW50Q29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzLmdldENvbnRleHQocm91dGUudmFsdWUub3V0bGV0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZUNoaWxkcmVuQXNNYXAocm91dGUpO1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0c18xID0gcm91dGUudmFsdWUuY29tcG9uZW50ID8gY29udGV4dC5jaGlsZHJlbiA6IHBhcmVudENvbnRleHRzO1xuICAgICAgICAgICAgICAgIGZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBfdGhpcy5kZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbih2LCBjb250ZXh0c18xKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQub3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldC5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIGNvbnRleHRzIGZvciBhbGwgdGhlIG91dGxldHMgdGhhdCB3ZXJlIGluIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jaGlsZHJlbi5vbk91dGxldERlYWN0aXZhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBY3RpdmF0ZVJvdXRlcy5wcm90b3R5cGUuYWN0aXZhdGVDaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIChmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlQ2hpbGRyZW5Bc01hcChjdXJyTm9kZSk7XG4gICAgICAgICAgICBmdXR1cmVOb2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZVJvdXRlcyhjLCBjaGlsZHJlbltjLnZhbHVlLm91dGxldF0sIGNvbnRleHRzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5mb3J3YXJkRXZlbnQobmV3IEFjdGl2YXRpb25FbmQoYy52YWx1ZS5zbmFwc2hvdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZnV0dXJlTm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRFdmVudChuZXcgQ2hpbGRBY3RpdmF0aW9uRW5kKGZ1dHVyZU5vZGUudmFsdWUuc25hcHNob3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWN0aXZhdGVSb3V0ZXMucHJvdG90eXBlLmFjdGl2YXRlUm91dGVzID0gZnVuY3Rpb24gKGZ1dHVyZU5vZGUsIGN1cnJOb2RlLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICAgICAgdmFyIGZ1dHVyZSA9IGZ1dHVyZU5vZGUudmFsdWU7XG4gICAgICAgICAgICB2YXIgY3VyciA9IGN1cnJOb2RlID8gY3Vyck5vZGUudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKGZ1dHVyZSk7XG4gICAgICAgICAgICAvLyByZXVzaW5nIHRoZSBub2RlXG4gICAgICAgICAgICBpZiAoZnV0dXJlID09PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1dHVyZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5vcm1hbCByb3V0ZSwgd2UgbmVlZCB0byBnbyB0aHJvdWdoIGFuIG91dGxldC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0cy5nZXRPckNyZWF0ZUNvbnRleHQoZnV0dXJlLm91dGxldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVDaGlsZFJvdXRlcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgY29udGV4dC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIHBhcmVudENvbnRleHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZnV0dXJlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbm9ybWFsIHJvdXRlLCB3ZSBuZWVkIHRvIHBsYWNlIHRoZSBjb21wb25lbnQgaW50byB0aGUgb3V0bGV0IGFuZCByZWN1cnNlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHBhcmVudENvbnRleHRzLmdldE9yQ3JlYXRlQ29udGV4dChmdXR1cmUub3V0bGV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5LnNob3VsZEF0dGFjaChmdXR1cmUuc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVkID0gdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3kucmV0cmlldmUoZnV0dXJlLnNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm91dGVSZXVzZVN0cmF0ZWd5LnN0b3JlKGZ1dHVyZS5zbmFwc2hvdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkcmVuLm9uT3V0bGV0UmVBdHRhY2hlZChzdG9yZWQuY29udGV4dHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hSZWYgPSBzdG9yZWQuY29tcG9uZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3V0ZSA9IHN0b3JlZC5yb3V0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm91dGxldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCByaWdodCBhd2F5IHdoZW4gdGhlIG91dGxldCBoYXMgYWxyZWFkeSBiZWVuIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhdHRhY2ggZnJvbSBgUm91dGVyT3V0bGV0Lm5nT25Jbml0YCB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3V0bGV0LmF0dGFjaChzdG9yZWQuY29tcG9uZW50UmVmLCBzdG9yZWQucm91dGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlTm9kZUFuZEl0c0NoaWxkcmVuKHN0b3JlZC5yb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gcGFyZW50TG9hZGVkQ29uZmlnKGZ1dHVyZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY21wRmFjdG9yeVJlc29sdmVyID0gY29uZmlnID8gY29uZmlnLm1vZHVsZS5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hdHRhY2hSZWYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3V0ZSA9IGZ1dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzb2x2ZXIgPSBjbXBGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vdXRsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgb3V0bGV0IHdoZW4gaXQgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgd2lsbCBnZXQgYWN0aXZhdGVkIGZyb20gaXRzIGBuZ09uSW5pdGAgd2hlbiBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldC5hY3RpdmF0ZVdpdGgoZnV0dXJlLCBjbXBGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUNoaWxkUm91dGVzKGZ1dHVyZU5vZGUsIG51bGwsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlQ2hpbGRSb3V0ZXMoZnV0dXJlTm9kZSwgbnVsbCwgcGFyZW50Q29udGV4dHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRlUm91dGVzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gYWR2YW5jZUFjdGl2YXRlZFJvdXRlTm9kZUFuZEl0c0NoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgYWR2YW5jZUFjdGl2YXRlZFJvdXRlKG5vZGUudmFsdWUpO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goYWR2YW5jZUFjdGl2YXRlZFJvdXRlTm9kZUFuZEl0c0NoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyZW50TG9hZGVkQ29uZmlnKHNuYXBzaG90KSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBzbmFwc2hvdC5wYXJlbnQ7IHM7IHMgPSBzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHJvdXRlID0gcy5yb3V0ZUNvbmZpZztcbiAgICAgICAgICAgIGlmIChyb3V0ZSAmJiByb3V0ZS5fbG9hZGVkQ29uZmlnKVxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZS5fbG9hZGVkQ29uZmlnO1xuICAgICAgICAgICAgaWYgKHJvdXRlICYmIHJvdXRlLmNvbXBvbmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2ltcGxlIGZ1bmN0aW9uIGNoZWNrLCBidXQgZ2VuZXJpYyBzbyB0eXBlIGluZmVyZW5jZSB3aWxsIGZsb3cuIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBwcm9kdWN0KGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gICAgICogICByZXR1cm4gYSAqIGI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogaWYgKGlzRnVuY3Rpb248cHJvZHVjdD4oZm4pKSB7XG4gICAgICogICByZXR1cm4gZm4oMSwgMik7XG4gICAgICogfSBlbHNlIHtcbiAgICAgKiAgIHRocm93IFwiTXVzdCBwcm92aWRlIHRoZSBgcHJvZHVjdGAgZnVuY3Rpb25cIjtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnYm9vbGVhbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVXJsVHJlZSh2KSB7XG4gICAgICAgIHJldHVybiB2IGluc3RhbmNlb2YgVXJsVHJlZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDYW5Mb2FkKGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBndWFyZCAmJiBpc0Z1bmN0aW9uKGd1YXJkLmNhbkxvYWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NhbkFjdGl2YXRlKGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBndWFyZCAmJiBpc0Z1bmN0aW9uKGd1YXJkLmNhbkFjdGl2YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNDYW5BY3RpdmF0ZUNoaWxkKGd1YXJkKSB7XG4gICAgICAgIHJldHVybiBndWFyZCAmJiBpc0Z1bmN0aW9uKGd1YXJkLmNhbkFjdGl2YXRlQ2hpbGQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NhbkRlYWN0aXZhdGUoZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGd1YXJkICYmIGlzRnVuY3Rpb24oZ3VhcmQuY2FuRGVhY3RpdmF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBOb01hdGNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOb01hdGNoKHNlZ21lbnRHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50R3JvdXAgPSBzZWdtZW50R3JvdXAgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9NYXRjaDtcbiAgICB9KCkpO1xuICAgIHZhciBBYnNvbHV0ZVJlZGlyZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnNvbHV0ZVJlZGlyZWN0KHVybFRyZWUpIHtcbiAgICAgICAgICAgIHRoaXMudXJsVHJlZSA9IHVybFRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFic29sdXRlUmVkaXJlY3Q7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBub01hdGNoKHNlZ21lbnRHcm91cCkge1xuICAgICAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IobmV3IE5vTWF0Y2goc2VnbWVudEdyb3VwKSk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhYnNvbHV0ZVJlZGlyZWN0KG5ld1RyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLmVycm9yKG5ldyBBYnNvbHV0ZVJlZGlyZWN0KG5ld1RyZWUpKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hbWVkT3V0bGV0c1JlZGlyZWN0KHJlZGlyZWN0VG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyByeGpzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLmVycm9yKG5ldyBFcnJvcihcIk9ubHkgYWJzb2x1dGUgcmVkaXJlY3RzIGNhbiBoYXZlIG5hbWVkIG91dGxldHMuIHJlZGlyZWN0VG86ICdcIiArIHJlZGlyZWN0VG8gKyBcIidcIikpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuTG9hZEZhaWxzKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy5lcnJvcihuYXZpZ2F0aW9uQ2FuY2VsaW5nRXJyb3IoXCJDYW5ub3QgbG9hZCBjaGlsZHJlbiBiZWNhdXNlIHRoZSBndWFyZCBvZiB0aGUgcm91dGUgXFxcInBhdGg6ICdcIiArIHJvdXRlLnBhdGggKyBcIidcXFwiIHJldHVybmVkIGZhbHNlXCIpKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBVcmxUcmVlYCB3aXRoIHRoZSByZWRpcmVjdGlvbiBhcHBsaWVkLlxuICAgICAqXG4gICAgICogTGF6eSBtb2R1bGVzIGFyZSBsb2FkZWQgYWxvbmcgdGhlIHdheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB1cmxUcmVlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB1cmxUcmVlLCBjb25maWcpLmFwcGx5KCk7XG4gICAgfVxuICAgIHZhciBBcHBseVJlZGlyZWN0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHlSZWRpcmVjdHMobW9kdWxlSW5qZWN0b3IsIGNvbmZpZ0xvYWRlciwgdXJsU2VyaWFsaXplciwgdXJsVHJlZSwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ0xvYWRlciA9IGNvbmZpZ0xvYWRlcjtcbiAgICAgICAgICAgIHRoaXMudXJsU2VyaWFsaXplciA9IHVybFNlcmlhbGl6ZXI7XG4gICAgICAgICAgICB0aGlzLnVybFRyZWUgPSB1cmxUcmVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLmFsbG93UmVkaXJlY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGUgPSBtb2R1bGVJbmplY3Rvci5nZXQoY29yZS5OZ01vZHVsZVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCQgPSB0aGlzLmV4cGFuZFNlZ21lbnRHcm91cCh0aGlzLm5nTW9kdWxlLCB0aGlzLmNvbmZpZywgdGhpcy51cmxUcmVlLnJvb3QsIFBSSU1BUllfT1VUTEVUKTtcbiAgICAgICAgICAgIHZhciB1cmxUcmVlcyQgPSBleHBhbmRlZCQucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChyb290U2VnbWVudEdyb3VwKSB7IHJldHVybiBfdGhpcy5jcmVhdGVVcmxUcmVlKHJvb3RTZWdtZW50R3JvdXAsIF90aGlzLnVybFRyZWUucXVlcnlQYXJhbXMsIF90aGlzLnVybFRyZWUuZnJhZ21lbnQpOyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdXJsVHJlZXMkLnBpcGUob3BlcmF0b3JzLmNhdGNoRXJyb3IoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFic29sdXRlUmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgYW4gYWJzb2x1dGUgcmVkaXJlY3Qgd2UgZG8gbm90IGFwcGx5IGFueSBtb3JlIHJlZGlyZWN0cyFcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWxsb3dSZWRpcmVjdHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBydW4gbWF0Y2hpbmcsIHNvIHdlIGNhbiBmZXRjaCBhbGwgbGF6eS1sb2FkZWQgbW9kdWxlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWF0Y2goZS51cmxUcmVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLm5vTWF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhwYW5kZWQkID0gdGhpcy5leHBhbmRTZWdtZW50R3JvdXAodGhpcy5uZ01vZHVsZSwgdGhpcy5jb25maWcsIHRyZWUucm9vdCwgUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICAgICAgdmFyIG1hcHBlZCQgPSBleHBhbmRlZCQucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChyb290U2VnbWVudEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZVVybFRyZWUocm9vdFNlZ21lbnRHcm91cCwgdHJlZS5xdWVyeVBhcmFtcywgdHJlZS5mcmFnbWVudCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkJC5waXBlKG9wZXJhdG9ycy5jYXRjaEVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLm5vTWF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLm5vTWF0Y2hFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQ2Fubm90IG1hdGNoIGFueSByb3V0ZXMuIFVSTCBTZWdtZW50OiAnXCIgKyBlLnNlZ21lbnRHcm91cCArIFwiJ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmNyZWF0ZVVybFRyZWUgPSBmdW5jdGlvbiAocm9vdENhbmRpZGF0ZSwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDYW5kaWRhdGUuc2VnbWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgbmV3IFVybFNlZ21lbnRHcm91cChbXSwgKF9hID0ge30sIF9hW1BSSU1BUllfT1VUTEVUXSA9IHJvb3RDYW5kaWRhdGUsIF9hKSkgOlxuICAgICAgICAgICAgICAgIHJvb3RDYW5kaWRhdGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFRyZWUocm9vdCwgcXVlcnlQYXJhbXMsIGZyYWdtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFNlZ21lbnRHcm91cCA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGVzLCBzZWdtZW50R3JvdXAsIG91dGxldCkge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRHcm91cC5zZWdtZW50cy5sZW5ndGggPT09IDAgJiYgc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRDaGlsZHJlbihuZ01vZHVsZSwgcm91dGVzLCBzZWdtZW50R3JvdXApXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGNoaWxkcmVuKSB7IHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCBjaGlsZHJlbik7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNlZ21lbnQobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCBzZWdtZW50R3JvdXAuc2VnbWVudHMsIG91dGxldCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGV4cGFuZCBzZWdtZW50IGdyb3VwcyBmb3IgYWxsIHRoZSBjaGlsZCBvdXRsZXRzXG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5leHBhbmRDaGlsZHJlbiA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGVzLCBzZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gd2FpdEZvck1hcChzZWdtZW50R3JvdXAuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZE91dGxldCwgY2hpbGQpIHsgcmV0dXJuIF90aGlzLmV4cGFuZFNlZ21lbnRHcm91cChuZ01vZHVsZSwgcm91dGVzLCBjaGlsZCwgY2hpbGRPdXRsZXQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFNlZ21lbnQgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCBzZWdtZW50cywgb3V0bGV0LCBhbGxvd1JlZGlyZWN0cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiByeGpzLm9mLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQocm91dGVzKSkucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkJCA9IF90aGlzLmV4cGFuZFNlZ21lbnRBZ2FpbnN0Um91dGUobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCByLCBzZWdtZW50cywgb3V0bGV0LCBhbGxvd1JlZGlyZWN0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkJC5waXBlKG9wZXJhdG9ycy5jYXRjaEVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm9NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhpKTogdGhpcyByZXR1cm4gdHlwZSBkb2Vzbid0IG1hdGNoIHRoZSBkZWNsYXJlZCBPYnNlcnZhYmxlPFVybFNlZ21lbnRHcm91cD4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFsayB0byBKYXNvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSwgb3BlcmF0b3JzLmNvbmNhdEFsbCgpLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICEhczsgfSksIG9wZXJhdG9ycy5jYXRjaEVycm9yKGZ1bmN0aW9uIChlLCBfKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiByeGpzLkVtcHR5RXJyb3IgfHwgZS5uYW1lID09PSAnRW1wdHlFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm5vTGVmdG92ZXJzSW5Vcmwoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YobmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaChzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUubm9MZWZ0b3ZlcnNJblVybCA9IGZ1bmN0aW9uIChzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXNlZ21lbnRHcm91cC5jaGlsZHJlbltvdXRsZXRdO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZXhwYW5kU2VnbWVudEFnYWluc3RSb3V0ZSA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHJvdXRlLCBwYXRocywgb3V0bGV0LCBhbGxvd1JlZGlyZWN0cykge1xuICAgICAgICAgICAgaWYgKGdldE91dGxldChyb3V0ZSkgIT09IG91dGxldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoKHNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm91dGUucmVkaXJlY3RUbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hTZWdtZW50QWdhaW5zdFJvdXRlKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlLCBwYXRocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dSZWRpcmVjdHMgJiYgdGhpcy5hbGxvd1JlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNlZ21lbnRBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0KG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgcm91dGUsIHBhdGhzLCBvdXRsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vTWF0Y2goc2VnbWVudEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFNlZ21lbnRBZ2FpbnN0Um91dGVVc2luZ1JlZGlyZWN0ID0gZnVuY3Rpb24gKG5nTW9kdWxlLCBzZWdtZW50R3JvdXAsIHJvdXRlcywgcm91dGUsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kV2lsZENhcmRXaXRoUGFyYW1zQWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChuZ01vZHVsZSwgcm91dGVzLCByb3V0ZSwgb3V0bGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFJlZ3VsYXJTZWdtZW50QWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHJvdXRlLCBzZWdtZW50cywgb3V0bGV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFdpbGRDYXJkV2l0aFBhcmFtc0FnYWluc3RSb3V0ZVVzaW5nUmVkaXJlY3QgPSBmdW5jdGlvbiAobmdNb2R1bGUsIHJvdXRlcywgcm91dGUsIG91dGxldCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBuZXdUcmVlID0gdGhpcy5hcHBseVJlZGlyZWN0Q29tbWFuZHMoW10sIHJvdXRlLnJlZGlyZWN0VG8sIHt9KTtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhYnNvbHV0ZVJlZGlyZWN0KG5ld1RyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZXJhbGl6ZVNlZ21lbnRzKHJvdXRlLCBuZXdUcmVlKS5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAobmV3U2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgVXJsU2VnbWVudEdyb3VwKG5ld1NlZ21lbnRzLCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4cGFuZFNlZ21lbnQobmdNb2R1bGUsIGdyb3VwLCByb3V0ZXMsIG5ld1NlZ21lbnRzLCBvdXRsZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbHlSZWRpcmVjdHMucHJvdG90eXBlLmV4cGFuZFJlZ3VsYXJTZWdtZW50QWdhaW5zdFJvdXRlVXNpbmdSZWRpcmVjdCA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgc2VnbWVudEdyb3VwLCByb3V0ZXMsIHJvdXRlLCBzZWdtZW50cywgb3V0bGV0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hID0gbWF0Y2goc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpLCBtYXRjaGVkID0gX2EubWF0Y2hlZCwgY29uc3VtZWRTZWdtZW50cyA9IF9hLmNvbnN1bWVkU2VnbWVudHMsIGxhc3RDaGlsZCA9IF9hLmxhc3RDaGlsZCwgcG9zaXRpb25hbFBhcmFtU2VnbWVudHMgPSBfYS5wb3NpdGlvbmFsUGFyYW1TZWdtZW50cztcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9NYXRjaChzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgdmFyIG5ld1RyZWUgPSB0aGlzLmFwcGx5UmVkaXJlY3RDb21tYW5kcyhjb25zdW1lZFNlZ21lbnRzLCByb3V0ZS5yZWRpcmVjdFRvLCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50cyk7XG4gICAgICAgICAgICBpZiAocm91dGUucmVkaXJlY3RUby5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJzb2x1dGVSZWRpcmVjdChuZXdUcmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVyYWxpemVTZWdtZW50cyhyb3V0ZSwgbmV3VHJlZSkucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKG5ld1NlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4cGFuZFNlZ21lbnQobmdNb2R1bGUsIHNlZ21lbnRHcm91cCwgcm91dGVzLCBuZXdTZWdtZW50cy5jb25jYXQoc2VnbWVudHMuc2xpY2UobGFzdENoaWxkKSksIG91dGxldCwgZmFsc2UpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUubWF0Y2hTZWdtZW50QWdhaW5zdFJvdXRlID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByYXdTZWdtZW50R3JvdXAsIHJvdXRlLCBzZWdtZW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWdMb2FkZXIubG9hZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlLl9sb2FkZWRDb25maWcgPSBjZmc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50cywge30pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG5ldyBVcmxTZWdtZW50R3JvdXAoc2VnbWVudHMsIHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSBtYXRjaChyYXdTZWdtZW50R3JvdXAsIHJvdXRlLCBzZWdtZW50cyksIG1hdGNoZWQgPSBfYS5tYXRjaGVkLCBjb25zdW1lZFNlZ21lbnRzID0gX2EuY29uc3VtZWRTZWdtZW50cywgbGFzdENoaWxkID0gX2EubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBub01hdGNoKHJhd1NlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICB2YXIgcmF3U2xpY2VkU2VnbWVudHMgPSBzZWdtZW50cy5zbGljZShsYXN0Q2hpbGQpO1xuICAgICAgICAgICAgdmFyIGNoaWxkQ29uZmlnJCA9IHRoaXMuZ2V0Q2hpbGRDb25maWcobmdNb2R1bGUsIHJvdXRlLCBzZWdtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRDb25maWckLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChyb3V0ZXJDb25maWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRNb2R1bGUgPSByb3V0ZXJDb25maWcubW9kdWxlO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbmZpZyA9IHJvdXRlckNvbmZpZy5yb3V0ZXM7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gc3BsaXQocmF3U2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCByYXdTbGljZWRTZWdtZW50cywgY2hpbGRDb25maWcpLCBzZWdtZW50R3JvdXAgPSBfYS5zZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzID0gX2Euc2xpY2VkU2VnbWVudHM7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWQkXzEgPSBfdGhpcy5leHBhbmRDaGlsZHJlbihjaGlsZE1vZHVsZSwgY2hpbGRDb25maWcsIHNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCRfMS5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGNoaWxkcmVuKSB7IHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKGNvbnN1bWVkU2VnbWVudHMsIGNoaWxkcmVuKTsgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDb25maWcubGVuZ3RoID09PSAwICYmIHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihuZXcgVXJsU2VnbWVudEdyb3VwKGNvbnN1bWVkU2VnbWVudHMsIHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZCQgPSBfdGhpcy5leHBhbmRTZWdtZW50KGNoaWxkTW9kdWxlLCBzZWdtZW50R3JvdXAsIGNoaWxkQ29uZmlnLCBzbGljZWRTZWdtZW50cywgUFJJTUFSWV9PVVRMRVQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCQucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChjcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChjb25zdW1lZFNlZ21lbnRzLmNvbmNhdChjcy5zZWdtZW50cyksIGNzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5nZXRDaGlsZENvbmZpZyA9IGZ1bmN0aW9uIChuZ01vZHVsZSwgcm91dGUsIHNlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGJlbG9uZyB0byB0aGUgc2FtZSBtb2R1bGVcbiAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihuZXcgTG9hZGVkUm91dGVyQ29uZmlnKHJvdXRlLmNoaWxkcmVuLCBuZ01vZHVsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIC8vIGxhenkgY2hpbGRyZW4gYmVsb25nIHRvIHRoZSBsb2FkZWQgbW9kdWxlXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlLl9sb2FkZWRDb25maWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihyb3V0ZS5fbG9hZGVkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bkNhbkxvYWRHdWFyZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUsIHNlZ21lbnRzKVxuICAgICAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWVyZ2VNYXAoZnVuY3Rpb24gKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb25maWdMb2FkZXIubG9hZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUuX2xvYWRlZENvbmZpZyA9IGNmZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2ZnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5Mb2FkRmFpbHMocm91dGUpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG5ldyBMb2FkZWRSb3V0ZXJDb25maWcoW10sIG5nTW9kdWxlKSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5saW5lcmFsaXplU2VnbWVudHMgPSBmdW5jdGlvbiAocm91dGUsIHVybFRyZWUpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjID0gdXJsVHJlZS5yb290O1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGMuc2VnbWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChjLm51bWJlck9mQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMubnVtYmVyT2ZDaGlsZHJlbiA+IDEgfHwgIWMuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lZE91dGxldHNSZWRpcmVjdChyb3V0ZS5yZWRpcmVjdFRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYyA9IGMuY2hpbGRyZW5bUFJJTUFSWV9PVVRMRVRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuYXBwbHlSZWRpcmVjdENvbW1hbmRzID0gZnVuY3Rpb24gKHNlZ21lbnRzLCByZWRpcmVjdFRvLCBwb3NQYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5UmVkaXJlY3RDcmVhdHJlVXJsVHJlZShyZWRpcmVjdFRvLCB0aGlzLnVybFNlcmlhbGl6ZXIucGFyc2UocmVkaXJlY3RUbyksIHNlZ21lbnRzLCBwb3NQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuYXBwbHlSZWRpcmVjdENyZWF0cmVVcmxUcmVlID0gZnVuY3Rpb24gKHJlZGlyZWN0VG8sIHVybFRyZWUsIHNlZ21lbnRzLCBwb3NQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdSb290ID0gdGhpcy5jcmVhdGVTZWdtZW50R3JvdXAocmVkaXJlY3RUbywgdXJsVHJlZS5yb290LCBzZWdtZW50cywgcG9zUGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsVHJlZShuZXdSb290LCB0aGlzLmNyZWF0ZVF1ZXJ5UGFyYW1zKHVybFRyZWUucXVlcnlQYXJhbXMsIHRoaXMudXJsVHJlZS5xdWVyeVBhcmFtcyksIHVybFRyZWUuZnJhZ21lbnQpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuY3JlYXRlUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAocmVkaXJlY3RUb1BhcmFtcywgYWN0dWFsUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgICAgICBmb3JFYWNoKHJlZGlyZWN0VG9QYXJhbXMsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcHlTb3VyY2VWYWx1ZSA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyAmJiB2LnN0YXJ0c1dpdGgoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoY29weVNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOYW1lID0gdi5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trXSA9IGFjdHVhbFBhcmFtc1tzb3VyY2VOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuY3JlYXRlU2VnbWVudEdyb3VwID0gZnVuY3Rpb24gKHJlZGlyZWN0VG8sIGdyb3VwLCBzZWdtZW50cywgcG9zUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZWdtZW50cyA9IHRoaXMuY3JlYXRlU2VnbWVudHMocmVkaXJlY3RUbywgZ3JvdXAuc2VnbWVudHMsIHNlZ21lbnRzLCBwb3NQYXJhbXMpO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0ge307XG4gICAgICAgICAgICBmb3JFYWNoKGdyb3VwLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IF90aGlzLmNyZWF0ZVNlZ21lbnRHcm91cChyZWRpcmVjdFRvLCBjaGlsZCwgc2VnbWVudHMsIHBvc1BhcmFtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsU2VnbWVudEdyb3VwKHVwZGF0ZWRTZWdtZW50cywgY2hpbGRyZW4pO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuY3JlYXRlU2VnbWVudHMgPSBmdW5jdGlvbiAocmVkaXJlY3RUbywgcmVkaXJlY3RUb1NlZ21lbnRzLCBhY3R1YWxTZWdtZW50cywgcG9zUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0VG9TZWdtZW50cy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucGF0aC5zdGFydHNXaXRoKCc6JykgPyBfdGhpcy5maW5kUG9zUGFyYW0ocmVkaXJlY3RUbywgcywgcG9zUGFyYW1zKSA6XG4gICAgICAgICAgICAgICAgX3RoaXMuZmluZE9yUmV0dXJuKHMsIGFjdHVhbFNlZ21lbnRzKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGx5UmVkaXJlY3RzLnByb3RvdHlwZS5maW5kUG9zUGFyYW0gPSBmdW5jdGlvbiAocmVkaXJlY3RUbywgcmVkaXJlY3RUb1VybFNlZ21lbnQsIHBvc1BhcmFtcykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHBvc1BhcmFtc1tyZWRpcmVjdFRvVXJsU2VnbWVudC5wYXRoLnN1YnN0cmluZygxKV07XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVkaXJlY3QgdG8gJ1wiICsgcmVkaXJlY3RUbyArIFwiJy4gQ2Fubm90IGZpbmQgJ1wiICsgcmVkaXJlY3RUb1VybFNlZ21lbnQucGF0aCArIFwiJy5cIik7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9O1xuICAgICAgICBBcHBseVJlZGlyZWN0cy5wcm90b3R5cGUuZmluZE9yUmV0dXJuID0gZnVuY3Rpb24gKHJlZGlyZWN0VG9VcmxTZWdtZW50LCBhY3R1YWxTZWdtZW50cykge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYWN0dWFsU2VnbWVudHNfMSA9IF9fdmFsdWVzKGFjdHVhbFNlZ21lbnRzKSwgYWN0dWFsU2VnbWVudHNfMV8xID0gYWN0dWFsU2VnbWVudHNfMS5uZXh0KCk7ICFhY3R1YWxTZWdtZW50c18xXzEuZG9uZTsgYWN0dWFsU2VnbWVudHNfMV8xID0gYWN0dWFsU2VnbWVudHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhY3R1YWxTZWdtZW50c18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnBhdGggPT09IHJlZGlyZWN0VG9VcmxTZWdtZW50LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFNlZ21lbnRzLnNwbGljZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3R1YWxTZWdtZW50c18xXzEgJiYgIWFjdHVhbFNlZ21lbnRzXzFfMS5kb25lICYmIChfYSA9IGFjdHVhbFNlZ21lbnRzXzEucmV0dXJuKSkgX2EuY2FsbChhY3R1YWxTZWdtZW50c18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0VG9VcmxTZWdtZW50O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXBwbHlSZWRpcmVjdHM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBydW5DYW5Mb2FkR3VhcmQobW9kdWxlSW5qZWN0b3IsIHJvdXRlLCBzZWdtZW50cykge1xuICAgICAgICB2YXIgY2FuTG9hZCA9IHJvdXRlLmNhbkxvYWQ7XG4gICAgICAgIGlmICghY2FuTG9hZCB8fCBjYW5Mb2FkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHRydWUpO1xuICAgICAgICB2YXIgb2JzID0gcnhqcy5mcm9tKGNhbkxvYWQpLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoaW5qZWN0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBndWFyZCA9IG1vZHVsZUluamVjdG9yLmdldChpbmplY3Rpb25Ub2tlbik7XG4gICAgICAgICAgICB2YXIgZ3VhcmRWYWw7XG4gICAgICAgICAgICBpZiAoaXNDYW5Mb2FkKGd1YXJkKSkge1xuICAgICAgICAgICAgICAgIGd1YXJkVmFsID0gZ3VhcmQuY2FuTG9hZChyb3V0ZSwgc2VnbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihndWFyZCkpIHtcbiAgICAgICAgICAgICAgICBndWFyZFZhbCA9IGd1YXJkKHJvdXRlLCBzZWdtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ2FuTG9hZCBndWFyZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZFZhbCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG9icy5waXBlKG9wZXJhdG9ycy5jb25jYXRBbGwoKSwgb3BlcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTsgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaChzZWdtZW50R3JvdXAsIHJvdXRlLCBzZWdtZW50cykge1xuICAgICAgICBpZiAocm91dGUucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmICgocm91dGUucGF0aE1hdGNoID09PSAnZnVsbCcpICYmIChzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSB8fCBzZWdtZW50cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1hdGNoZWQ6IGZhbHNlLCBjb25zdW1lZFNlZ21lbnRzOiBbXSwgbGFzdENoaWxkOiAwLCBwb3NpdGlvbmFsUGFyYW1TZWdtZW50czoge30gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoZWQ6IHRydWUsIGNvbnN1bWVkU2VnbWVudHM6IFtdLCBsYXN0Q2hpbGQ6IDAsIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVyID0gcm91dGUubWF0Y2hlciB8fCBkZWZhdWx0VXJsTWF0Y2hlcjtcbiAgICAgICAgdmFyIHJlcyA9IG1hdGNoZXIoc2VnbWVudHMsIHNlZ21lbnRHcm91cCwgcm91dGUpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25zdW1lZFNlZ21lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGQ6IDAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25hbFBhcmFtU2VnbWVudHM6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnN1bWVkU2VnbWVudHM6IHJlcy5jb25zdW1lZCxcbiAgICAgICAgICAgIGxhc3RDaGlsZDogcmVzLmNvbnN1bWVkLmxlbmd0aCxcbiAgICAgICAgICAgIHBvc2l0aW9uYWxQYXJhbVNlZ21lbnRzOiByZXMucG9zUGFyYW1zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdChzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zRW1wdHlQYXRoUmVkaXJlY3RzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cywgY3JlYXRlQ2hpbGRyZW5Gb3JFbXB0eVNlZ21lbnRzKGNvbmZpZywgbmV3IFVybFNlZ21lbnRHcm91cChzbGljZWRTZWdtZW50cywgc2VnbWVudEdyb3VwLmNoaWxkcmVuKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBtZXJnZVRyaXZpYWxDaGlsZHJlbihzKSwgc2xpY2VkU2VnbWVudHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgY29udGFpbnNFbXB0eVBhdGhSZWRpcmVjdHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywgYWRkRW1wdHlTZWdtZW50c1RvQ2hpbGRyZW5JZk5lZWRlZChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcsIHNlZ21lbnRHcm91cC5jaGlsZHJlbikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBtZXJnZVRyaXZpYWxDaGlsZHJlbihzKSwgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzOiBzbGljZWRTZWdtZW50cyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVRyaXZpYWxDaGlsZHJlbihzKSB7XG4gICAgICAgIGlmIChzLm51bWJlck9mQ2hpbGRyZW4gPT09IDEgJiYgcy5jaGlsZHJlbltQUklNQVJZX09VVExFVF0pIHtcbiAgICAgICAgICAgIHZhciBjID0gcy5jaGlsZHJlbltQUklNQVJZX09VVExFVF07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzLnNlZ21lbnRzLmNvbmNhdChjLnNlZ21lbnRzKSwgYy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVtcHR5U2VnbWVudHNUb0NoaWxkcmVuSWZOZWVkZWQoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcm91dGVzLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzEgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpOyAhcm91dGVzXzFfMS5kb25lOyByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5UGF0aFJlZGlyZWN0KHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIHIpICYmICFjaGlsZHJlbltnZXRPdXRsZXQocildKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tnZXRPdXRsZXQocildID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlc18xXzEgJiYgIXJvdXRlc18xXzEuZG9uZSAmJiAoX2EgPSByb3V0ZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHJvdXRlc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIGNoaWxkcmVuLCByZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkZvckVtcHR5U2VnbWVudHMocm91dGVzLCBwcmltYXJ5U2VnbWVudEdyb3VwKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlc1tQUklNQVJZX09VVExFVF0gPSBwcmltYXJ5U2VnbWVudEdyb3VwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzIgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpOyAhcm91dGVzXzJfMS5kb25lOyByb3V0ZXNfMl8xID0gcm91dGVzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyLnBhdGggPT09ICcnICYmIGdldE91dGxldChyKSAhPT0gUFJJTUFSWV9PVVRMRVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2dldE91dGxldChyKV0gPSBuZXcgVXJsU2VnbWVudEdyb3VwKFtdLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzJfMSAmJiAhcm91dGVzXzJfMS5kb25lICYmIChfYSA9IHJvdXRlc18yLnJldHVybikpIF9hLmNhbGwocm91dGVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zRW1wdHlQYXRoUmVkaXJlY3RzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBpc0VtcHR5UGF0aFJlZGlyZWN0KHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIHIpICYmIGdldE91dGxldChyKSAhPT0gUFJJTUFSWV9PVVRMRVQ7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc0VtcHR5UGF0aFJlZGlyZWN0cyhzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBpc0VtcHR5UGF0aFJlZGlyZWN0KHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIHIpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbXB0eVBhdGhSZWRpcmVjdChzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCByKSB7XG4gICAgICAgIGlmICgoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgc2VnbWVudHMubGVuZ3RoID4gMCkgJiYgci5wYXRoTWF0Y2ggPT09ICdmdWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnBhdGggPT09ICcnICYmIHIucmVkaXJlY3RUbyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsZXQocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlLm91dGxldCB8fCBQUklNQVJZX09VVExFVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwbHlSZWRpcmVjdHMkMShtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucGlwZShvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBhcHBseVJlZGlyZWN0cyhtb2R1bGVJbmplY3RvciwgY29uZmlnTG9hZGVyLCB1cmxTZXJpYWxpemVyLCB0LmV4dHJhY3RlZFVybCwgY29uZmlnKVxuICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHVybEFmdGVyUmVkaXJlY3RzKSB7IHJldHVybiAoX19hc3NpZ24oe30sIHQsIHsgdXJsQWZ0ZXJSZWRpcmVjdHM6IHVybEFmdGVyUmVkaXJlY3RzIH0pKTsgfSkpOyB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBDYW5BY3RpdmF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FuQWN0aXZhdGUocGF0aCkge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYW5BY3RpdmF0ZTtcbiAgICB9KCkpO1xuICAgIHZhciBDYW5EZWFjdGl2YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgcm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYW5EZWFjdGl2YXRlO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZ2V0QWxsUm91dGVHdWFyZHMoZnV0dXJlLCBjdXJyLCBwYXJlbnRDb250ZXh0cykge1xuICAgICAgICB2YXIgZnV0dXJlUm9vdCA9IGZ1dHVyZS5fcm9vdDtcbiAgICAgICAgdmFyIGN1cnJSb290ID0gY3VyciA/IGN1cnIuX3Jvb3QgOiBudWxsO1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVSb290LCBjdXJyUm9vdCwgcGFyZW50Q29udGV4dHMsIFtmdXR1cmVSb290LnZhbHVlXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENhbkFjdGl2YXRlQ2hpbGQocCkge1xuICAgICAgICB2YXIgY2FuQWN0aXZhdGVDaGlsZCA9IHAucm91dGVDb25maWcgPyBwLnJvdXRlQ29uZmlnLmNhbkFjdGl2YXRlQ2hpbGQgOiBudWxsO1xuICAgICAgICBpZiAoIWNhbkFjdGl2YXRlQ2hpbGQgfHwgY2FuQWN0aXZhdGVDaGlsZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcCwgZ3VhcmRzOiBjYW5BY3RpdmF0ZUNoaWxkIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRva2VuKHRva2VuLCBzbmFwc2hvdCwgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGdldENsb3Nlc3RMb2FkZWRDb25maWcoc25hcHNob3QpO1xuICAgICAgICB2YXIgaW5qZWN0b3IgPSBjb25maWcgPyBjb25maWcubW9kdWxlLmluamVjdG9yIDogbW9kdWxlSW5qZWN0b3I7XG4gICAgICAgIHJldHVybiBpbmplY3Rvci5nZXQodG9rZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDbG9zZXN0TG9hZGVkQ29uZmlnKHNuYXBzaG90KSB7XG4gICAgICAgIGlmICghc25hcHNob3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgcyA9IHNuYXBzaG90LnBhcmVudDsgczsgcyA9IHMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcm91dGUgPSBzLnJvdXRlQ29uZmlnO1xuICAgICAgICAgICAgaWYgKHJvdXRlICYmIHJvdXRlLl9sb2FkZWRDb25maWcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlLl9sb2FkZWRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoaWxkUm91dGVHdWFyZHMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHRzLCBmdXR1cmVQYXRoLCBjaGVja3MpIHtcbiAgICAgICAgaWYgKGNoZWNrcyA9PT0gdm9pZCAwKSB7IGNoZWNrcyA9IHtcbiAgICAgICAgICAgIGNhbkRlYWN0aXZhdGVDaGVja3M6IFtdLFxuICAgICAgICAgICAgY2FuQWN0aXZhdGVDaGVja3M6IFtdXG4gICAgICAgIH07IH1cbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IG5vZGVDaGlsZHJlbkFzTWFwKGN1cnJOb2RlKTtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hpbGRyZW4gb2YgdGhlIGZ1dHVyZSByb3V0ZVxuICAgICAgICBmdXR1cmVOb2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGdldFJvdXRlR3VhcmRzKGMsIHByZXZDaGlsZHJlbltjLnZhbHVlLm91dGxldF0sIGNvbnRleHRzLCBmdXR1cmVQYXRoLmNvbmNhdChbYy52YWx1ZV0pLCBjaGVja3MpO1xuICAgICAgICAgICAgZGVsZXRlIHByZXZDaGlsZHJlbltjLnZhbHVlLm91dGxldF07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQcm9jZXNzIGFueSBjaGlsZHJlbiBsZWZ0IGZyb20gdGhlIGN1cnJlbnQgcm91dGUgKG5vdCBhY3RpdmUgZm9yIHRoZSBmdXR1cmUgcm91dGUpXG4gICAgICAgIGZvckVhY2gocHJldkNoaWxkcmVuLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgcmV0dXJuIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKHYsIGNvbnRleHRzLmdldENvbnRleHQoayksIGNoZWNrcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dHMsIGZ1dHVyZVBhdGgsIGNoZWNrcykge1xuICAgICAgICBpZiAoY2hlY2tzID09PSB2b2lkIDApIHsgY2hlY2tzID0ge1xuICAgICAgICAgICAgY2FuRGVhY3RpdmF0ZUNoZWNrczogW10sXG4gICAgICAgICAgICBjYW5BY3RpdmF0ZUNoZWNrczogW11cbiAgICAgICAgfTsgfVxuICAgICAgICB2YXIgZnV0dXJlID0gZnV0dXJlTm9kZS52YWx1ZTtcbiAgICAgICAgdmFyIGN1cnIgPSBjdXJyTm9kZSA/IGN1cnJOb2RlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnRDb250ZXh0cyA/IHBhcmVudENvbnRleHRzLmdldENvbnRleHQoZnV0dXJlTm9kZS52YWx1ZS5vdXRsZXQpIDogbnVsbDtcbiAgICAgICAgLy8gcmV1c2luZyB0aGUgbm9kZVxuICAgICAgICBpZiAoY3VyciAmJiBmdXR1cmUucm91dGVDb25maWcgPT09IGN1cnIucm91dGVDb25maWcpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRSdW4gPSBzaG91bGRSdW5HdWFyZHNBbmRSZXNvbHZlcnMoY3VyciwgZnV0dXJlLCBmdXR1cmUucm91dGVDb25maWcucnVuR3VhcmRzQW5kUmVzb2x2ZXJzKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSdW4pIHtcbiAgICAgICAgICAgICAgICBjaGVja3MuY2FuQWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuQWN0aXZhdGUoZnV0dXJlUGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICBmdXR1cmUuZGF0YSA9IGN1cnIuZGF0YTtcbiAgICAgICAgICAgICAgICBmdXR1cmUuX3Jlc29sdmVkRGF0YSA9IGN1cnIuX3Jlc29sdmVkRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBhbiBvdXRsZXQuXG4gICAgICAgICAgICBpZiAoZnV0dXJlLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGdldENoaWxkUm91dGVHdWFyZHMoZnV0dXJlTm9kZSwgY3Vyck5vZGUsIGNvbnRleHQgPyBjb250ZXh0LmNoaWxkcmVuIDogbnVsbCwgZnV0dXJlUGF0aCwgY2hlY2tzKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29tcG9uZW50bGVzcyByb3V0ZSwgd2UgcmVjdXJzZSBidXQga2VlcCB0aGUgc2FtZSBvdXRsZXQgbWFwLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBjdXJyTm9kZSwgcGFyZW50Q29udGV4dHMsIGZ1dHVyZVBhdGgsIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUnVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbnRleHQgJiYgY29udGV4dC5vdXRsZXQgJiYgY29udGV4dC5vdXRsZXQuY29tcG9uZW50IHx8IG51bGw7XG4gICAgICAgICAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShjb21wb25lbnQsIGN1cnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4oY3Vyck5vZGUsIGNvbnRleHQsIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja3MuY2FuQWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuQWN0aXZhdGUoZnV0dXJlUGF0aCkpO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBnbyB0aHJvdWdoIGFuIG91dGxldC5cbiAgICAgICAgICAgIGlmIChmdXR1cmUuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRSb3V0ZUd1YXJkcyhmdXR1cmVOb2RlLCBudWxsLCBjb250ZXh0ID8gY29udGV4dC5jaGlsZHJlbiA6IG51bGwsIGZ1dHVyZVBhdGgsIGNoZWNrcyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGNvbXBvbmVudGxlc3Mgcm91dGUsIHdlIHJlY3Vyc2UgYnV0IGtlZXAgdGhlIHNhbWUgb3V0bGV0IG1hcC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldENoaWxkUm91dGVHdWFyZHMoZnV0dXJlTm9kZSwgbnVsbCwgcGFyZW50Q29udGV4dHMsIGZ1dHVyZVBhdGgsIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoZWNrcztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUnVuR3VhcmRzQW5kUmVzb2x2ZXJzKGN1cnIsIGZ1dHVyZSwgbW9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlKGN1cnIsIGZ1dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdwYXRoUGFyYW1zQ2hhbmdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVxdWFsUGF0aChjdXJyLnVybCwgZnV0dXJlLnVybCk7XG4gICAgICAgICAgICBjYXNlICdwYXRoUGFyYW1zT3JRdWVyeVBhcmFtc0NoYW5nZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlcXVhbFBhdGgoY3Vyci51cmwsIGZ1dHVyZS51cmwpIHx8XG4gICAgICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwoY3Vyci5xdWVyeVBhcmFtcywgZnV0dXJlLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICdwYXJhbXNPclF1ZXJ5UGFyYW1zQ2hhbmdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoY3VyciwgZnV0dXJlKSB8fFxuICAgICAgICAgICAgICAgICAgICAhc2hhbGxvd0VxdWFsKGN1cnIucXVlcnlQYXJhbXMsIGZ1dHVyZS5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICBjYXNlICdwYXJhbXNDaGFuZ2UnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVxdWFsUGFyYW1zQW5kVXJsU2VnbWVudHMoY3VyciwgZnV0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbihyb3V0ZSwgY29udGV4dCwgY2hlY2tzKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGVDaGlsZHJlbkFzTWFwKHJvdXRlKTtcbiAgICAgICAgdmFyIHIgPSByb3V0ZS52YWx1ZTtcbiAgICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUsIGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFyLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVSb3V0ZUFuZEl0c0NoaWxkcmVuKG5vZGUsIGNvbnRleHQsIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgZGVhY3RpdmF0ZVJvdXRlQW5kSXRzQ2hpbGRyZW4obm9kZSwgY29udGV4dC5jaGlsZHJlbi5nZXRDb250ZXh0KGNoaWxkTmFtZSksIGNoZWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWFjdGl2YXRlUm91dGVBbmRJdHNDaGlsZHJlbihub2RlLCBudWxsLCBjaGVja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShudWxsLCByKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm91dGxldCAmJiBjb250ZXh0Lm91dGxldC5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgY2hlY2tzLmNhbkRlYWN0aXZhdGVDaGVja3MucHVzaChuZXcgQ2FuRGVhY3RpdmF0ZShjb250ZXh0Lm91dGxldC5jb21wb25lbnQsIHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrcy5jYW5EZWFjdGl2YXRlQ2hlY2tzLnB1c2gobmV3IENhbkRlYWN0aXZhdGUobnVsbCwgcikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBJTklUSUFMX1ZBTFVFID0gU3ltYm9sKCdJTklUSUFMX1ZBTFVFJyk7XG4gICAgZnVuY3Rpb24gcHJpb3JpdGl6ZWRHdWFyZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gb3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAob2JzKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5jb21iaW5lTGF0ZXN0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWQob2JzLm1hcChmdW5jdGlvbiAobykgeyByZXR1cm4gby5waXBlKG9wZXJhdG9ycy50YWtlKDEpLCBvcGVyYXRvcnMuc3RhcnRXaXRoKElOSVRJQUxfVkFMVUUpKTsgfSkpKS5waXBlKG9wZXJhdG9ycy5zY2FuKGZ1bmN0aW9uIChhY2MsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChpbm5lckFjYywgdmFsLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lckFjYyAhPT0gSU5JVElBTF9WQUxVRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckFjYztcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9nZ2xlIHBlbmRpbmcgZmxhZyBpZiBhbnkgdmFsdWVzIGhhdmVuJ3QgYmVlbiBzZXQgeWV0XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IElOSVRJQUxfVkFMVUUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbnkgb3RoZXIgcmV0dXJuIHZhbHVlcyBhcmUgb25seSB2YWxpZCBpZiB3ZSBoYXZlbid0IHlldCBoaXQgYSBwZW5kaW5nIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IGluIHRoZSBjYXNlIG9mIGEgZ3VhcmQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgdHJlZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYSByZWRpcmVjdCwgd2Ugd2lsbCB3YWl0IGZvciB0aGUgaGlnaGVyIHByaW9yaXR5IGd1YXJkIGF0IHRoZSB0b3AgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIGJlZm9yZSBwZXJmb3JtaW5nIHRoZSByZWRpcmVjdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVhcmx5IHJldHVybiB3aGVuIHdlIGhpdCBhIGBmYWxzZWAgdmFsdWUgYXMgdGhhdCBzaG91bGQgYWx3YXlzIGNhbmNlbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsaXN0Lmxlbmd0aCAtIDEgfHwgaXNVcmxUcmVlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckFjYztcbiAgICAgICAgICAgICAgICB9LCBhY2MpO1xuICAgICAgICAgICAgfSwgSU5JVElBTF9WQUxVRSksIG9wZXJhdG9ycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gIT09IElOSVRJQUxfVkFMVUU7IH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpc1VybFRyZWUoaXRlbSkgPyBpdGVtIDogaXRlbSA9PT0gdHJ1ZTsgfSksIC8vXG4gICAgICAgICAgICBvcGVyYXRvcnMudGFrZSgxKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0d1YXJkcyhtb2R1bGVJbmplY3RvciwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFNuYXBzaG90ID0gdC50YXJnZXRTbmFwc2hvdCwgY3VycmVudFNuYXBzaG90ID0gdC5jdXJyZW50U25hcHNob3QsIF9hID0gdC5ndWFyZHMsIGNhbkFjdGl2YXRlQ2hlY2tzID0gX2EuY2FuQWN0aXZhdGVDaGVja3MsIGNhbkRlYWN0aXZhdGVDaGVja3MgPSBfYS5jYW5EZWFjdGl2YXRlQ2hlY2tzO1xuICAgICAgICAgICAgICAgIGlmIChjYW5EZWFjdGl2YXRlQ2hlY2tzLmxlbmd0aCA9PT0gMCAmJiBjYW5BY3RpdmF0ZUNoZWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YoX19hc3NpZ24oe30sIHQsIHsgZ3VhcmRzUmVzdWx0OiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bkNhbkRlYWN0aXZhdGVDaGVja3MoY2FuRGVhY3RpdmF0ZUNoZWNrcywgdGFyZ2V0U25hcHNob3QsIGN1cnJlbnRTbmFwc2hvdCwgbW9kdWxlSW5qZWN0b3IpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAoY2FuRGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuRGVhY3RpdmF0ZSAmJiBpc0Jvb2xlYW4oY2FuRGVhY3RpdmF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVuQ2FuQWN0aXZhdGVDaGVja3ModGFyZ2V0U25hcHNob3QsIGNhbkFjdGl2YXRlQ2hlY2tzLCBtb2R1bGVJbmplY3RvciwgZm9yd2FyZEV2ZW50KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICByeGpzLm9mKGNhbkRlYWN0aXZhdGUpO1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChndWFyZHNSZXN1bHQpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgdCwgeyBndWFyZHNSZXN1bHQ6IGd1YXJkc1Jlc3VsdCB9KSk7IH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuRGVhY3RpdmF0ZUNoZWNrcyhjaGVja3MsIGZ1dHVyZVJTUywgY3VyclJTUywgbW9kdWxlSW5qZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShjaGVja3MpLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bkNhbkRlYWN0aXZhdGUoY2hlY2suY29tcG9uZW50LCBjaGVjay5yb3V0ZSwgY3VyclJTUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgIH0pLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ICE9PSB0cnVlOyB9LCB0cnVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bkNhbkFjdGl2YXRlQ2hlY2tzKGZ1dHVyZVNuYXBzaG90LCBjaGVja3MsIG1vZHVsZUluamVjdG9yLCBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHJ4anMuZnJvbShjaGVja3MpLnBpcGUob3BlcmF0b3JzLmNvbmNhdE1hcChmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oW1xuICAgICAgICAgICAgICAgIGZpcmVDaGlsZEFjdGl2YXRpb25TdGFydChjaGVjay5yb3V0ZS5wYXJlbnQsIGZvcndhcmRFdmVudCksXG4gICAgICAgICAgICAgICAgZmlyZUFjdGl2YXRpb25TdGFydChjaGVjay5yb3V0ZSwgZm9yd2FyZEV2ZW50KSxcbiAgICAgICAgICAgICAgICBydW5DYW5BY3RpdmF0ZUNoaWxkKGZ1dHVyZVNuYXBzaG90LCBjaGVjay5wYXRoLCBtb2R1bGVJbmplY3RvciksXG4gICAgICAgICAgICAgICAgcnVuQ2FuQWN0aXZhdGUoZnV0dXJlU25hcHNob3QsIGNoZWNrLnJvdXRlLCBtb2R1bGVJbmplY3RvcilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLmNvbmNhdEFsbCgpLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IHRydWU7XG4gICAgICAgICAgICB9LCB0cnVlKSk7XG4gICAgICAgIH0pLCBvcGVyYXRvcnMuZmlyc3QoZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0ICE9PSB0cnVlOyB9LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogVGhpcyBzaG91bGQgZmlyZSBvZmYgYEFjdGl2YXRpb25TdGFydGAgZXZlbnRzIGZvciBlYWNoIHJvdXRlIGJlaW5nIGFjdGl2YXRlZCBhdCB0aGlzXG4gICAgICAgKiBsZXZlbC5cbiAgICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB5b3UncmUgYWN0aXZhdGluZyBgYWAgYW5kIGBiYCBiZWxvdywgYHBhdGhgIHdpbGwgY29udGFpbiB0aGVcbiAgICAgICAqIGBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90YHMgZm9yIGJvdGggYW5kIHdlIHdpbGwgZmlyZSBgQWN0aXZhdGlvblN0YXJ0YCBmb3IgYm90aC4gQWx3YXlzXG4gICAgICAgKiByZXR1cm5cbiAgICAgICAqIGB0cnVlYCBzbyBjaGVja3MgY29udGludWUgdG8gcnVuLlxuICAgICAgICovXG4gICAgZnVuY3Rpb24gZmlyZUFjdGl2YXRpb25TdGFydChzbmFwc2hvdCwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIGlmIChzbmFwc2hvdCAhPT0gbnVsbCAmJiBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGZvcndhcmRFdmVudChuZXcgQWN0aXZhdGlvblN0YXJ0KHNuYXBzaG90KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ4anMub2YodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgICogVGhpcyBzaG91bGQgZmlyZSBvZmYgYENoaWxkQWN0aXZhdGlvblN0YXJ0YCBldmVudHMgZm9yIGVhY2ggcm91dGUgYmVpbmcgYWN0aXZhdGVkIGF0IHRoaXNcbiAgICAgICAqIGxldmVsLlxuICAgICAgICogSW4gb3RoZXIgd29yZHMsIGlmIHlvdSdyZSBhY3RpdmF0aW5nIGBhYCBhbmQgYGJgIGJlbG93LCBgcGF0aGAgd2lsbCBjb250YWluIHRoZVxuICAgICAgICogYEFjdGl2YXRlZFJvdXRlU25hcHNob3RgcyBmb3IgYm90aCBhbmQgd2Ugd2lsbCBmaXJlIGBDaGlsZEFjdGl2YXRpb25TdGFydGAgZm9yIGJvdGguIEFsd2F5c1xuICAgICAgICogcmV0dXJuXG4gICAgICAgKiBgdHJ1ZWAgc28gY2hlY2tzIGNvbnRpbnVlIHRvIHJ1bi5cbiAgICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpcmVDaGlsZEFjdGl2YXRpb25TdGFydChzbmFwc2hvdCwgZm9yd2FyZEV2ZW50KSB7XG4gICAgICAgIGlmIChzbmFwc2hvdCAhPT0gbnVsbCAmJiBmb3J3YXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGZvcndhcmRFdmVudChuZXcgQ2hpbGRBY3RpdmF0aW9uU3RhcnQoc25hcHNob3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnhqcy5vZih0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuQWN0aXZhdGUoZnV0dXJlUlNTLCBmdXR1cmVBUlMsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZSA9IGZ1dHVyZUFSUy5yb3V0ZUNvbmZpZyA/IGZ1dHVyZUFSUy5yb3V0ZUNvbmZpZy5jYW5BY3RpdmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghY2FuQWN0aXZhdGUgfHwgY2FuQWN0aXZhdGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodHJ1ZSk7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZU9ic2VydmFibGVzID0gY2FuQWN0aXZhdGUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqcy5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkID0gZ2V0VG9rZW4oYywgZnV0dXJlQVJTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2FuQWN0aXZhdGUoZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuQWN0aXZhdGUoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihndWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZChmdXR1cmVBUlMsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbkFjdGl2YXRlIGd1YXJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnhqcy5vZihjYW5BY3RpdmF0ZU9ic2VydmFibGVzKS5waXBlKHByaW9yaXRpemVkR3VhcmRWYWx1ZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuQ2FuQWN0aXZhdGVDaGlsZChmdXR1cmVSU1MsIHBhdGgsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciBmdXR1cmVBUlMgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkR3VhcmRzID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBnZXRDYW5BY3RpdmF0ZUNoaWxkKHApOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXyAhPT0gbnVsbDsgfSk7XG4gICAgICAgIHZhciBjYW5BY3RpdmF0ZUNoaWxkR3VhcmRzTWFwcGVkID0gY2FuQWN0aXZhdGVDaGlsZEd1YXJkcy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3VhcmRzTWFwcGVkID0gZC5ndWFyZHMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZCA9IGdldFRva2VuKGMsIGQubm9kZSwgbW9kdWxlSW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FuQWN0aXZhdGVDaGlsZChndWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB3cmFwSW50b09ic2VydmFibGUoZ3VhcmQuY2FuQWN0aXZhdGVDaGlsZChmdXR1cmVBUlMsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkKGZ1dHVyZUFSUywgZnV0dXJlUlNTKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ2FuQWN0aXZhdGVDaGlsZCBndWFyZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKGd1YXJkc01hcHBlZCkucGlwZShwcmlvcml0aXplZEd1YXJkVmFsdWUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByeGpzLm9mKGNhbkFjdGl2YXRlQ2hpbGRHdWFyZHNNYXBwZWQpLnBpcGUocHJpb3JpdGl6ZWRHdWFyZFZhbHVlKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5DYW5EZWFjdGl2YXRlKGNvbXBvbmVudCwgY3VyckFSUywgY3VyclJTUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICB2YXIgY2FuRGVhY3RpdmF0ZSA9IGN1cnJBUlMgJiYgY3VyckFSUy5yb3V0ZUNvbmZpZyA/IGN1cnJBUlMucm91dGVDb25maWcuY2FuRGVhY3RpdmF0ZSA6IG51bGw7XG4gICAgICAgIGlmICghY2FuRGVhY3RpdmF0ZSB8fCBjYW5EZWFjdGl2YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHRydWUpO1xuICAgICAgICB2YXIgY2FuRGVhY3RpdmF0ZU9ic2VydmFibGVzID0gY2FuRGVhY3RpdmF0ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBndWFyZCA9IGdldFRva2VuKGMsIGN1cnJBUlMsIG1vZHVsZUluamVjdG9yKTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlO1xuICAgICAgICAgICAgaWYgKGlzQ2FuRGVhY3RpdmF0ZShndWFyZCkpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID1cbiAgICAgICAgICAgICAgICAgICAgd3JhcEludG9PYnNlcnZhYmxlKGd1YXJkLmNhbkRlYWN0aXZhdGUoY29tcG9uZW50LCBjdXJyQVJTLCBjdXJyUlNTLCBmdXR1cmVSU1MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IHdyYXBJbnRvT2JzZXJ2YWJsZShndWFyZChjb21wb25lbnQsIGN1cnJBUlMsIGN1cnJSU1MsIGZ1dHVyZVJTUykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENhbkRlYWN0aXZhdGUgZ3VhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnBpcGUob3BlcmF0b3JzLmZpcnN0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ4anMub2YoY2FuRGVhY3RpdmF0ZU9ic2VydmFibGVzKS5waXBlKHByaW9yaXRpemVkR3VhcmRWYWx1ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIE5vTWF0Y2gkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTm9NYXRjaCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9NYXRjaDtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIHJlY29nbml6ZShyb290Q29tcG9uZW50VHlwZSwgY29uZmlnLCB1cmxUcmVlLCB1cmwsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kgPT09IHZvaWQgMCkgeyBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5ID0gJ2VtcHR5T25seSc7IH1cbiAgICAgICAgaWYgKHJlbGF0aXZlTGlua1Jlc29sdXRpb24gPT09IHZvaWQgMCkgeyByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gJ2xlZ2FjeSc7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWNvZ25pemVyKHJvb3RDb21wb25lbnRUeXBlLCBjb25maWcsIHVybFRyZWUsIHVybCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbilcbiAgICAgICAgICAgIC5yZWNvZ25pemUoKTtcbiAgICB9XG4gICAgdmFyIFJlY29nbml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlY29nbml6ZXIocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgdXJsVHJlZSwgdXJsLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RDb21wb25lbnRUeXBlID0gcm9vdENvbXBvbmVudFR5cGU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgIHRoaXMudXJsVHJlZSA9IHVybFRyZWU7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9IHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24gPSByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RTZWdtZW50R3JvdXAgPSBzcGxpdCQxKHRoaXMudXJsVHJlZS5yb290LCBbXSwgW10sIHRoaXMuY29uZmlnLCB0aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pLnNlZ21lbnRHcm91cDtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb2Nlc3NTZWdtZW50R3JvdXAodGhpcy5jb25maWcsIHJvb3RTZWdtZW50R3JvdXAsIFBSSU1BUllfT1VUTEVUKTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IG5ldyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KFtdLCBPYmplY3QuZnJlZXplKHt9KSwgT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbih7fSwgdGhpcy51cmxUcmVlLnF1ZXJ5UGFyYW1zKSksIHRoaXMudXJsVHJlZS5mcmFnbWVudCwge30sIFBSSU1BUllfT1VUTEVULCB0aGlzLnJvb3RDb21wb25lbnRUeXBlLCBudWxsLCB0aGlzLnVybFRyZWUucm9vdCwgLTEsIHt9KTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdE5vZGUgPSBuZXcgVHJlZU5vZGUocm9vdCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIHZhciByb3V0ZVN0YXRlID0gbmV3IFJvdXRlclN0YXRlU25hcHNob3QodGhpcy51cmwsIHJvb3ROb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaGVyaXRQYXJhbXNBbmREYXRhKHJvdXRlU3RhdGUuX3Jvb3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHJvdXRlU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzKSB7IHJldHVybiBvYnMuZXJyb3IoZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5pbmhlcml0UGFyYW1zQW5kRGF0YSA9IGZ1bmN0aW9uIChyb3V0ZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcm91dGUgPSByb3V0ZU5vZGUudmFsdWU7XG4gICAgICAgICAgICB2YXIgaSA9IGluaGVyaXRlZFBhcmFtc0RhdGFSZXNvbHZlKHJvdXRlLCB0aGlzLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kpO1xuICAgICAgICAgICAgcm91dGUucGFyYW1zID0gT2JqZWN0LmZyZWV6ZShpLnBhcmFtcyk7XG4gICAgICAgICAgICByb3V0ZS5kYXRhID0gT2JqZWN0LmZyZWV6ZShpLmRhdGEpO1xuICAgICAgICAgICAgcm91dGVOb2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG4pIHsgcmV0dXJuIF90aGlzLmluaGVyaXRQYXJhbXNBbmREYXRhKG4pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVjb2duaXplci5wcm90b3R5cGUucHJvY2Vzc1NlZ21lbnRHcm91cCA9IGZ1bmN0aW9uIChjb25maWcsIHNlZ21lbnRHcm91cCwgb3V0bGV0KSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDaGlsZHJlbihjb25maWcsIHNlZ21lbnRHcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU2VnbWVudChjb25maWcsIHNlZ21lbnRHcm91cCwgc2VnbWVudEdyb3VwLnNlZ21lbnRzLCBvdXRsZXQpO1xuICAgICAgICB9O1xuICAgICAgICBSZWNvZ25pemVyLnByb3RvdHlwZS5wcm9jZXNzQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY29uZmlnLCBzZWdtZW50R3JvdXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtYXBDaGlsZHJlbkludG9BcnJheShzZWdtZW50R3JvdXAsIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRPdXRsZXQpIHsgcmV0dXJuIF90aGlzLnByb2Nlc3NTZWdtZW50R3JvdXAoY29uZmlnLCBjaGlsZCwgY2hpbGRPdXRsZXQpOyB9KTtcbiAgICAgICAgICAgIGNoZWNrT3V0bGV0TmFtZVVuaXF1ZW5lc3MoY2hpbGRyZW4pO1xuICAgICAgICAgICAgc29ydEFjdGl2YXRlZFJvdXRlU25hcHNob3RzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgfTtcbiAgICAgICAgUmVjb2duaXplci5wcm90b3R5cGUucHJvY2Vzc1NlZ21lbnQgPSBmdW5jdGlvbiAoY29uZmlnLCBzZWdtZW50R3JvdXAsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb25maWdfMSA9IF9fdmFsdWVzKGNvbmZpZyksIGNvbmZpZ18xXzEgPSBjb25maWdfMS5uZXh0KCk7ICFjb25maWdfMV8xLmRvbmU7IGNvbmZpZ18xXzEgPSBjb25maWdfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjb25maWdfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1NlZ21lbnRBZ2FpbnN0Um91dGUociwgc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE5vTWF0Y2gkMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnXzFfMSAmJiAhY29uZmlnXzFfMS5kb25lICYmIChfYSA9IGNvbmZpZ18xLnJldHVybikpIF9hLmNhbGwoY29uZmlnXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub0xlZnRvdmVyc0luVXJsKHNlZ21lbnRHcm91cCwgc2VnbWVudHMsIG91dGxldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCQxKCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlY29nbml6ZXIucHJvdG90eXBlLm5vTGVmdG92ZXJzSW5VcmwgPSBmdW5jdGlvbiAoc2VnbWVudEdyb3VwLCBzZWdtZW50cywgb3V0bGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoID09PSAwICYmICFzZWdtZW50R3JvdXAuY2hpbGRyZW5bb3V0bGV0XTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVjb2duaXplci5wcm90b3R5cGUucHJvY2Vzc1NlZ21lbnRBZ2FpbnN0Um91dGUgPSBmdW5jdGlvbiAocm91dGUsIHJhd1NlZ21lbnQsIHNlZ21lbnRzLCBvdXRsZXQpIHtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb01hdGNoJDEoKTtcbiAgICAgICAgICAgIGlmICgocm91dGUub3V0bGV0IHx8IFBSSU1BUllfT1VUTEVUKSAhPT0gb3V0bGV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb01hdGNoJDEoKTtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIHZhciBjb25zdW1lZFNlZ21lbnRzID0gW107XG4gICAgICAgICAgICB2YXIgcmF3U2xpY2VkU2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZS5wYXRoID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNlZ21lbnRzLmxlbmd0aCA+IDAgPyBsYXN0KHNlZ21lbnRzKS5wYXJhbWV0ZXJzIDoge307XG4gICAgICAgICAgICAgICAgc25hcHNob3QgPSBuZXcgQWN0aXZhdGVkUm91dGVTbmFwc2hvdChzZWdtZW50cywgcGFyYW1zLCBPYmplY3QuZnJlZXplKF9fYXNzaWduKHt9LCB0aGlzLnVybFRyZWUucXVlcnlQYXJhbXMpKSwgdGhpcy51cmxUcmVlLmZyYWdtZW50LCBnZXREYXRhKHJvdXRlKSwgb3V0bGV0LCByb3V0ZS5jb21wb25lbnQsIHJvdXRlLCBnZXRTb3VyY2VTZWdtZW50R3JvdXAocmF3U2VnbWVudCksIGdldFBhdGhJbmRleFNoaWZ0KHJhd1NlZ21lbnQpICsgc2VnbWVudHMubGVuZ3RoLCBnZXRSZXNvbHZlKHJvdXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWF0Y2gkMShyYXdTZWdtZW50LCByb3V0ZSwgc2VnbWVudHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkU2VnbWVudHMgPSByZXN1bHQuY29uc3VtZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgICByYXdTbGljZWRTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKHJlc3VsdC5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90ID0gbmV3IEFjdGl2YXRlZFJvdXRlU25hcHNob3QoY29uc3VtZWRTZWdtZW50cywgcmVzdWx0LnBhcmFtZXRlcnMsIE9iamVjdC5mcmVlemUoX19hc3NpZ24oe30sIHRoaXMudXJsVHJlZS5xdWVyeVBhcmFtcykpLCB0aGlzLnVybFRyZWUuZnJhZ21lbnQsIGdldERhdGEocm91dGUpLCBvdXRsZXQsIHJvdXRlLmNvbXBvbmVudCwgcm91dGUsIGdldFNvdXJjZVNlZ21lbnRHcm91cChyYXdTZWdtZW50KSwgZ2V0UGF0aEluZGV4U2hpZnQocmF3U2VnbWVudCkgKyBjb25zdW1lZFNlZ21lbnRzLmxlbmd0aCwgZ2V0UmVzb2x2ZShyb3V0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ29uZmlnID0gZ2V0Q2hpbGRDb25maWcocm91dGUpO1xuICAgICAgICAgICAgdmFyIF9hID0gc3BsaXQkMShyYXdTZWdtZW50LCBjb25zdW1lZFNlZ21lbnRzLCByYXdTbGljZWRTZWdtZW50cywgY2hpbGRDb25maWcsIHRoaXMucmVsYXRpdmVMaW5rUmVzb2x1dGlvbiksIHNlZ21lbnRHcm91cCA9IF9hLnNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMgPSBfYS5zbGljZWRTZWdtZW50cztcbiAgICAgICAgICAgIGlmIChzbGljZWRTZWdtZW50cy5sZW5ndGggPT09IDAgJiYgc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IHRoaXMucHJvY2Vzc0NoaWxkcmVuKGNoaWxkQ29uZmlnLCBzZWdtZW50R3JvdXApO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRyZWVOb2RlKHNuYXBzaG90LCBjaGlsZHJlbl8xKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRDb25maWcubGVuZ3RoID09PSAwICYmIHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRyZWVOb2RlKHNuYXBzaG90LCBbXSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9jZXNzU2VnbWVudChjaGlsZENvbmZpZywgc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgUFJJTUFSWV9PVVRMRVQpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVHJlZU5vZGUoc25hcHNob3QsIGNoaWxkcmVuKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWNvZ25pemVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gc29ydEFjdGl2YXRlZFJvdXRlU25hcHNob3RzKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLnZhbHVlLm91dGxldCA9PT0gUFJJTUFSWV9PVVRMRVQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGIudmFsdWUub3V0bGV0ID09PSBQUklNQVJZX09VVExFVClcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIHJldHVybiBhLnZhbHVlLm91dGxldC5sb2NhbGVDb21wYXJlKGIudmFsdWUub3V0bGV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoaWxkQ29uZmlnKHJvdXRlKSB7XG4gICAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZS5sb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZS5fbG9hZGVkQ29uZmlnLnJvdXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hdGNoJDEoc2VnbWVudEdyb3VwLCByb3V0ZSwgc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHJvdXRlLnBhdGggPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAocm91dGUucGF0aE1hdGNoID09PSAnZnVsbCcgJiYgKHNlZ21lbnRHcm91cC5oYXNDaGlsZHJlbigpIHx8IHNlZ21lbnRzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vTWF0Y2gkMSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgY29uc3VtZWRTZWdtZW50czogW10sIGxhc3RDaGlsZDogMCwgcGFyYW1ldGVyczoge30gfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlciA9IHJvdXRlLm1hdGNoZXIgfHwgZGVmYXVsdFVybE1hdGNoZXI7XG4gICAgICAgIHZhciByZXMgPSBtYXRjaGVyKHNlZ21lbnRzLCBzZWdtZW50R3JvdXAsIHJvdXRlKTtcbiAgICAgICAgaWYgKCFyZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9NYXRjaCQxKCk7XG4gICAgICAgIHZhciBwb3NQYXJhbXMgPSB7fTtcbiAgICAgICAgZm9yRWFjaChyZXMucG9zUGFyYW1zLCBmdW5jdGlvbiAodiwgaykgeyBwb3NQYXJhbXNba10gPSB2LnBhdGg7IH0pO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHJlcy5jb25zdW1lZC5sZW5ndGggPiAwID8gX19hc3NpZ24oe30sIHBvc1BhcmFtcywgcmVzLmNvbnN1bWVkW3Jlcy5jb25zdW1lZC5sZW5ndGggLSAxXS5wYXJhbWV0ZXJzKSA6XG4gICAgICAgICAgICBwb3NQYXJhbXM7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkU2VnbWVudHM6IHJlcy5jb25zdW1lZCwgbGFzdENoaWxkOiByZXMuY29uc3VtZWQubGVuZ3RoLCBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrT3V0bGV0TmFtZVVuaXF1ZW5lc3Mobm9kZXMpIHtcbiAgICAgICAgdmFyIG5hbWVzID0ge307XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciByb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZSA9IG5hbWVzW24udmFsdWUub3V0bGV0XTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVdpdGhTYW1lT3V0bGV0TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcm91dGVXaXRoU2FtZU91dGxldE5hbWUudXJsLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy50b1N0cmluZygpOyB9KS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuLnZhbHVlLnVybC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9TdHJpbmcoKTsgfSkuam9pbignLycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR3byBzZWdtZW50cyBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBvdXRsZXQgbmFtZTogJ1wiICsgcCArIFwiJyBhbmQgJ1wiICsgYyArIFwiJy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lc1tuLnZhbHVlLm91dGxldF0gPSBuLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U291cmNlU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cCkge1xuICAgICAgICB2YXIgcyA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgd2hpbGUgKHMuX3NvdXJjZVNlZ21lbnQpIHtcbiAgICAgICAgICAgIHMgPSBzLl9zb3VyY2VTZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYXRoSW5kZXhTaGlmdChzZWdtZW50R3JvdXApIHtcbiAgICAgICAgdmFyIHMgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgIHZhciByZXMgPSAocy5fc2VnbWVudEluZGV4U2hpZnQgPyBzLl9zZWdtZW50SW5kZXhTaGlmdCA6IDApO1xuICAgICAgICB3aGlsZSAocy5fc291cmNlU2VnbWVudCkge1xuICAgICAgICAgICAgcyA9IHMuX3NvdXJjZVNlZ21lbnQ7XG4gICAgICAgICAgICByZXMgKz0gKHMuX3NlZ21lbnRJbmRleFNoaWZ0ID8gcy5fc2VnbWVudEluZGV4U2hpZnQgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzIC0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXQkMShzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcsIHJlbGF0aXZlTGlua1Jlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zRW1wdHlQYXRoTWF0Y2hlc1dpdGhOYW1lZE91dGxldHMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgY29uZmlnKSkge1xuICAgICAgICAgICAgdmFyIHNfMSA9IG5ldyBVcmxTZWdtZW50R3JvdXAoY29uc3VtZWRTZWdtZW50cywgY3JlYXRlQ2hpbGRyZW5Gb3JFbXB0eVBhdGhzKHNlZ21lbnRHcm91cCwgY29uc3VtZWRTZWdtZW50cywgY29uZmlnLCBuZXcgVXJsU2VnbWVudEdyb3VwKHNsaWNlZFNlZ21lbnRzLCBzZWdtZW50R3JvdXAuY2hpbGRyZW4pKSk7XG4gICAgICAgICAgICBzXzEuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgICAgICBzXzEuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4geyBzZWdtZW50R3JvdXA6IHNfMSwgc2xpY2VkU2VnbWVudHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsaWNlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzKHNlZ21lbnRHcm91cCwgc2xpY2VkU2VnbWVudHMsIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHZhciBzXzIgPSBuZXcgVXJsU2VnbWVudEdyb3VwKHNlZ21lbnRHcm91cC5zZWdtZW50cywgYWRkRW1wdHlQYXRoc1RvQ2hpbGRyZW5JZk5lZWRlZChzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHNsaWNlZFNlZ21lbnRzLCBjb25maWcsIHNlZ21lbnRHcm91cC5jaGlsZHJlbiwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikpO1xuICAgICAgICAgICAgc18yLl9zb3VyY2VTZWdtZW50ID0gc2VnbWVudEdyb3VwO1xuICAgICAgICAgICAgc18yLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VnbWVudEdyb3VwOiBzXzIsIHNsaWNlZFNlZ21lbnRzOiBzbGljZWRTZWdtZW50cyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50R3JvdXAuc2VnbWVudHMsIHNlZ21lbnRHcm91cC5jaGlsZHJlbik7XG4gICAgICAgIHMuX3NvdXJjZVNlZ21lbnQgPSBzZWdtZW50R3JvdXA7XG4gICAgICAgIHMuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRHcm91cDogcywgc2xpY2VkU2VnbWVudHM6IHNsaWNlZFNlZ21lbnRzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEVtcHR5UGF0aHNUb0NoaWxkcmVuSWZOZWVkZWQoc2VnbWVudEdyb3VwLCBjb25zdW1lZFNlZ21lbnRzLCBzbGljZWRTZWdtZW50cywgcm91dGVzLCBjaGlsZHJlbiwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbikge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgcm91dGVzXzEgPSBfX3ZhbHVlcyhyb3V0ZXMpLCByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpOyAhcm91dGVzXzFfMS5kb25lOyByb3V0ZXNfMV8xID0gcm91dGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByb3V0ZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eVBhdGhNYXRjaChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByKSAmJiAhY2hpbGRyZW5bZ2V0T3V0bGV0JDEocildKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgICAgICAgICBzLl9zb3VyY2VTZWdtZW50ID0gc2VnbWVudEdyb3VwO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVMaW5rUmVzb2x1dGlvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuX3NlZ21lbnRJbmRleFNoaWZ0ID0gc2VnbWVudEdyb3VwLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzW2dldE91dGxldCQxKHIpXSA9IHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVzXzFfMSAmJiAhcm91dGVzXzFfMS5kb25lICYmIChfYSA9IHJvdXRlc18xLnJldHVybikpIF9hLmNhbGwocm91dGVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgY2hpbGRyZW4sIHJlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuRm9yRW1wdHlQYXRocyhzZWdtZW50R3JvdXAsIGNvbnN1bWVkU2VnbWVudHMsIHJvdXRlcywgcHJpbWFyeVNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgcmVzW1BSSU1BUllfT1VUTEVUXSA9IHByaW1hcnlTZWdtZW50O1xuICAgICAgICBwcmltYXJ5U2VnbWVudC5fc291cmNlU2VnbWVudCA9IHNlZ21lbnRHcm91cDtcbiAgICAgICAgcHJpbWFyeVNlZ21lbnQuX3NlZ21lbnRJbmRleFNoaWZ0ID0gY29uc3VtZWRTZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciByb3V0ZXNfMiA9IF9fdmFsdWVzKHJvdXRlcyksIHJvdXRlc18yXzEgPSByb3V0ZXNfMi5uZXh0KCk7ICFyb3V0ZXNfMl8xLmRvbmU7IHJvdXRlc18yXzEgPSByb3V0ZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJvdXRlc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHIucGF0aCA9PT0gJycgJiYgZ2V0T3V0bGV0JDEocikgIT09IFBSSU1BUllfT1VUTEVUKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbmV3IFVybFNlZ21lbnRHcm91cChbXSwge30pO1xuICAgICAgICAgICAgICAgICAgICBzLl9zb3VyY2VTZWdtZW50ID0gc2VnbWVudEdyb3VwO1xuICAgICAgICAgICAgICAgICAgICBzLl9zZWdtZW50SW5kZXhTaGlmdCA9IGNvbnN1bWVkU2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXNbZ2V0T3V0bGV0JDEocildID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXNfMl8xICYmICFyb3V0ZXNfMl8xLmRvbmUgJiYgKF9hID0gcm91dGVzXzIucmV0dXJuKSkgX2EuY2FsbChyb3V0ZXNfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNFbXB0eVBhdGhNYXRjaGVzV2l0aE5hbWVkT3V0bGV0cyhzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByb3V0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7IHJldHVybiBlbXB0eVBhdGhNYXRjaChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByKSAmJiBnZXRPdXRsZXQkMShyKSAhPT0gUFJJTUFSWV9PVVRMRVQ7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc0VtcHR5UGF0aE1hdGNoZXMoc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcm91dGVzKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikgeyByZXR1cm4gZW1wdHlQYXRoTWF0Y2goc2VnbWVudEdyb3VwLCBzbGljZWRTZWdtZW50cywgcik7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbXB0eVBhdGhNYXRjaChzZWdtZW50R3JvdXAsIHNsaWNlZFNlZ21lbnRzLCByKSB7XG4gICAgICAgIGlmICgoc2VnbWVudEdyb3VwLmhhc0NoaWxkcmVuKCkgfHwgc2xpY2VkU2VnbWVudHMubGVuZ3RoID4gMCkgJiYgci5wYXRoTWF0Y2ggPT09ICdmdWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnBhdGggPT09ICcnICYmIHIucmVkaXJlY3RUbyA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPdXRsZXQkMShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gcm91dGUub3V0bGV0IHx8IFBSSU1BUllfT1VUTEVUO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREYXRhKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiByb3V0ZS5kYXRhIHx8IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXNvbHZlKHJvdXRlKSB7XG4gICAgICAgIHJldHVybiByb3V0ZS5yZXNvbHZlIHx8IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNvZ25pemUkMShyb290Q29tcG9uZW50VHlwZSwgY29uZmlnLCBzZXJpYWxpemVyLCBwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCByZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiByZWNvZ25pemUocm9vdENvbXBvbmVudFR5cGUsIGNvbmZpZywgdC51cmxBZnRlclJlZGlyZWN0cywgc2VyaWFsaXplcih0LnVybEFmdGVyUmVkaXJlY3RzKSwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbilcbiAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICh0YXJnZXRTbmFwc2hvdCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCB0LCB7IHRhcmdldFNuYXBzaG90OiB0YXJnZXRTbmFwc2hvdCB9KSk7IH0pKTsgfSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlRGF0YShwYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5LCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTbmFwc2hvdCA9IHQudGFyZ2V0U25hcHNob3QsIGNhbkFjdGl2YXRlQ2hlY2tzID0gdC5ndWFyZHMuY2FuQWN0aXZhdGVDaGVja3M7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5BY3RpdmF0ZUNoZWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oY2FuQWN0aXZhdGVDaGVja3MpXG4gICAgICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5jb25jYXRNYXAoZnVuY3Rpb24gKGNoZWNrKSB7IHJldHVybiBydW5SZXNvbHZlKGNoZWNrLnJvdXRlLCB0YXJnZXRTbmFwc2hvdCwgcGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSwgbW9kdWxlSW5qZWN0b3IpOyB9KSwgb3BlcmF0b3JzLnJlZHVjZShmdW5jdGlvbiAoXywgX18pIHsgcmV0dXJuIF87IH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChfKSB7IHJldHVybiB0OyB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1blJlc29sdmUoZnV0dXJlQVJTLCBmdXR1cmVSU1MsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciByZXNvbHZlID0gZnV0dXJlQVJTLl9yZXNvbHZlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUocmVzb2x2ZSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAocmVzb2x2ZWREYXRhKSB7XG4gICAgICAgICAgICBmdXR1cmVBUlMuX3Jlc29sdmVkRGF0YSA9IHJlc29sdmVkRGF0YTtcbiAgICAgICAgICAgIGZ1dHVyZUFSUy5kYXRhID0gX19hc3NpZ24oe30sIGZ1dHVyZUFSUy5kYXRhLCBpbmhlcml0ZWRQYXJhbXNEYXRhUmVzb2x2ZShmdXR1cmVBUlMsIHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3kpLnJlc29sdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU5vZGUocmVzb2x2ZSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzb2x2ZSk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ4anMub2Yoe30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGtleV8xID0ga2V5c1swXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXNvbHZlcihyZXNvbHZlW2tleV8xXSwgZnV0dXJlQVJTLCBmdXR1cmVSU1MsIG1vZHVsZUluamVjdG9yKVxuICAgICAgICAgICAgICAgIC5waXBlKG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfYSA9IHt9LCBfYVtrZXlfMV0gPSB2YWx1ZSwgX2E7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyIHJ1bm5pbmdSZXNvbHZlcnMkID0gcnhqcy5mcm9tKGtleXMpLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXNvbHZlcihyZXNvbHZlW2tleV0sIGZ1dHVyZUFSUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3RvcilcbiAgICAgICAgICAgICAgICAucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcnVubmluZ1Jlc29sdmVycyQucGlwZShvcGVyYXRvcnMubGFzdCgpLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVzb2x2ZXIoaW5qZWN0aW9uVG9rZW4sIGZ1dHVyZUFSUywgZnV0dXJlUlNTLCBtb2R1bGVJbmplY3Rvcikge1xuICAgICAgICB2YXIgcmVzb2x2ZXIgPSBnZXRUb2tlbihpbmplY3Rpb25Ub2tlbiwgZnV0dXJlQVJTLCBtb2R1bGVJbmplY3Rvcik7XG4gICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlID8gd3JhcEludG9PYnNlcnZhYmxlKHJlc29sdmVyLnJlc29sdmUoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKSA6XG4gICAgICAgICAgICB3cmFwSW50b09ic2VydmFibGUocmVzb2x2ZXIoZnV0dXJlQVJTLCBmdXR1cmVSU1MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IHRocm91Z2ggYSBzd2l0Y2hNYXAgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSxcbiAgICAgKiBidXQgcmV0dXJuIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS4gSXQncyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhc1xuICAgICAqIHRoZSBgdGFwYCBvcGVyYXRvciwgYnV0IGlmIHRoZSBzaWRlIGVmZmVjdGZ1bCBgbmV4dGAgZnVuY3Rpb24gcmV0dXJucyBhbiBPYnNlcnZhYmxlSW5wdXQsXG4gICAgICogaXQgd2lsbCB3YWl0IGJlZm9yZSBjb250aW51aW5nIHdpdGggdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN3aXRjaFRhcChuZXh0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnBpcGUob3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVzdWx0ID0gbmV4dCh2KTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5mcm9tKG5leHRSZXN1bHQpLnBpcGUob3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiB2OyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oW3ZdKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBjdXN0b21pemUgd2hlbiBhY3RpdmF0ZWQgcm91dGVzIGdldCByZXVzZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlUmV1c2VTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVSZXVzZVN0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSb3V0ZVJldXNlU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBEb2VzIG5vdCBkZXRhY2ggYW55IHN1YnRyZWVzLiBSZXVzZXMgcm91dGVzIGFzIGxvbmcgYXMgdGhlaXIgcm91dGUgY29uZmlnIGlzIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIHZhciBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnNob3VsZERldGFjaCA9IGZ1bmN0aW9uIChyb3V0ZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKHJvdXRlLCBkZXRhY2hlZFRyZWUpIHsgfTtcbiAgICAgICAgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneS5wcm90b3R5cGUuc2hvdWxkQXR0YWNoID0gZnVuY3Rpb24gKHJvdXRlKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneS5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbiAocm91dGUpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIERlZmF1bHRSb3V0ZVJldXNlU3RyYXRlZ3kucHJvdG90eXBlLnNob3VsZFJldXNlUm91dGUgPSBmdW5jdGlvbiAoZnV0dXJlLCBjdXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnV0dXJlLnJvdXRlQ29uZmlnID09PSBjdXJyLnJvdXRlQ29uZmlnO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdFJvdXRlUmV1c2VTdHJhdGVneTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkb2NzTm90UmVxdWlyZWRcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJPVVRFUyA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdST1VURVMnKTtcbiAgICB2YXIgUm91dGVyQ29uZmlnTG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJDb25maWdMb2FkZXIobG9hZGVyLCBjb21waWxlciwgb25Mb2FkU3RhcnRMaXN0ZW5lciwgb25Mb2FkRW5kTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xuICAgICAgICAgICAgdGhpcy5jb21waWxlciA9IGNvbXBpbGVyO1xuICAgICAgICAgICAgdGhpcy5vbkxvYWRTdGFydExpc3RlbmVyID0gb25Mb2FkU3RhcnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIHRoaXMub25Mb2FkRW5kTGlzdGVuZXIgPSBvbkxvYWRFbmRMaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJDb25maWdMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAocGFyZW50SW5qZWN0b3IsIHJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Mb2FkU3RhcnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkU3RhcnRMaXN0ZW5lcihyb3V0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9kdWxlRmFjdG9yeSQgPSB0aGlzLmxvYWRNb2R1bGVGYWN0b3J5KHJvdXRlLmxvYWRDaGlsZHJlbik7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlRmFjdG9yeSQucGlwZShvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9uTG9hZEVuZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTG9hZEVuZExpc3RlbmVyKHJvdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGZhY3RvcnkuY3JlYXRlKHBhcmVudEluamVjdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExvYWRlZFJvdXRlckNvbmZpZyhmbGF0dGVuKG1vZHVsZS5pbmplY3Rvci5nZXQoUk9VVEVTKSkubWFwKHN0YW5kYXJkaXplQ29uZmlnKSwgbW9kdWxlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyQ29uZmlnTG9hZGVyLnByb3RvdHlwZS5sb2FkTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChsb2FkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRDaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5mcm9tKHRoaXMubG9hZGVyLmxvYWQobG9hZENoaWxkcmVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcEludG9PYnNlcnZhYmxlKGxvYWRDaGlsZHJlbigpKS5waXBlKG9wZXJhdG9ycy5tZXJnZU1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGNvcmUuTmdNb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZih0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20oX3RoaXMuY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbmZpZ0xvYWRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgdG8gbWlncmF0ZSBBbmd1bGFySlMgYXBwbGljYXRpb25zIHRvIEFuZ3VsYXIuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFVybEhhbmRsaW5nU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFVybEhhbmRsaW5nU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVybEhhbmRsaW5nU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneS5wcm90b3R5cGUuc2hvdWxkUHJvY2Vzc1VybCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gdXJsOyB9O1xuICAgICAgICBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobmV3VXJsUGFydCwgd2hvbGVVcmwpIHsgcmV0dXJuIG5ld1VybFBhcnQ7IH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0VXJsSGFuZGxpbmdTdHJhdGVneTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIoZXJyb3IsIHVybFNlcmlhbGl6ZXIsIHVybCkge1xuICAgICAgICByZXR1cm4gdXJsU2VyaWFsaXplci5wYXJzZSgnLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0Um91dGVySG9vayhzbmFwc2hvdCwgcnVuRXh0cmFzKSB7XG4gICAgICAgIHJldHVybiByeGpzLm9mKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFuIE5nTW9kdWxlIHRoYXQgcHJvdmlkZXMgbmF2aWdhdGlvbiBhbmQgVVJMIG1hbmlwdWxhdGlvbiBjYXBhYmlsaXRpZXMuXG4gICAgICpcbiAgICAgKiBAc2VlIGBSb3V0ZWAuXG4gICAgICogQHNlZSBbUm91dGluZyBhbmQgTmF2aWdhdGlvbiBHdWlkZV0oZ3VpZGUvcm91dGVyKS5cbiAgICAgKlxuICAgICAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgcm91dGVyIHNlcnZpY2UuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPOiB2c2F2a2luIG1ha2UgaW50ZXJuYWwgYWZ0ZXIgdGhlIGZpbmFsIGlzIG91dC5cbiAgICAgICAgZnVuY3Rpb24gUm91dGVyKHJvb3RDb21wb25lbnRUeXBlLCB1cmxTZXJpYWxpemVyLCByb290Q29udGV4dHMsIGxvY2F0aW9uLCBpbmplY3RvciwgbG9hZGVyLCBjb21waWxlciwgY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yb290Q29tcG9uZW50VHlwZSA9IHJvb3RDb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy51cmxTZXJpYWxpemVyID0gdXJsU2VyaWFsaXplcjtcbiAgICAgICAgICAgIHRoaXMucm9vdENvbnRleHRzID0gcm9vdENvbnRleHRzO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLmxhc3RTdWNjZXNzZnVsTmF2aWdhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnROYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbklkID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNOZ1pvbmVFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIGV2ZW50IHN0cmVhbSBmb3Igcm91dGluZyBldmVudHMgaW4gdGhpcyBOZ01vZHVsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgcnhqcy5TdWJqZWN0KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgaGFuZGxlciBmb3IgbmF2aWdhdGlvbiBlcnJvcnMgaW4gdGhpcyBOZ01vZHVsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBkZWZhdWx0RXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYWxmb3JtZWQgdXJpIGVycm9yIGhhbmRsZXIgaXMgaW52b2tlZCB3aGVuIGBSb3V0ZXIucGFyc2VVcmwodXJsKWAgdGhyb3dzIGFuXG4gICAgICAgICAgICAgKiBlcnJvciBkdWUgdG8gY29udGFpbmluZyBhbiBpbnZhbGlkIGNoYXJhY3Rlci4gVGhlIG1vc3QgY29tbW9uIGNhc2Ugd291bGQgYmUgYSBgJWAgc2lnblxuICAgICAgICAgICAgICogdGhhdCdzIG5vdCBlbmNvZGVkIGFuZCBpcyBub3QgcGFydCBvZiBhIHBlcmNlbnQgZW5jb2RlZCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIgPSBkZWZhdWx0TWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUcnVlIGlmIGF0IGxlYXN0IG9uZSBuYXZpZ2F0aW9uIGV2ZW50IGhhcyBvY2N1cnJlZCxcbiAgICAgICAgICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFN1Y2Nlc3NmdWxJZCA9IC0xO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIb29rcyB0aGF0IGVuYWJsZSB5b3UgdG8gcGF1c2UgbmF2aWdhdGlvbixcbiAgICAgICAgICAgICAqIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHByZWFjdGl2YXRpb24gcGhhc2UuXG4gICAgICAgICAgICAgKiBVc2VkIGJ5IGBSb3V0ZXJNb2R1bGVgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmhvb2tzID0ge1xuICAgICAgICAgICAgICAgIGJlZm9yZVByZWFjdGl2YXRpb246IGRlZmF1bHRSb3V0ZXJIb29rLFxuICAgICAgICAgICAgICAgIGFmdGVyUHJlYWN0aXZhdGlvbjogZGVmYXVsdFJvdXRlckhvb2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4dHJhY3RzIGFuZCBtZXJnZXMgVVJMcy4gVXNlZCBmb3IgQW5ndWxhckpTIHRvIEFuZ3VsYXIgbWlncmF0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5ID0gbmV3IERlZmF1bHRVcmxIYW5kbGluZ1N0cmF0ZWd5KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzdHJhdGVneSBmb3IgcmUtdXNpbmcgcm91dGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdXRlUmV1c2VTdHJhdGVneSA9IG5ldyBEZWZhdWx0Um91dGVSZXVzZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhvdyB0byBoYW5kbGUgYSBuYXZpZ2F0aW9uIHJlcXVlc3QgdG8gdGhlIGN1cnJlbnQgVVJMLiBPbmUgb2Y6XG4gICAgICAgICAgICAgKiAtIGAnaWdub3JlJ2AgOiAgVGhlIHJvdXRlciBpZ25vcmVzIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICogLSBgJ3JlbG9hZCdgIDogVGhlIHJvdXRlciByZWxvYWRzIHRoZSBVUkwuIFVzZSB0byBpbXBsZW1lbnQgYSBcInJlZnJlc2hcIiBmZWF0dXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9uU2FtZVVybE5hdmlnYXRpb24gPSAnaWdub3JlJztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSG93IHRvIG1lcmdlIHBhcmFtZXRlcnMsIGRhdGEsIGFuZCByZXNvbHZlZCBkYXRhIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgICAgICAgICAgKiByb3V0ZXMuIE9uZSBvZjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGAnZW1wdHlPbmx5J2AgOiBJbmhlcml0IHBhcmVudCBwYXJhbWV0ZXJzLCBkYXRhLCBhbmQgcmVzb2x2ZWQgZGF0YVxuICAgICAgICAgICAgICogZm9yIHBhdGgtbGVzcyBvciBjb21wb25lbnQtbGVzcyByb3V0ZXMuXG4gICAgICAgICAgICAgKiAtIGAnYWx3YXlzJ2AgOiBJbmhlcml0IHBhcmVudCBwYXJhbWV0ZXJzLCBkYXRhLCBhbmQgcmVzb2x2ZWQgZGF0YVxuICAgICAgICAgICAgICogZm9yIGFsbCBjaGlsZCByb3V0ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9ICdlbXB0eU9ubHknO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZpbmVzIHdoZW4gdGhlIHJvdXRlciB1cGRhdGVzIHRoZSBicm93c2VyIFVSTC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gdXBkYXRlIGFmdGVyXG4gICAgICAgICAgICAgKiBzdWNjZXNzZnVsIG5hdmlnYXRpb24uIEhvd2V2ZXIsIHNvbWUgYXBwbGljYXRpb25zIG1heSBwcmVmZXIgYSBtb2RlIHdoZXJlIHRoZSBVUkwgZ2V0c1xuICAgICAgICAgICAgICogdXBkYXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIG5hdmlnYXRpb24uIFRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB1cGRhdGluZyB0aGVcbiAgICAgICAgICAgICAqIFVSTCBlYXJseSBzbyBpZiBuYXZpZ2F0aW9uIGZhaWxzLCB5b3UgY2FuIHNob3cgYW4gZXJyb3IgbWVzc2FnZSB3aXRoIHRoZSBVUkwgdGhhdCBmYWlsZWQuXG4gICAgICAgICAgICAgKiBBdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBgJ2RlZmVycmVkJ2AsIHRoZSBkZWZhdWx0LCB1cGRhdGVzIHRoZSBicm93c2VyIFVSTCBhZnRlciBuYXZpZ2F0aW9uIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgICAgICAqIC0gYCdlYWdlcidgLCB1cGRhdGVzIGJyb3dzZXIgVVJMIGF0IHRoZSBiZWdpbm5pbmcgb2YgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy51cmxVcGRhdGVTdHJhdGVneSA9ICdkZWZlcnJlZCc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlZSB7QGxpbmsgUm91dGVyTW9kdWxlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uID0gJ2xlZ2FjeSc7XG4gICAgICAgICAgICB2YXIgb25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gX3RoaXMudHJpZ2dlckV2ZW50KG5ldyBSb3V0ZUNvbmZpZ0xvYWRTdGFydChyKSk7IH07XG4gICAgICAgICAgICB2YXIgb25Mb2FkRW5kID0gZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF90aGlzLnRyaWdnZXJFdmVudChuZXcgUm91dGVDb25maWdMb2FkRW5kKHIpKTsgfTtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGUgPSBpbmplY3Rvci5nZXQoY29yZS5OZ01vZHVsZVJlZik7XG4gICAgICAgICAgICB0aGlzLmNvbnNvbGUgPSBpbmplY3Rvci5nZXQoY29yZS7JtUNvbnNvbGUpO1xuICAgICAgICAgICAgdmFyIG5nWm9uZSA9IGluamVjdG9yLmdldChjb3JlLk5nWm9uZSk7XG4gICAgICAgICAgICB0aGlzLmlzTmdab25lRW5hYmxlZCA9IG5nWm9uZSBpbnN0YW5jZW9mIGNvcmUuTmdab25lO1xuICAgICAgICAgICAgdGhpcy5yZXNldENvbmZpZyhjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VXJsVHJlZSA9IGNyZWF0ZUVtcHR5VXJsVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5yYXdVcmxUcmVlID0gdGhpcy5jdXJyZW50VXJsVHJlZTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlclVybFRyZWUgPSB0aGlzLmN1cnJlbnRVcmxUcmVlO1xuICAgICAgICAgICAgdGhpcy5jb25maWdMb2FkZXIgPSBuZXcgUm91dGVyQ29uZmlnTG9hZGVyKGxvYWRlciwgY29tcGlsZXIsIG9uTG9hZFN0YXJ0LCBvbkxvYWRFbmQpO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXJTdGF0ZSA9IGNyZWF0ZUVtcHR5U3RhdGUodGhpcy5jdXJyZW50VXJsVHJlZSwgdGhpcy5yb290Q29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IHJ4anMuQmVoYXZpb3JTdWJqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJsVHJlZTogdGhpcy5jdXJyZW50VXJsVHJlZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UmF3VXJsOiB0aGlzLmN1cnJlbnRVcmxUcmVlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFVybDogdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5LmV4dHJhY3QodGhpcy5jdXJyZW50VXJsVHJlZSksXG4gICAgICAgICAgICAgICAgdXJsQWZ0ZXJSZWRpcmVjdHM6IHRoaXMudXJsSGFuZGxpbmdTdHJhdGVneS5leHRyYWN0KHRoaXMuY3VycmVudFVybFRyZWUpLFxuICAgICAgICAgICAgICAgIHJhd1VybDogdGhpcy5jdXJyZW50VXJsVHJlZSxcbiAgICAgICAgICAgICAgICBleHRyYXM6IHt9LFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IFByb21pc2UucmVzb2x2ZSh0cnVlKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdpbXBlcmF0aXZlJyxcbiAgICAgICAgICAgICAgICByZXN0b3JlZFN0YXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTbmFwc2hvdDogdGhpcy5yb3V0ZXJTdGF0ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRTbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVyU3RhdGU6IHRoaXMucm91dGVyU3RhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0Um91dGVyU3RhdGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZ3VhcmRzOiB7IGNhbkFjdGl2YXRlQ2hlY2tzOiBbXSwgY2FuRGVhY3RpdmF0ZUNoZWNrczogW10gfSxcbiAgICAgICAgICAgICAgICBndWFyZHNSZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbnMgPSB0aGlzLnNldHVwTmF2aWdhdGlvbnModGhpcy50cmFuc2l0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NOYXZpZ2F0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuc2V0dXBOYXZpZ2F0aW9ucyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBldmVudHNTdWJqZWN0ID0gdGhpcy5ldmVudHM7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbnMucGlwZShvcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmlkICE9PSAwOyB9KSwgXG4gICAgICAgICAgICAvLyBFeHRyYWN0IFVSTFxuICAgICAgICAgICAgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gKF9fYXNzaWduKHt9LCB0LCB7IGV4dHJhY3RlZFVybDogX3RoaXMudXJsSGFuZGxpbmdTdHJhdGVneS5leHRyYWN0KHQucmF3VXJsKSB9KSk7IH0pLCBcbiAgICAgICAgICAgIC8vIFVzaW5nIHN3aXRjaE1hcCBzbyB3ZSBjYW5jZWwgZXhlY3V0aW5nIG5hdmlnYXRpb25zIHdoZW4gYSBuZXcgb25lIGNvbWVzIGluXG4gICAgICAgICAgICBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodCkucGlwZShcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgTmF2aWdhdGlvbiBvYmplY3RcbiAgICAgICAgICAgICAgICBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnROYXZpZ2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsVXJsOiB0LmN1cnJlbnRSYXdVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0ZWRVcmw6IHQuZXh0cmFjdGVkVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYXM6IHQuZXh0cmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOYXZpZ2F0aW9uOiBfdGhpcy5sYXN0U3VjY2Vzc2Z1bE5hdmlnYXRpb24gPyBfX2Fzc2lnbih7fSwgX3RoaXMubGFzdFN1Y2Nlc3NmdWxOYXZpZ2F0aW9uLCB7IHByZXZpb3VzTmF2aWdhdGlvbjogbnVsbCB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmxUcmFuc2l0aW9uID0gIV90aGlzLm5hdmlnYXRlZCB8fCB0LmV4dHJhY3RlZFVybC50b1N0cmluZygpICE9PSBfdGhpcy5icm93c2VyVXJsVHJlZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc0N1cnJlbnRVcmwgPSAoX3RoaXMub25TYW1lVXJsTmF2aWdhdGlvbiA9PT0gJ3JlbG9hZCcgPyB0cnVlIDogdXJsVHJhbnNpdGlvbikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kuc2hvdWxkUHJvY2Vzc1VybCh0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzQ3VycmVudFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgTmF2aWdhdGlvblN0YXJ0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnMuc3dpdGNoTWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBfdGhpcy50cmFuc2l0aW9ucy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuZXcgTmF2aWdhdGlvblN0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIHQuc291cmNlLCB0LnJlc3RvcmVkU3RhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNpdGlvbiAhPT0gX3RoaXMudHJhbnNpdGlvbnMuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5FTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZGVsYXkgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggb2xkIGJlaGF2aW9yIHRoYXQgZm9yY2VkIG5hdmlnYXRpb24gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBiZSBhc3luY1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JzLnN3aXRjaE1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpOyB9KSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseVJlZGlyZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlSZWRpcmVjdHMkMShfdGhpcy5uZ01vZHVsZS5pbmplY3RvciwgX3RoaXMuY29uZmlnTG9hZGVyLCBfdGhpcy51cmxTZXJpYWxpemVyLCBfdGhpcy5jb25maWcpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudE5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF2aWdhdGlvbiA9IF9fYXNzaWduKHt9LCBfdGhpcy5jdXJyZW50TmF2aWdhdGlvbiwgeyBmaW5hbFVybDogdC51cmxBZnRlclJlZGlyZWN0cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29nbml6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2duaXplJDEoX3RoaXMucm9vdENvbXBvbmVudFR5cGUsIF90aGlzLmNvbmZpZywgZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuc2VyaWFsaXplVXJsKHVybCk7IH0sIF90aGlzLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIF90aGlzLnJlbGF0aXZlTGlua1Jlc29sdXRpb24pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBVUkwgaWYgaW4gYGVhZ2VyYCB1cGRhdGUgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy51cmxVcGRhdGVTdHJhdGVneSA9PT0gJ2VhZ2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQuZXh0cmFzLnNraXBMb2NhdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0QnJvd3NlclVybCh0LnVybEFmdGVyUmVkaXJlY3RzLCAhIXQuZXh0cmFzLnJlcGxhY2VVcmwsIHQuaWQsIHQuZXh0cmFzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm93c2VyVXJsVHJlZSA9IHQudXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBSb3V0ZXNSZWNvZ25pemVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlc1JlY29nbml6ZWQgPSBuZXcgUm91dGVzUmVjb2duaXplZCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwodC51cmxBZnRlclJlZGlyZWN0cyksIHQudGFyZ2V0U25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChyb3V0ZXNSZWNvZ25pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzUHJldmlvdXNVcmwgPSB1cmxUcmFuc2l0aW9uICYmIF90aGlzLnJhd1VybFRyZWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5LnNob3VsZFByb2Nlc3NVcmwoX3RoaXMucmF3VXJsVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXaGVuIHRoZSBjdXJyZW50IFVSTCBzaG91bGRuJ3QgYmUgcHJvY2Vzc2VkLCBidXQgdGhlIHByZXZpb3VzIG9uZSB3YXMsIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBoYW5kbGUgdGhpcyBcImVycm9yIGNvbmRpdGlvblwiIGJ5IG5hdmlnYXRpbmcgdG8gdGhlIHByZXZpb3VzbHkgc3VjY2Vzc2Z1bCBVUkwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBidXQgbGVhdmluZyB0aGUgVVJMIGludGFjdC4qL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NQcmV2aW91c1VybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHQuaWQsIGV4dHJhY3RlZFVybCA9IHQuZXh0cmFjdGVkVXJsLCBzb3VyY2UgPSB0LnNvdXJjZSwgcmVzdG9yZWRTdGF0ZSA9IHQucmVzdG9yZWRTdGF0ZSwgZXh0cmFzID0gdC5leHRyYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hdlN0YXJ0ID0gbmV3IE5hdmlnYXRpb25TdGFydChpZCwgX3RoaXMuc2VyaWFsaXplVXJsKGV4dHJhY3RlZFVybCksIHNvdXJjZSwgcmVzdG9yZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KG5hdlN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSBjcmVhdGVFbXB0eVN0YXRlKGV4dHJhY3RlZFVybCwgX3RoaXMucm9vdENvbXBvbmVudFR5cGUpLnNuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKF9fYXNzaWduKHt9LCB0LCB7IHRhcmdldFNuYXBzaG90OiB0YXJnZXRTbmFwc2hvdCwgdXJsQWZ0ZXJSZWRpcmVjdHM6IGV4dHJhY3RlZFVybCwgZXh0cmFzOiBfX2Fzc2lnbih7fSwgZXh0cmFzLCB7IHNraXBMb2NhdGlvbkNoYW5nZTogZmFsc2UsIHJlcGxhY2VVcmw6IGZhbHNlIH0pIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFdoZW4gbmVpdGhlciB0aGUgY3VycmVudCBvciBwcmV2aW91cyBVUkwgY2FuIGJlIHByb2Nlc3NlZCwgZG8gbm90aGluZyBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYW4gdXBkYXRlIHJvdXRlcidzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBcInNldHRsZWRcIiBVUkwuIFRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB3YXkgdGhlIG5leHQgbmF2aWdhdGlvbiB3aWxsIGJlIGNvbWluZyBmcm9tIHRoZSBjdXJyZW50IFVSTCBpbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yYXdVcmxUcmVlID0gdC5yYXdVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnJvd3NlclVybFRyZWUgPSB0LnVybEFmdGVyUmVkaXJlY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5FTVBUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgUHJlYWN0aXZhdGlvblxuICAgICAgICAgICAgICAgIHN3aXRjaFRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBuYXZpZ2F0aW9uSWQgPSB0LmlkLCBhcHBsaWVkVXJsVHJlZSA9IHQuZXh0cmFjdGVkVXJsLCByYXdVcmxUcmVlID0gdC5yYXdVcmwsIF9hID0gdC5leHRyYXMsIHNraXBMb2NhdGlvbkNoYW5nZSA9IF9hLnNraXBMb2NhdGlvbkNoYW5nZSwgcmVwbGFjZVVybCA9IF9hLnJlcGxhY2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ob29rcy5iZWZvcmVQcmVhY3RpdmF0aW9uKHRhcmdldFNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uSWQ6IG5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRVcmxUcmVlOiBhcHBsaWVkVXJsVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1VybFRyZWU6IHJhd1VybFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwTG9jYXRpb25DaGFuZ2U6ICEhc2tpcExvY2F0aW9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVVybDogISFyZXBsYWNlVXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgLy8gLS0tIEdVQVJEUyAtLS1cbiAgICAgICAgICAgICAgICBvcGVyYXRvcnMudGFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZHNTdGFydCA9IG5ldyBHdWFyZHNDaGVja1N0YXJ0KHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChndWFyZHNTdGFydCk7XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgdCwgeyBndWFyZHM6IGdldEFsbFJvdXRlR3VhcmRzKHQudGFyZ2V0U25hcHNob3QsIHQuY3VycmVudFNuYXBzaG90LCBfdGhpcy5yb290Q29udGV4dHMpIH0pKTsgfSksIGNoZWNrR3VhcmRzKF90aGlzLm5nTW9kdWxlLmluamVjdG9yLCBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy50cmlnZ2VyRXZlbnQoZXZ0KTsgfSksIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVXJsVHJlZSh0Lmd1YXJkc1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5hdmlnYXRpb25DYW5jZWxpbmdFcnJvcihcIlJlZGlyZWN0aW5nIHRvIFxcXCJcIiArIF90aGlzLnNlcmlhbGl6ZVVybCh0Lmd1YXJkc1Jlc3VsdCkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci51cmwgPSB0Lmd1YXJkc1Jlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1YXJkc0VuZCA9IG5ldyBHdWFyZHNDaGVja0VuZCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwodC51cmxBZnRlclJlZGlyZWN0cyksIHQudGFyZ2V0U25hcHNob3QsICEhdC5ndWFyZHNSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoZ3VhcmRzRW5kKTtcbiAgICAgICAgICAgICAgICB9KSwgb3BlcmF0b3JzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQuZ3VhcmRzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNldFVybFRvQ3VycmVudFVybFRyZWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXZDYW5jZWwgPSBuZXcgTmF2aWdhdGlvbkNhbmNlbCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2Q2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIC8vIC0tLSBSRVNPTFZFIC0tLVxuICAgICAgICAgICAgICAgIHN3aXRjaFRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5ndWFyZHMuY2FuQWN0aXZhdGVDaGVja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZih0KS5waXBlKG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZVN0YXJ0ID0gbmV3IFJlc29sdmVTdGFydCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBfdGhpcy5zZXJpYWxpemVVcmwodC51cmxBZnRlclJlZGlyZWN0cyksIHQudGFyZ2V0U25hcHNob3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudChyZXNvbHZlU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHJlc29sdmVEYXRhKF90aGlzLnBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3ksIF90aGlzLm5nTW9kdWxlLmluamVjdG9yKSwgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9ycy50YXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUVuZCA9IG5ldyBSZXNvbHZlRW5kKHQuaWQsIF90aGlzLnNlcmlhbGl6ZVVybCh0LmV4dHJhY3RlZFVybCksIF90aGlzLnNlcmlhbGl6ZVVybCh0LnVybEFmdGVyUmVkaXJlY3RzKSwgdC50YXJnZXRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KHJlc29sdmVFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIC8vIC0tLSBBRlRFUiBQUkVBQ1RJVkFUSU9OIC0tLVxuICAgICAgICAgICAgICAgIHN3aXRjaFRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U25hcHNob3QgPSB0LnRhcmdldFNuYXBzaG90LCBuYXZpZ2F0aW9uSWQgPSB0LmlkLCBhcHBsaWVkVXJsVHJlZSA9IHQuZXh0cmFjdGVkVXJsLCByYXdVcmxUcmVlID0gdC5yYXdVcmwsIF9hID0gdC5leHRyYXMsIHNraXBMb2NhdGlvbkNoYW5nZSA9IF9hLnNraXBMb2NhdGlvbkNoYW5nZSwgcmVwbGFjZVVybCA9IF9hLnJlcGxhY2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ob29rcy5hZnRlclByZWFjdGl2YXRpb24odGFyZ2V0U25hcHNob3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb25JZDogbmF2aWdhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFVybFRyZWU6IGFwcGxpZWRVcmxUcmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3VXJsVHJlZTogcmF3VXJsVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBMb2NhdGlvbkNoYW5nZTogISFza2lwTG9jYXRpb25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlVXJsOiAhIXJlcGxhY2VVcmwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRSb3V0ZXJTdGF0ZSA9IGNyZWF0ZVJvdXRlclN0YXRlKF90aGlzLnJvdXRlUmV1c2VTdHJhdGVneSwgdC50YXJnZXRTbmFwc2hvdCwgdC5jdXJyZW50Um91dGVyU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKHt9LCB0LCB7IHRhcmdldFJvdXRlclN0YXRlOiB0YXJnZXRSb3V0ZXJTdGF0ZSB9KSk7XG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIC8qIE9uY2UgaGVyZSwgd2UgYXJlIGFib3V0IHRvIGFjdGl2YXRlIHN5bmNyb25vdXNseS4gVGhlIGFzc3VtcHRpb24gaXMgdGhpcyB3aWxsXG4gICAgICAgICAgICAgICAgICAgc3VjY2VlZCwgYW5kIHVzZXIgY29kZSBtYXkgcmVhZCBmcm9tIHRoZSBSb3V0ZXIgc2VydmljZS4gVGhlcmVmb3JlIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgIGFjdGl2YXRpb24sIHdlIG5lZWQgdG8gdXBkYXRlIHJvdXRlciBwcm9wZXJ0aWVzIHN0b3JpbmcgdGhlIGN1cnJlbnQgVVJMIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAgICBSb3V0ZXJTdGF0ZSwgYXMgd2VsbCBhcyB1cGRhdGVkIHRoZSBicm93c2VyIFVSTC4gQWxsIHRoaXMgc2hvdWxkIGhhcHBlbiAqYmVmb3JlKlxuICAgICAgICAgICAgICAgICAgIGFjdGl2YXRpbmcuICovXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzLnRhcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50VXJsVHJlZSA9IHQudXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJhd1VybFRyZWUgPSBfdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5Lm1lcmdlKF90aGlzLmN1cnJlbnRVcmxUcmVlLCB0LnJhd1VybCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvdXRlclN0YXRlID0gdC50YXJnZXRSb3V0ZXJTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnVybFVwZGF0ZVN0cmF0ZWd5ID09PSAnZGVmZXJyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQuZXh0cmFzLnNraXBMb2NhdGlvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEJyb3dzZXJVcmwoX3RoaXMucmF3VXJsVHJlZSwgISF0LmV4dHJhcy5yZXBsYWNlVXJsLCB0LmlkLCB0LmV4dHJhcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5icm93c2VyVXJsVHJlZSA9IHQudXJsQWZ0ZXJSZWRpcmVjdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgYWN0aXZhdGVSb3V0ZXMoX3RoaXMucm9vdENvbnRleHRzLCBfdGhpcy5yb3V0ZVJldXNlU3RyYXRlZ3ksIGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuIF90aGlzLnRyaWdnZXJFdmVudChldnQpOyB9KSwgb3BlcmF0b3JzLnRhcCh7IG5leHQ6IGZ1bmN0aW9uICgpIHsgY29tcGxldGVkID0gdHJ1ZTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgY29tcGxldGVkID0gdHJ1ZTsgfSB9KSwgb3BlcmF0b3JzLmZpbmFsaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogV2hlbiB0aGUgbmF2aWdhdGlvbiBzdHJlYW0gZmluaXNoZXMgZWl0aGVyIHRocm91Z2ggZXJyb3Igb3Igc3VjY2Vzcywgd2Ugc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBgY29tcGxldGVkYCBvciBgZXJyb3JlZGAgZmxhZy4gSG93ZXZlciwgdGhlcmUgYXJlIHNvbWUgc2l0dWF0aW9ucyB3aGVyZSB3ZSBjb3VsZFxuICAgICAgICAgICAgICAgICAgICAgKiBnZXQgaGVyZSB3aXRob3V0IGVpdGhlciBvZiB0aG9zZSBiZWluZyBzZXQuIEZvciBpbnN0YW5jZSwgYSByZWRpcmVjdCBkdXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICogTmF2aWdhdGlvblN0YXJ0LiBUaGVyZWZvcmUsIHRoaXMgaXMgYSBjYXRjaC1hbGwgdG8gbWFrZSBzdXJlIHRoZSBOYXZpZ2F0aW9uQ2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAqIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBuYXZpZ2F0aW9uIGdldHMgY2FuY2VsbGVkIGJ1dCBub3QgY2F1Z2h0IGJ5IG90aGVyIG1lYW5zLiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCAmJiAhZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCByZXNldCB0byBjdXJyZW50IFVSTCB0cmVlIGhlcmUgdG8gZW5zdXJlIGhpc3Rvcnkuc3RhdGUgaXMgc2V0LiBPbiBhIGZyZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWdlIGxvYWQsIGlmIGEgbmV3IG5hdmlnYXRpb24gY29tZXMgaW4gYmVmb3JlIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZXMsIHRoZXJlIHdpbGwgYmUgbm90aGluZyBpbiBoaXN0b3J5LnN0YXRlLm5hdmlnYXRpb25JZC4gVGhpcyBjYW4gY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bmMgcHJvYmxlbXMgd2l0aCBBbmd1bGFySlMgc3luYyBjb2RlIHdoaWNoIGxvb2tzIGZvciBhIHZhbHVlIGhlcmUgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBoYW5kbGUgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBvciB0byBsZWF2ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIEFuZ3VhbHIgcm91dGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzZXRVcmxUb0N1cnJlbnRVcmxUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2Q2FuY2VsID0gbmV3IE5hdmlnYXRpb25DYW5jZWwodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgXCJOYXZpZ2F0aW9uIElEIFwiICsgdC5pZCArIFwiIGlzIG5vdCBlcXVhbCB0byB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGlkIFwiICsgX3RoaXMubmF2aWdhdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1N1YmplY3QubmV4dChuYXZDYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50TmF2aWdhdGlvbiBzaG91bGQgYWx3YXlzIGJlIHJlc2V0IHRvIG51bGwgaGVyZS4gSWYgbmF2aWdhdGlvbiB3YXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCwgbGFzdFN1Y2Nlc3NmdWxUcmFuc2l0aW9uIHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LiBUaGVyZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHNhZmVseSBzZXQgY3VycmVudE5hdmlnYXRpb24gdG8gbnVsbCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF2aWdhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSksIG9wZXJhdG9ycy5jYXRjaEVycm9yKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIHR5cGUgaXMgaXNzdWVkIGR1cmluZyBSZWRpcmVjdCwgYW5kIGlzIGhhbmRsZWQgYXMgYSBjYW5jZWxsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICogcmF0aGVyIHRoYW4gYW4gZXJyb3IuICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hdmlnYXRpb25DYW5jZWxpbmdFcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZGlyZWN0aW5nID0gaXNVcmxUcmVlKGUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVkaXJlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcHJvcGVydHkgb25seSBpZiB3ZSdyZSBub3QgcmVkaXJlY3RpbmcuIElmIHdlIGxhbmRlZCBvbiBhIHBhZ2UgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVkaXJlY3QgdG8gYC9gIHJvdXRlLCB0aGUgbmV3IG5hdmlnYXRpb24gaXMgZ29pbmcgdG8gc2VlIHRoZSBgL2AgaXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGNoYW5nZSBmcm9tIHRoZSBkZWZhdWx0IGN1cnJlbnRVcmxUcmVlIGFuZCB3b24ndCBuYXZpZ2F0ZS4gVGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwbGljYWJsZSB3aXRoIGluaXRpYWwgbmF2aWdhdGlvbiwgc28gc2V0dGluZyBgbmF2aWdhdGVkYCBvbmx5IHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgcmVkaXJlY3RpbmcgcmVzb2x2ZXMgdGhpcyBzY2VuYXJpby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0U3RhdGVBbmRVcmwodC5jdXJyZW50Um91dGVyU3RhdGUsIHQuY3VycmVudFVybFRyZWUsIHQucmF3VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXZDYW5jZWwgPSBuZXcgTmF2aWdhdGlvbkNhbmNlbCh0LmlkLCBfdGhpcy5zZXJpYWxpemVVcmwodC5leHRyYWN0ZWRVcmwpLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzU3ViamVjdC5uZXh0KG5hdkNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0LnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGVCeVVybChlLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBBbGwgb3RoZXIgZXJyb3JzIHNob3VsZCByZXNldCB0byB0aGUgcm91dGVyJ3MgaW50ZXJuYWwgVVJMIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZS1lcnJvciBzdGF0ZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0U3RhdGVBbmRVcmwodC5jdXJyZW50Um91dGVyU3RhdGUsIHQuY3VycmVudFVybFRyZWUsIHQucmF3VXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXZFcnJvciA9IG5ldyBOYXZpZ2F0aW9uRXJyb3IodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHNTdWJqZWN0Lm5leHQobmF2RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnJlc29sdmUoX3RoaXMuZXJyb3JIYW5kbGVyKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucmVqZWN0KGVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5FTVBUWTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhqYXNvbmFkZW4pOiByZW1vdmUgY2FzdCBvbmNlIGczIGlzIG9uIHVwZGF0ZWQgVHlwZVNjcmlwdFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIFRPRE86IHRoaXMgc2hvdWxkIGJlIHJlbW92ZWQgb25jZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIHJvdXRlciBtYWRlIGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0Um9vdENvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAocm9vdENvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdENvbXBvbmVudFR5cGUgPSByb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gcm91dGVyIDQuMCBzaG91bGQgbWFrZSB0aGUgcm9vdCBjb21wb25lbnQgc2V0IHRvIG51bGxcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBzaW1wbGlmeSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByb3V0ZXIuXG4gICAgICAgICAgICB0aGlzLnJvdXRlclN0YXRlLnJvb3QuY29tcG9uZW50ID0gdGhpcy5yb290Q29tcG9uZW50VHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25zLnZhbHVlO1xuICAgICAgICAgICAgLy8gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBzZXQuIE90aGVyIHZhbHVlcyBzdWNoIGFzIGV4dHJhY3RlZFVybCBhcmUgc2V0IG9uIGluaXRpYWwgbmF2aWdhdGlvblxuICAgICAgICAgICAgLy8gYnV0IHRoZSB1cmxBZnRlclJlZGlyZWN0cyBtYXkgbm90IGdldCBzZXQgaWYgd2UgYXJlbid0IHByb2Nlc3NpbmcgdGhlIG5ldyBVUkwgKmFuZCogbm90XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHRoZSBwcmV2aW91cyBVUkwuXG4gICAgICAgICAgICB0cmFuc2l0aW9uLnVybEFmdGVyUmVkaXJlY3RzID0gdGhpcy5icm93c2VyVXJsVHJlZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9ucy5uZXh0KF9fYXNzaWduKHt9LCB0aGlzLmdldFRyYW5zaXRpb24oKSwgdCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB1cCB0aGUgbG9jYXRpb24gY2hhbmdlIGxpc3RlbmVyIGFuZCBwZXJmb3JtcyB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5pbml0aWFsTmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlQnlVcmwodGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpLCB7IHJlcGxhY2VVcmw6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHVwIHRoZSBsb2NhdGlvbiBjaGFuZ2UgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHVzZSBab25lLndyYXAgYW55IG1vcmUsIGJlY2F1c2Ugem9uZS5qc1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBwYXRjaCBvblBvcFN0YXRlLCBzbyBsb2NhdGlvbiBjaGFuZ2UgY2FsbGJhY2sgd2lsbFxuICAgICAgICAgICAgLy8gcnVuIGludG8gbmdab25lXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5sb2NhdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VXJsVHJlZSA9IF90aGlzLnBhcnNlVXJsKGNoYW5nZVsndXJsJ10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gY2hhbmdlWyd0eXBlJ10gPT09ICdwb3BzdGF0ZScgPyAncG9wc3RhdGUnIDogJ2hhc2hjaGFuZ2UnO1xuICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW9ucyBjb21pbmcgZnJvbSBBbmd1bGFyIHJvdXRlciBoYXZlIGEgbmF2aWdhdGlvbklkIHN0YXRlIHByb3BlcnR5LiBXaGVuIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RzLCByZXN0b3JlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gY2hhbmdlLnN0YXRlICYmIGNoYW5nZS5zdGF0ZS5uYXZpZ2F0aW9uSWQgPyBjaGFuZ2Uuc3RhdGUgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuc2NoZWR1bGVOYXZpZ2F0aW9uKHJhd1VybFRyZWUsIHNvdXJjZSwgc3RhdGUsIHsgcmVwbGFjZVVybDogdHJ1ZSB9KTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXIucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgICAgICAvKiogVGhlIGN1cnJlbnQgVVJMLiAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNlcmlhbGl6ZVVybCh0aGlzLmN1cnJlbnRVcmxUcmVlKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBOYXZpZ2F0aW9uIG9iamVjdCBpZiBvbmUgZXhpc3RzICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuZ2V0Q3VycmVudE5hdmlnYXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmN1cnJlbnROYXZpZ2F0aW9uOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7IHRoaXMuZXZlbnRzLm5leHQoZXZlbnQpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBjb25maWd1cmF0aW9uIHVzZWQgZm9yIG5hdmlnYXRpb24gYW5kIGdlbmVyYXRpbmcgbGlua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgVGhlIHJvdXRlIGFycmF5IGZvciB0aGUgbmV3IGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiByb3V0ZXIucmVzZXRDb25maWcoW1xuICAgICAgICAgKiAgeyBwYXRoOiAndGVhbS86aWQnLCBjb21wb25lbnQ6IFRlYW1DbXAsIGNoaWxkcmVuOiBbXG4gICAgICAgICAqICAgIHsgcGF0aDogJ3NpbXBsZScsIGNvbXBvbmVudDogU2ltcGxlQ21wIH0sXG4gICAgICAgICAqICAgIHsgcGF0aDogJ3VzZXIvOm5hbWUnLCBjb21wb25lbnQ6IFVzZXJDbXAgfVxuICAgICAgICAgKiAgXX1cbiAgICAgICAgICogXSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5yZXNldENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZy5tYXAoc3RhbmRhcmRpemVDb25maWcpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFN1Y2Nlc3NmdWxJZCA9IC0xO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGRvY3NOb3RSZXF1aXJlZCAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpc3Bvc2UoKTsgfTtcbiAgICAgICAgLyoqIERpc3Bvc2VzIG9mIHRoZSByb3V0ZXIuICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2F0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhbiBhcnJheSBvZiBjb21tYW5kcyB0byB0aGUgY3VycmVudCBVUkwgdHJlZSBhbmQgY3JlYXRlcyBhIG5ldyBVUkwgdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBnaXZlbiBhbiBhY3RpdmF0ZSByb3V0ZSwgYXBwbGllcyB0aGUgZ2l2ZW4gY29tbWFuZHMgc3RhcnRpbmcgZnJvbSB0aGUgcm91dGUuXG4gICAgICAgICAqIFdoZW4gbm90IGdpdmVuIGEgcm91dGUsIGFwcGxpZXMgdGhlIGdpdmVuIGNvbW1hbmQgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbW1hbmRzIEFuIGFycmF5IG9mIGNvbW1hbmRzIHRvIGFwcGx5LlxuICAgICAgICAgKiBAcGFyYW0gbmF2aWdhdGlvbkV4dHJhc1xuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbmV3IFVSTCB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogLy8gY3JlYXRlIC90ZWFtLzMzL3VzZXIvMTFcbiAgICAgICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbScsIDMzLCAndXNlcicsIDExXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGNyZWF0ZSAvdGVhbS8zMztleHBhbmQ9dHJ1ZS91c2VyLzExXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge2V4cGFuZDogdHJ1ZX0sICd1c2VyJywgMTFdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8geW91IGNhbiBjb2xsYXBzZSBzdGF0aWMgc2VnbWVudHMgbGlrZSB0aGlzICh0aGlzIHdvcmtzIG9ubHkgd2l0aCB0aGUgZmlyc3QgcGFzc2VkLWluIHZhbHVlKTpcbiAgICAgICAgICogcm91dGVyLmNyZWF0ZVVybFRyZWUoWycvdGVhbS8zMy91c2VyJywgdXNlcklkXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIElmIHRoZSBmaXJzdCBzZWdtZW50IGNhbiBjb250YWluIHNsYXNoZXMsIGFuZCB5b3UgZG8gbm90IHdhbnQgdGhlIHJvdXRlciB0byBzcGxpdCBpdCwgeW91XG4gICAgICAgICAqIC8vIGNhbiBkbyB0aGUgZm9sbG93aW5nOlxuICAgICAgICAgKlxuICAgICAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbe3NlZ21lbnRQYXRoOiAnL29uZS90d28nfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBjcmVhdGUgL3RlYW0vMzMvKHVzZXIvMTEvL3JpZ2h0OmNoYXQpXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiAnY2hhdCd9fV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyByZW1vdmUgdGhlIHJpZ2h0IHNlY29uZGFyeSBub2RlXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnL3RlYW0nLCAzMywge291dGxldHM6IHtwcmltYXJ5OiAndXNlci8xMScsIHJpZ2h0OiBudWxsfX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gYXNzdW1pbmcgdGhlIGN1cnJlbnQgdXJsIGlzIGAvdGVhbS8zMy91c2VyLzExYCBhbmQgdGhlIHJvdXRlIHBvaW50cyB0byBgdXNlci8xMWBcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gbmF2aWdhdGUgdG8gL3RlYW0vMzMvdXNlci8xMS9kZXRhaWxzXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnZGV0YWlscyddLCB7cmVsYXRpdmVUbzogcm91dGV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gbmF2aWdhdGUgdG8gL3RlYW0vMzMvdXNlci8yMlxuICAgICAgICAgKiByb3V0ZXIuY3JlYXRlVXJsVHJlZShbJy4uLzIyJ10sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBuYXZpZ2F0ZSB0byAvdGVhbS80NC91c2VyLzIyXG4gICAgICAgICAqIHJvdXRlci5jcmVhdGVVcmxUcmVlKFsnLi4vLi4vdGVhbS80NC91c2VyLzIyJ10sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUuY3JlYXRlVXJsVHJlZSA9IGZ1bmN0aW9uIChjb21tYW5kcywgbmF2aWdhdGlvbkV4dHJhcykge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRpb25FeHRyYXMgPT09IHZvaWQgMCkgeyBuYXZpZ2F0aW9uRXh0cmFzID0ge307IH1cbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvID0gbmF2aWdhdGlvbkV4dHJhcy5yZWxhdGl2ZVRvLCBxdWVyeVBhcmFtcyA9IG5hdmlnYXRpb25FeHRyYXMucXVlcnlQYXJhbXMsIGZyYWdtZW50ID0gbmF2aWdhdGlvbkV4dHJhcy5mcmFnbWVudCwgcHJlc2VydmVRdWVyeVBhcmFtcyA9IG5hdmlnYXRpb25FeHRyYXMucHJlc2VydmVRdWVyeVBhcmFtcywgcXVlcnlQYXJhbXNIYW5kbGluZyA9IG5hdmlnYXRpb25FeHRyYXMucXVlcnlQYXJhbXNIYW5kbGluZywgcHJlc2VydmVGcmFnbWVudCA9IG5hdmlnYXRpb25FeHRyYXMucHJlc2VydmVGcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIHByZXNlcnZlUXVlcnlQYXJhbXMgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3ByZXNlcnZlUXVlcnlQYXJhbXMgaXMgZGVwcmVjYXRlZCwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhID0gcmVsYXRpdmVUbyB8fCB0aGlzLnJvdXRlclN0YXRlLnJvb3Q7XG4gICAgICAgICAgICB2YXIgZiA9IHByZXNlcnZlRnJhZ21lbnQgPyB0aGlzLmN1cnJlbnRVcmxUcmVlLmZyYWdtZW50IDogZnJhZ21lbnQ7XG4gICAgICAgICAgICB2YXIgcSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocXVlcnlQYXJhbXNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtZXJnZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gX19hc3NpZ24oe30sIHRoaXMuY3VycmVudFVybFRyZWUucXVlcnlQYXJhbXMsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmVzZXJ2ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gdGhpcy5jdXJyZW50VXJsVHJlZS5xdWVyeVBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHF1ZXJ5UGFyYW1zIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcSA9IHByZXNlcnZlUXVlcnlQYXJhbXMgPyB0aGlzLmN1cnJlbnRVcmxUcmVlLnF1ZXJ5UGFyYW1zIDogcXVlcnlQYXJhbXMgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcSA9IHRoaXMucmVtb3ZlRW1wdHlQcm9wcyhxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVVcmxUcmVlKGEsIHRoaXMuY3VycmVudFVybFRyZWUsIGNvbW1hbmRzLCBxLCBmKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBVUkwsIHdoaWNoIG11c3QgYmUgYWJzb2x1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1cmwgQW4gYWJzb2x1dGUgVVJMLiBUaGUgZnVuY3Rpb24gZG9lcyBub3QgYXBwbHkgYW55IGRlbHRhIHRvIHRoZSBjdXJyZW50IFVSTC5cbiAgICAgICAgICogQHBhcmFtIGV4dHJhcyBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRoYXQgbW9kaWZ5IHRoZSBuYXZpZ2F0aW9uIHN0cmF0ZWd5LlxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gaWdub3JlcyBhbnkgcHJvcGVydGllcyBpbiB0aGUgYE5hdmlnYXRpb25FeHRyYXNgIHRoYXQgd291bGQgY2hhbmdlIHRoZVxuICAgICAgICAgKiBwcm92aWRlZCBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvICd0cnVlJyB3aGVuIG5hdmlnYXRpb24gc3VjY2VlZHMsXG4gICAgICAgICAqIHRvICdmYWxzZScgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzLCBvciBpcyByZWplY3RlZCBvbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlTm90ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFwiL3RlYW0vMzMvdXNlci8xMVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gTmF2aWdhdGUgd2l0aG91dCB1cGRhdGluZyB0aGUgVVJMXG4gICAgICAgICAqIHJvdXRlci5uYXZpZ2F0ZUJ5VXJsKFwiL3RlYW0vMzMvdXNlci8xMVwiLCB7IHNraXBMb2NhdGlvbkNoYW5nZTogdHJ1ZSB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlQnlVcmwgPSBmdW5jdGlvbiAodXJsLCBleHRyYXMpIHtcbiAgICAgICAgICAgIGlmIChleHRyYXMgPT09IHZvaWQgMCkgeyBleHRyYXMgPSB7IHNraXBMb2NhdGlvbkNoYW5nZTogZmFsc2UgfTsgfVxuICAgICAgICAgICAgaWYgKGNvcmUuaXNEZXZNb2RlKCkgJiYgdGhpcy5pc05nWm9uZUVuYWJsZWQgJiYgIWNvcmUuTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zb2xlLndhcm4oXCJOYXZpZ2F0aW9uIHRyaWdnZXJlZCBvdXRzaWRlIEFuZ3VsYXIgem9uZSwgZGlkIHlvdSBmb3JnZXQgdG8gY2FsbCAnbmdab25lLnJ1bigpJz9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdXJsVHJlZSA9IGlzVXJsVHJlZSh1cmwpID8gdXJsIDogdGhpcy5wYXJzZVVybCh1cmwpO1xuICAgICAgICAgICAgdmFyIG1lcmdlZFRyZWUgPSB0aGlzLnVybEhhbmRsaW5nU3RyYXRlZ3kubWVyZ2UodXJsVHJlZSwgdGhpcy5yYXdVcmxUcmVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlTmF2aWdhdGlvbihtZXJnZWRUcmVlLCAnaW1wZXJhdGl2ZScsIG51bGwsIGV4dHJhcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYXZpZ2F0ZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgY29tbWFuZHMgYW5kIGEgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAgICAqIElmIG5vIHN0YXJ0aW5nIHJvdXRlIGlzIHByb3ZpZGVkLCB0aGUgbmF2aWdhdGlvbiBpcyBhYnNvbHV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdDpcbiAgICAgICAgICogLSByZXNvbHZlcyB0byAndHJ1ZScgd2hlbiBuYXZpZ2F0aW9uIHN1Y2NlZWRzLFxuICAgICAgICAgKiAtIHJlc29sdmVzIHRvICdmYWxzZScgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzLFxuICAgICAgICAgKiAtIGlzIHJlamVjdGVkIHdoZW4gYW4gZXJyb3IgaGFwcGVucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlTm90ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHJvdXRlci5uYXZpZ2F0ZShbJ3RlYW0nLCAzMywgJ3VzZXInLCAxMV0sIHtyZWxhdGl2ZVRvOiByb3V0ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBOYXZpZ2F0ZSB3aXRob3V0IHVwZGF0aW5nIHRoZSBVUkxcbiAgICAgICAgICogcm91dGVyLm5hdmlnYXRlKFsndGVhbScsIDMzLCAndXNlcicsIDExXSwge3JlbGF0aXZlVG86IHJvdXRlLCBza2lwTG9jYXRpb25DaGFuZ2U6IHRydWV9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgb2YgYG5hdmlnYXRlKClgIGlzIGEgZGVsdGEgdG8gYmUgYXBwbGllZCB0byB0aGUgY3VycmVudCBVUkxcbiAgICAgICAgICogb3IgdGhlIG9uZSBwcm92aWRlZCBpbiB0aGUgYHJlbGF0aXZlVG9gIHByb3BlcnR5IG9mIHRoZSBzZWNvbmQgcGFyYW1ldGVyICh0aGVcbiAgICAgICAgICogYE5hdmlnYXRpb25FeHRyYXNgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gb3JkZXIgdG8gYWZmZWN0IHRoaXMgYnJvd3NlcidzIGBoaXN0b3J5LnN0YXRlYCBlbnRyeSwgdGhlIGBzdGF0ZWBcbiAgICAgICAgICogcGFyYW1ldGVyIGNhbiBiZSBwYXNzZWQuIFRoaXMgbXVzdCBiZSBhbiBvYmplY3QgYmVjYXVzZSB0aGUgcm91dGVyXG4gICAgICAgICAqIHdpbGwgYWRkIHRoZSBgbmF2aWdhdGlvbklkYCBwcm9wZXJ0eSB0byB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgICAgICogdGhlIG5ldyBoaXN0b3J5IGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKGNvbW1hbmRzLCBleHRyYXMpIHtcbiAgICAgICAgICAgIGlmIChleHRyYXMgPT09IHZvaWQgMCkgeyBleHRyYXMgPSB7IHNraXBMb2NhdGlvbkNoYW5nZTogZmFsc2UgfTsgfVxuICAgICAgICAgICAgdmFsaWRhdGVDb21tYW5kcyhjb21tYW5kcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZUJ5VXJsKHRoaXMuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgZXh0cmFzKSwgZXh0cmFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFNlcmlhbGl6ZXMgYSBgVXJsVHJlZWAgaW50byBhIHN0cmluZyAqL1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVVybCA9IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIHRoaXMudXJsU2VyaWFsaXplci5zZXJpYWxpemUodXJsKTsgfTtcbiAgICAgICAgLyoqIFBhcnNlcyBhIHN0cmluZyBpbnRvIGEgYFVybFRyZWVgICovXG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUucGFyc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgdXJsVHJlZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdXJsVHJlZSA9IHRoaXMudXJsU2VyaWFsaXplci5wYXJzZSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1cmxUcmVlID0gdGhpcy5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXIoZSwgdGhpcy51cmxTZXJpYWxpemVyLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybFRyZWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBpcyBhY3RpdmF0ZWQgKi9cbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICh1cmwsIGV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNVcmxUcmVlKHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbnNUcmVlKHRoaXMuY3VycmVudFVybFRyZWUsIHVybCwgZXhhY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVybFRyZWUgPSB0aGlzLnBhcnNlVXJsKHVybCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNUcmVlKHRoaXMuY3VycmVudFVybFRyZWUsIHVybFRyZWUsIGV4YWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5yZW1vdmVFbXB0eVByb3BzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlci5wcm90b3R5cGUucHJvY2Vzc05hdmlnYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbnMuc3Vic2NyaWJlKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0U3VjY2Vzc2Z1bElkID0gdC5pZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudHNcbiAgICAgICAgICAgICAgICAgICAgLm5leHQobmV3IE5hdmlnYXRpb25FbmQodC5pZCwgX3RoaXMuc2VyaWFsaXplVXJsKHQuZXh0cmFjdGVkVXJsKSwgX3RoaXMuc2VyaWFsaXplVXJsKF90aGlzLmN1cnJlbnRVcmxUcmVlKSkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTdWNjZXNzZnVsTmF2aWdhdGlvbiA9IF90aGlzLmN1cnJlbnROYXZpZ2F0aW9uO1xuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnROYXZpZ2F0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0LnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkgeyBfdGhpcy5jb25zb2xlLndhcm4oXCJVbmhhbmRsZWQgTmF2aWdhdGlvbiBFcnJvcjogXCIpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLnByb3RvdHlwZS5zY2hlZHVsZU5hdmlnYXRpb24gPSBmdW5jdGlvbiAocmF3VXJsLCBzb3VyY2UsIHJlc3RvcmVkU3RhdGUsIGV4dHJhcykge1xuICAgICAgICAgICAgdmFyIGxhc3ROYXZpZ2F0aW9uID0gdGhpcy5nZXRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB0cmlnZ2VycyBhIG5hdmlnYXRpb24gaW1wZXJhdGl2ZWx5IChlLmcuLCBieSB1c2luZyBuYXZpZ2F0ZUJ5VXJsKSxcbiAgICAgICAgICAgIC8vIGFuZCB0aGF0IG5hdmlnYXRpb24gcmVzdWx0cyBpbiAncmVwbGFjZVN0YXRlJyB0aGF0IGxlYWRzIHRvIHRoZSBzYW1lIFVSTCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBza2lwIHRob3NlLlxuICAgICAgICAgICAgaWYgKGxhc3ROYXZpZ2F0aW9uICYmIHNvdXJjZSAhPT0gJ2ltcGVyYXRpdmUnICYmIGxhc3ROYXZpZ2F0aW9uLnNvdXJjZSA9PT0gJ2ltcGVyYXRpdmUnICYmXG4gICAgICAgICAgICAgICAgbGFzdE5hdmlnYXRpb24ucmF3VXJsLnRvU3RyaW5nKCkgPT09IHJhd1VybC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgLy8gcmV0dXJuIHZhbHVlIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIGEgYnVnIGluIElFIGFuZCBFZGdlLCB0aGUgbG9jYXRpb24gY2xhc3MgZmlyZXMgdHdvIGV2ZW50cyAocG9wc3RhdGUgYW5kXG4gICAgICAgICAgICAvLyBoYXNoY2hhbmdlKSBldmVyeSBzaW5nbGUgdGltZS4gVGhlIHNlY29uZCBvbmUgc2hvdWxkIGJlIGlnbm9yZWQuIE90aGVyd2lzZSwgdGhlIFVSTCB3aWxsXG4gICAgICAgICAgICAvLyBmbGlja2VyLiBIYW5kbGVzIHRoZSBjYXNlIHdoZW4gYSBwb3BzdGF0ZSB3YXMgZW1pdHRlZCBmaXJzdC5cbiAgICAgICAgICAgIGlmIChsYXN0TmF2aWdhdGlvbiAmJiBzb3VyY2UgPT0gJ2hhc2hjaGFuZ2UnICYmIGxhc3ROYXZpZ2F0aW9uLnNvdXJjZSA9PT0gJ3BvcHN0YXRlJyAmJlxuICAgICAgICAgICAgICAgIGxhc3ROYXZpZ2F0aW9uLnJhd1VybC50b1N0cmluZygpID09PSByYXdVcmwudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IC8vIHJldHVybiB2YWx1ZSBpcyBub3QgdXNlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRSBhbmQgRWRnZSwgdGhlIGxvY2F0aW9uIGNsYXNzIGZpcmVzIHR3byBldmVudHMgKHBvcHN0YXRlIGFuZFxuICAgICAgICAgICAgLy8gaGFzaGNoYW5nZSkgZXZlcnkgc2luZ2xlIHRpbWUuIFRoZSBzZWNvbmQgb25lIHNob3VsZCBiZSBpZ25vcmVkLiBPdGhlcndpc2UsIHRoZSBVUkwgd2lsbFxuICAgICAgICAgICAgLy8gZmxpY2tlci4gSGFuZGxlcyB0aGUgY2FzZSB3aGVuIGEgaGFzaGNoYW5nZSB3YXMgZW1pdHRlZCBmaXJzdC5cbiAgICAgICAgICAgIGlmIChsYXN0TmF2aWdhdGlvbiAmJiBzb3VyY2UgPT0gJ3BvcHN0YXRlJyAmJiBsYXN0TmF2aWdhdGlvbi5zb3VyY2UgPT09ICdoYXNoY2hhbmdlJyAmJlxuICAgICAgICAgICAgICAgIGxhc3ROYXZpZ2F0aW9uLnJhd1VybC50b1N0cmluZygpID09PSByYXdVcmwudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7IC8vIHJldHVybiB2YWx1ZSBpcyBub3QgdXNlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc29sdmUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlamVjdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaWQgPSArK3RoaXMubmF2aWdhdGlvbklkO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgcmVzdG9yZWRTdGF0ZTogcmVzdG9yZWRTdGF0ZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJsVHJlZTogdGhpcy5jdXJyZW50VXJsVHJlZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UmF3VXJsOiB0aGlzLnJhd1VybFRyZWUsIHJhd1VybDogcmF3VXJsLCBleHRyYXM6IGV4dHJhcywgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QsIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgY3VycmVudFNuYXBzaG90OiB0aGlzLnJvdXRlclN0YXRlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXJTdGF0ZTogdGhpcy5yb3V0ZXJTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgZXJyb3IgaXMgcHJvcGFnYXRlZCBldmVuIHRob3VnaCBgcHJvY2Vzc05hdmlnYXRpb25zYCBjYXRjaFxuICAgICAgICAgICAgLy8gaGFuZGxlciBkb2VzIG5vdCByZXRocm93XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnNldEJyb3dzZXJVcmwgPSBmdW5jdGlvbiAodXJsLCByZXBsYWNlVXJsLCBpZCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy51cmxTZXJpYWxpemVyLnNlcmlhbGl6ZSh1cmwpO1xuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2F0aW9uLmlzQ3VycmVudFBhdGhFcXVhbFRvKHBhdGgpIHx8IHJlcGxhY2VVcmwpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGphc29uYWRlbik6IFJlbW92ZSBmaXJzdCBgbmF2aWdhdGlvbklkYCBhbmQgcmVseSBvbiBgbmdgIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uLnJlcGxhY2VTdGF0ZShwYXRoLCAnJywgX19hc3NpZ24oe30sIHN0YXRlLCB7IG5hdmlnYXRpb25JZDogaWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbi5nbyhwYXRoLCAnJywgX19hc3NpZ24oe30sIHN0YXRlLCB7IG5hdmlnYXRpb25JZDogaWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0U3RhdGVBbmRVcmwgPSBmdW5jdGlvbiAoc3RvcmVkU3RhdGUsIHN0b3JlZFVybCwgcmF3VXJsKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlclN0YXRlID0gc3RvcmVkU3RhdGU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVcmxUcmVlID0gc3RvcmVkVXJsO1xuICAgICAgICAgICAgdGhpcy5yYXdVcmxUcmVlID0gdGhpcy51cmxIYW5kbGluZ1N0cmF0ZWd5Lm1lcmdlKHRoaXMuY3VycmVudFVybFRyZWUsIHJhd1VybCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSgpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnJlc2V0VXJsVG9DdXJyZW50VXJsVHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHRoaXMudXJsU2VyaWFsaXplci5zZXJpYWxpemUodGhpcy5yYXdVcmxUcmVlKSwgJycsIHsgbmF2aWdhdGlvbklkOiB0aGlzLmxhc3RTdWNjZXNzZnVsSWQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbW1hbmRzKGNvbW1hbmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgIGlmIChjbWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgcGF0aCBjb250YWlucyBcIiArIGNtZCArIFwiIHNlZ21lbnQgYXQgaW5kZXggXCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIExldHMgeW91IGxpbmsgdG8gc3BlY2lmaWMgcm91dGVzIGluIHlvdXIgYXBwLlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgdGhlIGZvbGxvd2luZyByb3V0ZSBjb25maWd1cmF0aW9uOlxuICAgICAqIGBbeyBwYXRoOiAndXNlci86bmFtZScsIGNvbXBvbmVudDogVXNlckNtcCB9XWAuXG4gICAgICogV2hlbiBsaW5raW5nIHRvIHRoaXMgYHVzZXIvOm5hbWVgIHJvdXRlLCB5b3UgdXNlIHRoZSBgUm91dGVyTGlua2AgZGlyZWN0aXZlLlxuICAgICAqXG4gICAgICogSWYgdGhlIGxpbmsgaXMgc3RhdGljLCB5b3UgY2FuIHVzZSB0aGUgZGlyZWN0aXZlIGFzIGZvbGxvd3M6XG4gICAgICogYDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIj5saW5rIHRvIHVzZXIgY29tcG9uZW50PC9hPmBcbiAgICAgKlxuICAgICAqIElmIHlvdSB1c2UgZHluYW1pYyB2YWx1ZXMgdG8gZ2VuZXJhdGUgdGhlIGxpbmssIHlvdSBjYW4gcGFzcyBhbiBhcnJheSBvZiBwYXRoXG4gICAgICogc2VnbWVudHMsIGZvbGxvd2VkIGJ5IHRoZSBwYXJhbXMgZm9yIGVhY2ggc2VnbWVudC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSBgWycvdGVhbScsIHRlYW1JZCwgJ3VzZXInLCB1c2VyTmFtZSwge2RldGFpbHM6IHRydWV9XWBcbiAgICAgKiBtZWFucyB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgYSBsaW5rIHRvIGAvdGVhbS8xMS91c2VyL2JvYjtkZXRhaWxzPXRydWVgLlxuICAgICAqXG4gICAgICogTXVsdGlwbGUgc3RhdGljIHNlZ21lbnRzIGNhbiBiZSBtZXJnZWQgaW50byBvbmVcbiAgICAgKiAoZS5nLiwgYFsnL3RlYW0vMTEvdXNlcicsIHVzZXJOYW1lLCB7ZGV0YWlsczogdHJ1ZX1dYCkuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc2VnbWVudCBuYW1lIGNhbiBiZSBwcmVwZW5kZWQgd2l0aCBgL2AsIGAuL2AsIG9yIGAuLi9gOlxuICAgICAqICogSWYgdGhlIGZpcnN0IHNlZ21lbnQgYmVnaW5zIHdpdGggYC9gLCB0aGUgcm91dGVyIHdpbGwgbG9vayB1cCB0aGUgcm91dGUgZnJvbSB0aGUgcm9vdCBvZiB0aGVcbiAgICAgKiAgIGFwcC5cbiAgICAgKiAqIElmIHRoZSBmaXJzdCBzZWdtZW50IGJlZ2lucyB3aXRoIGAuL2AsIG9yIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIHNsYXNoLCB0aGUgcm91dGVyIHdpbGxcbiAgICAgKiAgIGluc3RlYWQgbG9vayBpbiB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgYWN0aXZhdGVkIHJvdXRlLlxuICAgICAqICogQW5kIGlmIHRoZSBmaXJzdCBzZWdtZW50IGJlZ2lucyB3aXRoIGAuLi9gLCB0aGUgcm91dGVyIHdpbGwgZ28gdXAgb25lIGxldmVsLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzZXQgcXVlcnkgcGFyYW1zIGFuZCBmcmFnbWVudCBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgZnJhZ21lbnQ9XCJlZHVjYXRpb25cIj5cbiAgICAgKiAgIGxpbmsgdG8gdXNlciBjb21wb25lbnRcbiAgICAgKiA8L2E+XG4gICAgICogYGBgXG4gICAgICogUm91dGVyTGluayB3aWxsIHVzZSB0aGVzZSB0byBnZW5lcmF0ZSB0aGlzIGxpbms6IGAvdXNlci9ib2IjZWR1Y2F0aW9uP2RlYnVnPXRydWVgLlxuICAgICAqXG4gICAgICogKERlcHJlY2F0ZWQgaW4gdjQuMC4wIHVzZSBgcXVlcnlQYXJhbXNIYW5kbGluZ2AgaW5zdGVhZCkgWW91IGNhbiBhbHNvIHRlbGwgdGhlXG4gICAgICogZGlyZWN0aXZlIHRvIHByZXNlcnZlIHRoZSBjdXJyZW50IHF1ZXJ5IHBhcmFtcyBhbmQgZnJhZ21lbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSBbcm91dGVyTGlua109XCJbJy91c2VyL2JvYiddXCIgcHJlc2VydmVRdWVyeVBhcmFtcyBwcmVzZXJ2ZUZyYWdtZW50PlxuICAgICAqICAgbGluayB0byB1c2VyIGNvbXBvbmVudFxuICAgICAqIDwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdGVsbCB0aGUgZGlyZWN0aXZlIGhvdyB0byBoYW5kbGUgcXVlcnlQYXJhbXMuIEF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgLSBgJ21lcmdlJ2A6IG1lcmdlIHRoZSBxdWVyeVBhcmFtcyBpbnRvIHRoZSBjdXJyZW50IHF1ZXJ5UGFyYW1zXG4gICAgICogIC0gYCdwcmVzZXJ2ZSdgOiBwcmVzZXJ2ZSB0aGUgY3VycmVudCBxdWVyeVBhcmFtc1xuICAgICAqICAtIGRlZmF1bHQvYCcnYDogdXNlIHRoZSBxdWVyeVBhcmFtcyBvbmx5XG4gICAgICpcbiAgICAgKiBTYW1lIG9wdGlvbnMgZm9yIHtAbGluayBOYXZpZ2F0aW9uRXh0cmFzI3F1ZXJ5UGFyYW1zSGFuZGxpbmdcbiAgICAgKiBOYXZpZ2F0aW9uRXh0cmFzI3F1ZXJ5UGFyYW1zSGFuZGxpbmd9LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGEgW3JvdXRlckxpbmtdPVwiWycvdXNlci9ib2InXVwiIFtxdWVyeVBhcmFtc109XCJ7ZGVidWc6IHRydWV9XCIgcXVlcnlQYXJhbXNIYW5kbGluZz1cIm1lcmdlXCI+XG4gICAgICogICBsaW5rIHRvIHVzZXIgY29tcG9uZW50XG4gICAgICogPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBwcm92aWRlIGEgYHN0YXRlYCB2YWx1ZSB0byBiZSBwZXJzaXN0ZWQgdG8gdGhlIGJyb3dzZXIncyBIaXN0b3J5LnN0YXRlXG4gICAgICogcHJvcGVydHkgKFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeSNQcm9wZXJ0aWVzKS4gSXQnc1xuICAgICAqIHVzZWQgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhIFtyb3V0ZXJMaW5rXT1cIlsnL3VzZXIvYm9iJ11cIiBbc3RhdGVdPVwie3RyYWNpbmdJZDogMTIzfVwiPlxuICAgICAqICAgbGluayB0byB1c2VyIGNvbXBvbmVudFxuICAgICAqIDwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEFuZCBsYXRlciB0aGUgdmFsdWUgY2FuIGJlIHJlYWQgZnJvbSB0aGUgcm91dGVyIHRocm91Z2ggYHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbmAuXG4gICAgICogRm9yIGV4YW1wbGUsIHRvIGNhcHR1cmUgdGhlIGB0cmFjaW5nSWRgIGFib3ZlIGR1cmluZyB0aGUgYE5hdmlnYXRpb25TdGFydGAgZXZlbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBHZXQgTmF2aWdhdGlvblN0YXJ0IGV2ZW50c1xuICAgICAqIHJvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZSA9PiBlIGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSkuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAqICAgY29uc3QgbmF2aWdhdGlvbiA9IHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbigpO1xuICAgICAqICAgdHJhY2luZ1NlcnZpY2UudHJhY2Uoe2lkOiBuYXZpZ2F0aW9uLmV4dHJhcy5zdGF0ZS50cmFjaW5nSWR9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSByb3V0ZXIgbGluayBkaXJlY3RpdmUgYWx3YXlzIHRyZWF0cyB0aGUgcHJvdmlkZWQgaW5wdXQgYXMgYSBkZWx0YSB0byB0aGUgY3VycmVudCB1cmwuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGlmIHRoZSBjdXJyZW50IHVybCBpcyBgL3VzZXIvKGJveC8vYXV4OnRlYW0pYC5cbiAgICAgKlxuICAgICAqIFRoZW4gdGhlIGZvbGxvd2luZyBsaW5rIGA8YSBbcm91dGVyTGlua109XCJbJy91c2VyL2ppbSddXCI+SmltPC9hPmAgd2lsbCBnZW5lcmF0ZSB0aGUgbGlua1xuICAgICAqIGAvdXNlci8oamltLy9hdXg6dGVhbSlgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBSb3V0ZXIjY3JlYXRlVXJsVHJlZSBjcmVhdGVVcmxUcmVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVyTGluayhyb3V0ZXIsIHJvdXRlLCB0YWJJbmRleCwgcmVuZGVyZXIsIGVsKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0QXR0cmlidXRlKGVsLm5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcsICcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJvdXRlckxpbmtcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gQXJyYXkuaXNBcnJheShjb21tYW5kcykgPyBjb21tYW5kcyA6IFtjb21tYW5kc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgNC4wLjAgdXNlIGBxdWVyeVBhcmFtc0hhbmRsaW5nYCBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJlc2VydmVRdWVyeVBhcmFtcyBpcyBkZXByZWNhdGVkISwgdXNlIHF1ZXJ5UGFyYW1zSGFuZGxpbmcgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzZXJ2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlckxpbmsucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFzID0ge1xuICAgICAgICAgICAgICAgIHNraXBMb2NhdGlvbkNoYW5nZTogYXR0ckJvb2xWYWx1ZSh0aGlzLnNraXBMb2NhdGlvbkNoYW5nZSksXG4gICAgICAgICAgICAgICAgcmVwbGFjZVVybDogYXR0ckJvb2xWYWx1ZSh0aGlzLnJlcGxhY2VVcmwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodGhpcy51cmxUcmVlLCBleHRyYXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJ1cmxUcmVlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jcmVhdGVVcmxUcmVlKHRoaXMuY29tbWFuZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5yb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHRoaXMucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVF1ZXJ5UGFyYW1zOiBhdHRyQm9vbFZhbHVlKHRoaXMucHJlc2VydmUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc0hhbmRsaW5nOiB0aGlzLnF1ZXJ5UGFyYW1zSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlRnJhZ21lbnQ6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZUZyYWdtZW50KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICAgICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwiZnJhZ21lbnRcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJxdWVyeVBhcmFtc0hhbmRsaW5nXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInByZXNlcnZlRnJhZ21lbnRcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICAgICAgXSwgUm91dGVyTGluay5wcm90b3R5cGUsIFwic2tpcExvY2F0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG4gICAgICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInJlcGxhY2VVcmxcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rXCIsIG51bGwpO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG4gICAgICAgIF0sIFJvdXRlckxpbmsucHJvdG90eXBlLCBcInByZXNlcnZlUXVlcnlQYXJhbXNcIiwgbnVsbCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5Ib3N0TGlzdGVuZXIoJ2NsaWNrJyksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuICAgICAgICBSb3V0ZXJMaW5rID0gX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnOm5vdChhKTpub3QoYXJlYSlbcm91dGVyTGlua10nIH0pLFxuICAgICAgICAgICAgX19wYXJhbSgyLCBjb3JlLkF0dHJpYnV0ZSgndGFiaW5kZXgnKSksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgQWN0aXZhdGVkUm91dGUsIFN0cmluZywgY29yZS5SZW5kZXJlcjIsIGNvcmUuRWxlbWVudFJlZl0pXG4gICAgICAgIF0sIFJvdXRlckxpbmspO1xuICAgICAgICByZXR1cm4gUm91dGVyTGluaztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogTGV0cyB5b3UgbGluayB0byBzcGVjaWZpYyByb3V0ZXMgaW4geW91ciBhcHAuXG4gICAgICpcbiAgICAgKiBTZWUgYFJvdXRlckxpbmtgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQG5nTW9kdWxlIFJvdXRlck1vZHVsZVxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJMaW5rV2l0aEhyZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtXaXRoSHJlZihyb3V0ZXIsIHJvdXRlLCBsb2NhdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uU3RyYXRlZ3kgPSBsb2NhdGlvblN0cmF0ZWd5O1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIGlmIChzIGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUYXJnZXRVcmxBbmRIcmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmRzKSA/IGNvbW1hbmRzIDogW2NvbW1hbmRzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicHJlc2VydmVRdWVyeVBhcmFtc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzRGV2TW9kZSgpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJlc2VydmVRdWVyeVBhcmFtcyBpcyBkZXByZWNhdGVkLCB1c2UgcXVlcnlQYXJhbXNIYW5kbGluZyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnByZXNlcnZlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHRoaXMudXBkYXRlVGFyZ2V0VXJsQW5kSHJlZigpOyB9O1xuICAgICAgICBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoYnV0dG9uLCBjdHJsS2V5LCBtZXRhS2V5LCBzaGlmdEtleSkge1xuICAgICAgICAgICAgaWYgKGJ1dHRvbiAhPT0gMCB8fCBjdHJsS2V5IHx8IG1ldGFLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXQgPT09ICdzdHJpbmcnICYmIHRoaXMudGFyZ2V0ICE9ICdfc2VsZicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleHRyYXMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcExvY2F0aW9uQ2hhbmdlOiBhdHRyQm9vbFZhbHVlKHRoaXMuc2tpcExvY2F0aW9uQ2hhbmdlKSxcbiAgICAgICAgICAgICAgICByZXBsYWNlVXJsOiBhdHRyQm9vbFZhbHVlKHRoaXMucmVwbGFjZVVybCksXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHRoaXMudXJsVHJlZSwgZXh0cmFzKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZS51cGRhdGVUYXJnZXRVcmxBbmRIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5sb2NhdGlvblN0cmF0ZWd5LnByZXBhcmVFeHRlcm5hbFVybCh0aGlzLnJvdXRlci5zZXJpYWxpemVVcmwodGhpcy51cmxUcmVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInVybFRyZWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmNyZWF0ZVVybFRyZWUodGhpcy5jb21tYW5kcywge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB0aGlzLnJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogdGhpcy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHRoaXMuZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlUXVlcnlQYXJhbXM6IGF0dHJCb29sVmFsdWUodGhpcy5wcmVzZXJ2ZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zSGFuZGxpbmc6IHRoaXMucXVlcnlQYXJhbXNIYW5kbGluZyxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVGcmFnbWVudDogYXR0ckJvb2xWYWx1ZSh0aGlzLnByZXNlcnZlRnJhZ21lbnQpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5Ib3N0QmluZGluZygnYXR0ci50YXJnZXQnKSwgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInF1ZXJ5UGFyYW1zXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJmcmFnbWVudFwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwicXVlcnlQYXJhbXNIYW5kbGluZ1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInByZXNlcnZlRnJhZ21lbnRcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJza2lwTG9jYXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJyZXBsYWNlVXJsXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSG9zdEJpbmRpbmcoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG4gICAgICAgIF0sIFJvdXRlckxpbmtXaXRoSHJlZi5wcm90b3R5cGUsIFwiaHJlZlwiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcInJvdXRlckxpbmtcIiwgbnVsbCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbnB1dCgpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbiAgICAgICAgXSwgUm91dGVyTGlua1dpdGhIcmVmLnByb3RvdHlwZSwgXCJwcmVzZXJ2ZVF1ZXJ5UGFyYW1zXCIsIG51bGwpO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LmJ1dHRvbicsICckZXZlbnQuY3RybEtleScsICckZXZlbnQubWV0YUtleScsICckZXZlbnQuc2hpZnRLZXknXSksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXIsIEJvb2xlYW4sIEJvb2xlYW4sIEJvb2xlYW5dKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBCb29sZWFuKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG4gICAgICAgIFJvdXRlckxpbmtXaXRoSHJlZiA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Fbcm91dGVyTGlua10sYXJlYVtyb3V0ZXJMaW5rXScgfSksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgQWN0aXZhdGVkUm91dGUsXG4gICAgICAgICAgICAgICAgY29tbW9uLkxvY2F0aW9uU3RyYXRlZ3ldKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rV2l0aEhyZWYpO1xuICAgICAgICByZXR1cm4gUm91dGVyTGlua1dpdGhIcmVmO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gYXR0ckJvb2xWYWx1ZShzKSB7XG4gICAgICAgIHJldHVybiBzID09PSAnJyB8fCAhIXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBMZXRzIHlvdSBhZGQgYSBDU1MgY2xhc3MgdG8gYW4gZWxlbWVudCB3aGVuIHRoZSBsaW5rJ3Mgcm91dGUgYmVjb21lcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBsZXRzIHlvdSBhZGQgYSBDU1MgY2xhc3MgdG8gYW4gZWxlbWVudCB3aGVuIHRoZSBsaW5rJ3Mgcm91dGVcbiAgICAgKiBiZWNvbWVzIGFjdGl2ZS5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiByb3V0ZXJMaW5rQWN0aXZlPVwiYWN0aXZlLWxpbmtcIj5Cb2I8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSB1cmwgaXMgZWl0aGVyICcvdXNlcicgb3IgJy91c2VyL2JvYicsIHRoZSBhY3RpdmUtbGluayBjbGFzcyB3aWxsXG4gICAgICogYmUgYWRkZWQgdG8gdGhlIGBhYCB0YWcuIElmIHRoZSB1cmwgY2hhbmdlcywgdGhlIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gc2V0IG1vcmUgdGhhbiBvbmUgY2xhc3MsIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvYm9iXCIgcm91dGVyTGlua0FjdGl2ZT1cImNsYXNzMSBjbGFzczJcIj5Cb2I8L2E+XG4gICAgICogPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cIlsnY2xhc3MxJywgJ2NsYXNzMiddXCI+Qm9iPC9hPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBjb25maWd1cmUgUm91dGVyTGlua0FjdGl2ZSBieSBwYXNzaW5nIGBleGFjdDogdHJ1ZWAuIFRoaXMgd2lsbCBhZGQgdGhlIGNsYXNzZXNcbiAgICAgKiBvbmx5IHdoZW4gdGhlIHVybCBtYXRjaGVzIHRoZSBsaW5rIGV4YWN0bHkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvYm9iXCIgcm91dGVyTGlua0FjdGl2ZT1cImFjdGl2ZS1saW5rXCIgW3JvdXRlckxpbmtBY3RpdmVPcHRpb25zXT1cIntleGFjdDpcbiAgICAgKiB0cnVlfVwiPkJvYjwvYT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYXNzaWduIHRoZSBSb3V0ZXJMaW5rQWN0aXZlIGluc3RhbmNlIHRvIGEgdGVtcGxhdGUgdmFyaWFibGUgYW5kIGRpcmVjdGx5IGNoZWNrXG4gICAgICogdGhlIGBpc0FjdGl2ZWAgc3RhdHVzLlxuICAgICAqIGBgYFxuICAgICAqIDxhIHJvdXRlckxpbms9XCIvdXNlci9ib2JcIiByb3V0ZXJMaW5rQWN0aXZlICNybGE9XCJyb3V0ZXJMaW5rQWN0aXZlXCI+XG4gICAgICogICBCb2Ige3sgcmxhLmlzQWN0aXZlID8gJyhhbHJlYWR5IG9wZW4pJyA6ICcnfX1cbiAgICAgKiA8L2E+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBGaW5hbGx5LCB5b3UgY2FuIGFwcGx5IHRoZSBSb3V0ZXJMaW5rQWN0aXZlIGRpcmVjdGl2ZSB0byBhbiBhbmNlc3RvciBvZiBhIFJvdXRlckxpbmsuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2IHJvdXRlckxpbmtBY3RpdmU9XCJhY3RpdmUtbGlua1wiIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XCJ7ZXhhY3Q6IHRydWV9XCI+XG4gICAgICogICA8YSByb3V0ZXJMaW5rPVwiL3VzZXIvamltXCI+SmltPC9hPlxuICAgICAqICAgPGEgcm91dGVyTGluaz1cIi91c2VyL2JvYlwiPkJvYjwvYT5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBzZXQgdGhlIGFjdGl2ZS1saW5rIGNsYXNzIG9uIHRoZSBkaXYgdGFnIGlmIHRoZSB1cmwgaXMgZWl0aGVyICcvdXNlci9qaW0nIG9yXG4gICAgICogJy91c2VyL2JvYicuXG4gICAgICpcbiAgICAgKiBAbmdNb2R1bGUgUm91dGVyTW9kdWxlXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJvdXRlckxpbmtBY3RpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlckxpbmtBY3RpdmUocm91dGVyLCBlbGVtZW50LCByZW5kZXJlciwgbGluaywgbGlua1dpdGhIcmVmKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgICAgIHRoaXMubGlua1dpdGhIcmVmID0gbGlua1dpdGhIcmVmO1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdXRlckxpbmtBY3RpdmVPcHRpb25zID0geyBleGFjdDogZmFsc2UgfTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocyBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMubGlua3MuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMubGlua3NXaXRoSHJlZnMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogZGF0YS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhIWM7IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHsgdGhpcy51cGRhdGUoKTsgfTtcbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlua3MgfHwgIXRoaXMubGlua3NXaXRoSHJlZnMgfHwgIXRoaXMucm91dGVyLm5hdmlnYXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQWN0aXZlTGlua3MgPSBfdGhpcy5oYXNBY3RpdmVMaW5rcygpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSAhPT0gaGFzQWN0aXZlTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBoYXNBY3RpdmVMaW5rcztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQWN0aXZlTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhfdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlckxpbmtBY3RpdmUucHJvdG90eXBlLmlzTGlua0FjdGl2ZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVyLmlzQWN0aXZlKGxpbmsudXJsVHJlZSwgX3RoaXMucm91dGVyTGlua0FjdGl2ZU9wdGlvbnMuZXhhY3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUuaGFzQWN0aXZlTGlua3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmVDaGVja0ZuID0gdGhpcy5pc0xpbmtBY3RpdmUodGhpcy5yb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluayAmJiBpc0FjdGl2ZUNoZWNrRm4odGhpcy5saW5rKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGlua1dpdGhIcmVmICYmIGlzQWN0aXZlQ2hlY2tGbih0aGlzLmxpbmtXaXRoSHJlZikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtzLnNvbWUoaXNBY3RpdmVDaGVja0ZuKSB8fCB0aGlzLmxpbmtzV2l0aEhyZWZzLnNvbWUoaXNBY3RpdmVDaGVja0ZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLkNvbnRlbnRDaGlsZHJlbihSb3V0ZXJMaW5rLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIGNvcmUuUXVlcnlMaXN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJsaW5rc1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuQ29udGVudENoaWxkcmVuKFJvdXRlckxpbmtXaXRoSHJlZiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBjb3JlLlF1ZXJ5TGlzdClcbiAgICAgICAgXSwgUm91dGVyTGlua0FjdGl2ZS5wcm90b3R5cGUsIFwibGlua3NXaXRoSHJlZnNcIiwgdm9pZCAwKTtcbiAgICAgICAgX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLklucHV0KCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuSW5wdXQoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuICAgICAgICBdLCBSb3V0ZXJMaW5rQWN0aXZlLnByb3RvdHlwZSwgXCJyb3V0ZXJMaW5rQWN0aXZlXCIsIG51bGwpO1xuICAgICAgICBSb3V0ZXJMaW5rQWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgICAgICAgICBjb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcm91dGVyTGlua0FjdGl2ZV0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAncm91dGVyTGlua0FjdGl2ZScsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF9fcGFyYW0oMywgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fcGFyYW0oNCwgY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm91dGVyLCBjb3JlLkVsZW1lbnRSZWYsIGNvcmUuUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgIFJvdXRlckxpbmssXG4gICAgICAgICAgICAgICAgUm91dGVyTGlua1dpdGhIcmVmXSlcbiAgICAgICAgXSwgUm91dGVyTGlua0FjdGl2ZSk7XG4gICAgICAgIHJldHVybiBSb3V0ZXJMaW5rQWN0aXZlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCBhIGBSb3V0ZXJPdXRsZXRgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIE91dGxldENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE91dGxldENvbnRleHQoKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBDaGlsZHJlbk91dGxldENvbnRleHRzKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE91dGxldENvbnRleHQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZHJlbiAoPSBuZXN0ZWQpIGBSb3V0ZXJPdXRsZXRgXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIENoaWxkcmVuT3V0bGV0Q29udGV4dHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoaWxkcmVuT3V0bGV0Q29udGV4dHMoKSB7XG4gICAgICAgICAgICAvLyBjb250ZXh0cyBmb3IgY2hpbGQgb3V0bGV0cywgYnkgbmFtZS5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENhbGxlZCB3aGVuIGEgYFJvdXRlck91dGxldGAgZGlyZWN0aXZlIGlzIGluc3RhbnRpYXRlZCAqL1xuICAgICAgICBDaGlsZHJlbk91dGxldENvbnRleHRzLnByb3RvdHlwZS5vbkNoaWxkT3V0bGV0Q3JlYXRlZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIG91dGxldCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldE9yQ3JlYXRlQ29udGV4dChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgY29udGV4dC5vdXRsZXQgPSBvdXRsZXQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLnNldChjaGlsZE5hbWUsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSBgUm91dGVyT3V0bGV0YCBkaXJlY3RpdmUgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBXZSBuZWVkIHRvIGtlZXAgdGhlIGNvbnRleHQgYXMgdGhlIG91dGxldCBjb3VsZCBiZSBkZXN0cm95ZWQgaW5zaWRlIGEgTmdJZiBhbmQgbWlnaHQgYmVcbiAgICAgICAgICogcmUtY3JlYXRlZCBsYXRlci5cbiAgICAgICAgICovXG4gICAgICAgIENoaWxkcmVuT3V0bGV0Q29udGV4dHMucHJvdG90eXBlLm9uQ2hpbGRPdXRsZXREZXN0cm95ZWQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm91dGxldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29ycmVzcG9uZGluZyByb3V0ZSBpcyBkZWFjdGl2YXRlZCBkdXJpbmcgbmF2aWdhdGlvbi5cbiAgICAgICAgICogQmVjYXVzZSB0aGUgY29tcG9uZW50IGdldCBkZXN0cm95ZWQsIGFsbCBjaGlsZHJlbiBvdXRsZXQgYXJlIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIENoaWxkcmVuT3V0bGV0Q29udGV4dHMucHJvdG90eXBlLm9uT3V0bGV0RGVhY3RpdmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0cztcbiAgICAgICAgfTtcbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUub25PdXRsZXRSZUF0dGFjaGVkID0gZnVuY3Rpb24gKGNvbnRleHRzKSB7IHRoaXMuY29udGV4dHMgPSBjb250ZXh0czsgfTtcbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUuZ2V0T3JDcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgT3V0bGV0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc2V0KGNoaWxkTmFtZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cy5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHsgcmV0dXJuIHRoaXMuY29udGV4dHMuZ2V0KGNoaWxkTmFtZSkgfHwgbnVsbDsgfTtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuT3V0bGV0Q29udGV4dHM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgYSBwbGFjZWhvbGRlciB0aGF0IEFuZ3VsYXIgZHluYW1pY2FsbHkgZmlsbHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxuICAgICAqIDxyb3V0ZXItb3V0bGV0IG5hbWU9J2xlZnQnPjwvcm91dGVyLW91dGxldD5cbiAgICAgKiA8cm91dGVyLW91dGxldCBuYW1lPSdyaWdodCc+PC9yb3V0ZXItb3V0bGV0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQSByb3V0ZXIgb3V0bGV0IHdpbGwgZW1pdCBhbiBhY3RpdmF0ZSBldmVudCBhbnkgdGltZSBhIG5ldyBjb21wb25lbnQgaXMgYmVpbmcgaW5zdGFudGlhdGVkLFxuICAgICAqIGFuZCBhIGRlYWN0aXZhdGUgZXZlbnQgd2hlbiBpdCBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8cm91dGVyLW91dGxldFxuICAgICAqICAgKGFjdGl2YXRlKT0nb25BY3RpdmF0ZSgkZXZlbnQpJ1xuICAgICAqICAgKGRlYWN0aXZhdGUpPSdvbkRlYWN0aXZhdGUoJGV2ZW50KSc+PC9yb3V0ZXItb3V0bGV0PlxuICAgICAqIGBgYFxuICAgICAqIEBuZ01vZHVsZSBSb3V0ZXJNb2R1bGVcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyT3V0bGV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSb3V0ZXJPdXRsZXQocGFyZW50Q29udGV4dHMsIGxvY2F0aW9uLCByZXNvbHZlciwgbmFtZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Q29udGV4dHMgPSBwYXJlbnRDb250ZXh0cztcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlZFJvdXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVFdmVudHMgPSBuZXcgY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUV2ZW50cyA9IG5ldyBjb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCBQUklNQVJZX09VVExFVDtcbiAgICAgICAgICAgIHBhcmVudENvbnRleHRzLm9uQ2hpbGRPdXRsZXRDcmVhdGVkKHRoaXMubmFtZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyT3V0bGV0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wYXJlbnRDb250ZXh0cy5vbkNoaWxkT3V0bGV0RGVzdHJveWVkKHRoaXMubmFtZSk7IH07XG4gICAgICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG91dGxldCB3YXMgbm90IGluc3RhbnRpYXRlZCBhdCB0aGUgdGltZSB0aGUgcm91dGUgZ290IGFjdGl2YXRlZCB3ZSBuZWVkIHRvIHBvcHVsYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhlIG91dGxldCB3aGVuIGl0IGlzIGluaXRpYWxpemVkIChpZSBpbnNpZGUgYSBOZ0lmKVxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5wYXJlbnRDb250ZXh0cy5nZXRDb250ZXh0KHRoaXMubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5yb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5hdHRhY2hSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBhdHRhY2hSZWZgIGlzIHBvcHVsYXRlZCB3aGVuIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGNvbXBvbmVudCB0byBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2goY29udGV4dC5hdHRhY2hSZWYsIGNvbnRleHQucm91dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBjb21wb25lbnQgZGVmaW5lZCBpbiB0aGUgY29uZmlndXJhdGlvbiBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlV2l0aChjb250ZXh0LnJvdXRlLCBjb250ZXh0LnJlc29sdmVyIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJpc0FjdGl2YXRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5hY3RpdmF0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRsZXQgaXMgbm90IGFjdGl2YXRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZC5pbnN0YW5jZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUm91dGVyT3V0bGV0LnByb3RvdHlwZSwgXCJhY3RpdmF0ZWRSb3V0ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2YXRlZFJvdXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlZFJvdXRlRGF0YVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZhdGVkUm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2YXRlZFJvdXRlLnNuYXBzaG90LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIGBSb3V0ZVJldXNlU3RyYXRlZ3lgIGluc3RydWN0cyB0byBkZXRhY2ggdGhlIHN1YnRyZWVcbiAgICAgICAgICovXG4gICAgICAgIFJvdXRlck91dGxldC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGxldCBpcyBub3QgYWN0aXZhdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uLmRldGFjaCgpO1xuICAgICAgICAgICAgdmFyIGNtcCA9IHRoaXMuYWN0aXZhdGVkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBgUm91dGVSZXVzZVN0cmF0ZWd5YCBpbnN0cnVjdHMgdG8gcmUtYXR0YWNoIGEgcHJldmlvdXNseSBkZXRhY2hlZCBzdWJ0cmVlXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChyZWYsIGFjdGl2YXRlZFJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IHJlZjtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlZFJvdXRlID0gYWN0aXZhdGVkUm91dGU7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uLmluc2VydChyZWYuaG9zdFZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkUm91dGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZUV2ZW50cy5lbWl0KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLmFjdGl2YXRlV2l0aCA9IGZ1bmN0aW9uIChhY3RpdmF0ZWRSb3V0ZSwgcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWN0aXZhdGUgYW4gYWxyZWFkeSBhY3RpdmF0ZWQgb3V0bGV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gYWN0aXZhdGVkUm91dGUuX2Z1dHVyZVNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHNuYXBzaG90LnJvdXRlQ29uZmlnLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHJlc29sdmVyID0gcmVzb2x2ZXIgfHwgdGhpcy5yZXNvbHZlcjtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHZhciBjaGlsZENvbnRleHRzID0gdGhpcy5wYXJlbnRDb250ZXh0cy5nZXRPckNyZWF0ZUNvbnRleHQodGhpcy5uYW1lKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBpbmplY3RvciA9IG5ldyBPdXRsZXRJbmplY3RvcihhY3RpdmF0ZWRSb3V0ZSwgY2hpbGRDb250ZXh0cywgdGhpcy5sb2NhdGlvbi5pbmplY3Rvcik7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlZCA9IHRoaXMubG9jYXRpb24uY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHRoaXMubG9jYXRpb24ubGVuZ3RoLCBpbmplY3Rvcik7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIGBtYXJrRm9yQ2hlY2tgIHRvIG1ha2Ugc3VyZSB3ZSB3aWxsIHJ1biB0aGUgY2hhbmdlIGRldGVjdGlvbiB3aGVuIHRoZVxuICAgICAgICAgICAgLy8gYFJvdXRlck91dGxldGAgaXMgaW5zaWRlIGEgYENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaGAgY29tcG9uZW50LlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVFdmVudHMuZW1pdCh0aGlzLmFjdGl2YXRlZC5pbnN0YW5jZSk7XG4gICAgICAgIH07XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5PdXRwdXQoJ2FjdGl2YXRlJyksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuICAgICAgICBdLCBSb3V0ZXJPdXRsZXQucHJvdG90eXBlLCBcImFjdGl2YXRlRXZlbnRzXCIsIHZvaWQgMCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5PdXRwdXQoJ2RlYWN0aXZhdGUnKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG4gICAgICAgIF0sIFJvdXRlck91dGxldC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZUV2ZW50c1wiLCB2b2lkIDApO1xuICAgICAgICBSb3V0ZXJPdXRsZXQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIGNvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdyb3V0ZXItb3V0bGV0JywgZXhwb3J0QXM6ICdvdXRsZXQnIH0pLFxuICAgICAgICAgICAgX19wYXJhbSgzLCBjb3JlLkF0dHJpYnV0ZSgnbmFtZScpKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgY29yZS5WaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIGNvcmUuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBTdHJpbmcsIGNvcmUuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgICAgICBdLCBSb3V0ZXJPdXRsZXQpO1xuICAgICAgICByZXR1cm4gUm91dGVyT3V0bGV0O1xuICAgIH0oKSk7XG4gICAgdmFyIE91dGxldEluamVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPdXRsZXRJbmplY3Rvcihyb3V0ZSwgY2hpbGRDb250ZXh0cywgcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICB0aGlzLmNoaWxkQ29udGV4dHMgPSBjaGlsZENvbnRleHRzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgT3V0bGV0SW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBBY3RpdmF0ZWRSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID09PSBDaGlsZHJlbk91dGxldENvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDb250ZXh0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT3V0bGV0SW5qZWN0b3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICpAbGljZW5zZVxuICAgICpDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAqXG4gICAgKlVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgKmZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYSBwcmVsb2FkaW5nIHN0cmF0ZWd5LlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBQcmVsb2FkaW5nU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByZWxvYWRpbmdTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJlbG9hZGluZ1N0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBQcm92aWRlcyBhIHByZWxvYWRpbmcgc3RyYXRlZ3kgdGhhdCBwcmVsb2FkcyBhbGwgbW9kdWxlcyBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogUm91dGVNb2R1bGUuZm9yUm9vdChST1VURVMsIHtwcmVsb2FkaW5nU3RyYXRlZ3k6IFByZWxvYWRBbGxNb2R1bGVzfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUHJlbG9hZEFsbE1vZHVsZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByZWxvYWRBbGxNb2R1bGVzKCkge1xuICAgICAgICB9XG4gICAgICAgIFByZWxvYWRBbGxNb2R1bGVzLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKHJvdXRlLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuKCkucGlwZShvcGVyYXRvcnMuY2F0Y2hFcnJvcihmdW5jdGlvbiAoKSB7IHJldHVybiByeGpzLm9mKG51bGwpOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcmVsb2FkQWxsTW9kdWxlcztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYSBwcmVsb2FkaW5nIHN0cmF0ZWd5IHRoYXQgZG9lcyBub3QgcHJlbG9hZCBhbnkgbW9kdWxlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RyYXRlZ3kgaXMgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBOb1ByZWxvYWRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vUHJlbG9hZGluZygpIHtcbiAgICAgICAgfVxuICAgICAgICBOb1ByZWxvYWRpbmcucHJvdG90eXBlLnByZWxvYWQgPSBmdW5jdGlvbiAocm91dGUsIGZuKSB7IHJldHVybiByeGpzLm9mKG51bGwpOyB9O1xuICAgICAgICByZXR1cm4gTm9QcmVsb2FkaW5nO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIHByZWxvYWRlciBvcHRpbWlzdGljYWxseSBsb2FkcyBhbGwgcm91dGVyIGNvbmZpZ3VyYXRpb25zIHRvXG4gICAgICogbWFrZSBuYXZpZ2F0aW9ucyBpbnRvIGxhemlseS1sb2FkZWQgc2VjdGlvbnMgb2YgdGhlIGFwcGxpY2F0aW9uIGZhc3Rlci5cbiAgICAgKlxuICAgICAqIFRoZSBwcmVsb2FkZXIgcnVucyBpbiB0aGUgYmFja2dyb3VuZC4gV2hlbiB0aGUgcm91dGVyIGJvb3RzdHJhcHMsIHRoZSBwcmVsb2FkZXJcbiAgICAgKiBzdGFydHMgbGlzdGVuaW5nIHRvIGFsbCBuYXZpZ2F0aW9uIGV2ZW50cy4gQWZ0ZXIgZXZlcnkgc3VjaCBldmVudCwgdGhlIHByZWxvYWRlclxuICAgICAqIHdpbGwgY2hlY2sgaWYgYW55IGNvbmZpZ3VyYXRpb25zIGNhbiBiZSBsb2FkZWQgbGF6aWx5LlxuICAgICAqXG4gICAgICogSWYgYSByb3V0ZSBpcyBwcm90ZWN0ZWQgYnkgYGNhbkxvYWRgIGd1YXJkcywgdGhlIHByZWxvYWRlZCB3aWxsIG5vdCBsb2FkIGl0LlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJQcmVsb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvdXRlclByZWxvYWRlcihyb3V0ZXIsIG1vZHVsZUxvYWRlciwgY29tcGlsZXIsIGluamVjdG9yLCBwcmVsb2FkaW5nU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkaW5nU3RyYXRlZ3kgPSBwcmVsb2FkaW5nU3RyYXRlZ3k7XG4gICAgICAgICAgICB2YXIgb25TdGFydExvYWQgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcm91dGVyLnRyaWdnZXJFdmVudChuZXcgUm91dGVDb25maWdMb2FkU3RhcnQocikpOyB9O1xuICAgICAgICAgICAgdmFyIG9uRW5kTG9hZCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByb3V0ZXIudHJpZ2dlckV2ZW50KG5ldyBSb3V0ZUNvbmZpZ0xvYWRFbmQocikpOyB9O1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUm91dGVyQ29uZmlnTG9hZGVyKG1vZHVsZUxvYWRlciwgY29tcGlsZXIsIG9uU3RhcnRMb2FkLCBvbkVuZExvYWQpO1xuICAgICAgICB9XG4gICAgICAgIFJvdXRlclByZWxvYWRlci5wcm90b3R5cGUuc2V0VXBQcmVsb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUob3BlcmF0b3JzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZSBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQ7IH0pLCBvcGVyYXRvcnMuY29uY2F0TWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByZWxvYWQoKTsgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5pbmplY3Rvci5nZXQoY29yZS5OZ01vZHVsZVJlZik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUm91dGVzKG5nTW9kdWxlLCB0aGlzLnJvdXRlci5jb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPKGphc29uYWRlbik6IFRoaXMgY2xhc3MgcmVsaWVzIG9uIGNvZGUgZXh0ZXJuYWwgdG8gdGhlIGNsYXNzIHRvIGNhbGwgc2V0VXBQcmVsb2FkaW5nLiBJZlxuICAgICAgICAvLyB0aGlzIGhhc24ndCBiZWVuIGRvbmUsIG5nT25EZXN0cm95IHdpbGwgZmFpbCBhcyB0aGlzLnN1YnNjcmlwdGlvbiB3aWxsIGJlIHVuZGVmaW5lZC4gVGhpc1xuICAgICAgICAvLyBzaG91bGQgYmUgcmVmYWN0b3JlZC5cbiAgICAgICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5wcm9jZXNzUm91dGVzID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZXMpIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3V0ZXNfMSA9IF9fdmFsdWVzKHJvdXRlcyksIHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCk7ICFyb3V0ZXNfMV8xLmRvbmU7IHJvdXRlc18xXzEgPSByb3V0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBoYXZlIHRoZSBjb25maWcgbG9hZGVkLCBqdXN0IHJlY3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlLmxvYWRDaGlsZHJlbiAmJiAhcm91dGUuY2FuTG9hZCAmJiByb3V0ZS5fbG9hZGVkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb25maWcgPSByb3V0ZS5fbG9hZGVkQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5wcm9jZXNzUm91dGVzKGNoaWxkQ29uZmlnLm1vZHVsZSwgY2hpbGRDb25maWcucm91dGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBjb25maWcgbG9hZGVkLCBmZXRjaCB0aGUgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocm91dGUubG9hZENoaWxkcmVuICYmICFyb3V0ZS5jYW5Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnByZWxvYWRDb25maWcobmdNb2R1bGUsIHJvdXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNlIGludG8gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5wcm9jZXNzUm91dGVzKG5nTW9kdWxlLCByb3V0ZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZXNfMV8xICYmICFyb3V0ZXNfMV8xLmRvbmUgJiYgKF9hID0gcm91dGVzXzEucmV0dXJuKSkgX2EuY2FsbChyb3V0ZXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByeGpzLmZyb20ocmVzKS5waXBlKG9wZXJhdG9ycy5tZXJnZUFsbCgpLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChfKSB7IHJldHVybiB2b2lkIDA7IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyUHJlbG9hZGVyLnByb3RvdHlwZS5wcmVsb2FkQ29uZmlnID0gZnVuY3Rpb24gKG5nTW9kdWxlLCByb3V0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWxvYWRpbmdTdHJhdGVneS5wcmVsb2FkKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZCQgPSBfdGhpcy5sb2FkZXIubG9hZChuZ01vZHVsZS5pbmplY3Rvciwgcm91dGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZWQkLnBpcGUob3BlcmF0b3JzLm1lcmdlTWFwKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUuX2xvYWRlZENvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb2Nlc3NSb3V0ZXMoY29uZmlnLm1vZHVsZSwgY29uZmlnLnJvdXRlcyk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclByZWxvYWRlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JvdXRlciwgY29yZS5OZ01vZHVsZUZhY3RvcnlMb2FkZXIsIGNvcmUuQ29tcGlsZXIsXG4gICAgICAgICAgICAgICAgY29yZS5JbmplY3RvciwgUHJlbG9hZGluZ1N0cmF0ZWd5XSlcbiAgICAgICAgXSwgUm91dGVyUHJlbG9hZGVyKTtcbiAgICAgICAgcmV0dXJuIFJvdXRlclByZWxvYWRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVyU2Nyb2xsZXIocm91dGVyLCBcbiAgICAgICAgLyoqIEBkb2NzTm90UmVxdWlyZWQgKi8gdmlld3BvcnRTY3JvbGxlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydFNjcm9sbGVyID0gdmlld3BvcnRTY3JvbGxlcjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmxhc3RJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmxhc3RTb3VyY2UgPSAnaW1wZXJhdGl2ZSc7XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVkSWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBib3RoIG9wdGlvbnMgdG8gJ2Rpc2FibGVkJ1xuICAgICAgICAgICAgb3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uID0gb3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uIHx8ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICBvcHRpb25zLmFuY2hvclNjcm9sbGluZyA9IG9wdGlvbnMuYW5jaG9yU2Nyb2xsaW5nIHx8ICdkaXNhYmxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgUm91dGVyU2Nyb2xsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGRpc2FibGUgdGhlIGF1dG9tYXRpYyBzY3JvbGxpbmcgYmVjYXVzZSBoYXZpbmcgdHdvIHBsYWNlc1xuICAgICAgICAgICAgLy8gcmVzcG9uc2libGUgZm9yIHNjcm9sbGluZyByZXN1bHRzIHJhY2UgY29uZGl0aW9ucywgZXNwZWNpYWxseSBnaXZlblxuICAgICAgICAgICAgLy8gdGhhdCBicm93c2VyIGRvbid0IGltcGxlbWVudCB0aGlzIGJlaGF2aW9yIGNvbnNpc3RlbnRseVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNldEhpc3RvcnlTY3JvbGxSZXN0b3JhdGlvbignbWFudWFsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvdXRlckV2ZW50c1N1YnNjcmlwdGlvbiA9IHRoaXMuY3JlYXRlU2Nyb2xsRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEV2ZW50c1N1YnNjcmlwdGlvbiA9IHRoaXMuY29uc3VtZVNjcm9sbEV2ZW50cygpO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUuY3JlYXRlU2Nyb2xsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5ldmVudHMuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBzdGFibGUgbmF2aWdhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0b3JlW190aGlzLmxhc3RJZF0gPSBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTb3VyY2UgPSBlLm5hdmlnYXRpb25UcmlnZ2VyO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN0b3JlZElkID0gZS5yZXN0b3JlZFN0YXRlID8gZS5yZXN0b3JlZFN0YXRlLm5hdmlnYXRpb25JZCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RJZCA9IGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlU2Nyb2xsRXZlbnQoZSwgX3RoaXMucm91dGVyLnBhcnNlVXJsKGUudXJsQWZ0ZXJSZWRpcmVjdHMpLmZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyU2Nyb2xsZXIucHJvdG90eXBlLmNvbnN1bWVTY3JvbGxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmV2ZW50cy5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgU2Nyb2xsKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGEgcG9wc3RhdGUgZXZlbnQuIFRoZSBwb3Agc3RhdGUgZXZlbnQgd2lsbCBhbHdheXMgaWdub3JlIGFuY2hvciBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgaWYgKGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2Nyb2xsUG9zaXRpb25SZXN0b3JhdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdwb3J0U2Nyb2xsZXIuc2Nyb2xsVG9Qb3NpdGlvbihbMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm9wdGlvbnMuc2Nyb2xsUG9zaXRpb25SZXN0b3JhdGlvbiA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oZS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW1wZXJhdGl2ZSBuYXZpZ2F0aW9uIFwiZm9yd2FyZFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5hbmNob3IgJiYgX3RoaXMub3B0aW9ucy5hbmNob3JTY3JvbGxpbmcgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3BvcnRTY3JvbGxlci5zY3JvbGxUb0FuY2hvcihlLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMub3B0aW9ucy5zY3JvbGxQb3NpdGlvblJlc3RvcmF0aW9uICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3cG9ydFNjcm9sbGVyLnNjcm9sbFRvUG9zaXRpb24oWzAsIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJTY3JvbGxlci5wcm90b3R5cGUuc2NoZWR1bGVTY3JvbGxFdmVudCA9IGZ1bmN0aW9uIChyb3V0ZXJFdmVudCwgYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlci50cmlnZ2VyRXZlbnQobmV3IFNjcm9sbChyb3V0ZXJFdmVudCwgdGhpcy5sYXN0U291cmNlID09PSAncG9wc3RhdGUnID8gdGhpcy5zdG9yZVt0aGlzLnJlc3RvcmVkSWRdIDogbnVsbCwgYW5jaG9yKSk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlclNjcm9sbGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlckV2ZW50c1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyRXZlbnRzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxFdmVudHNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEV2ZW50c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUm91dGVyU2Nyb2xsZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENvbnRhaW5zIGEgbGlzdCBvZiBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHZhciBST1VURVJfRElSRUNUSVZFUyA9IFtSb3V0ZXJPdXRsZXQsIFJvdXRlckxpbmssIFJvdXRlckxpbmtXaXRoSHJlZiwgUm91dGVyTGlua0FjdGl2ZSwgybVFbXB0eU91dGxldENvbXBvbmVudF07XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJcyB1c2VkIGluIERJIHRvIGNvbmZpZ3VyZSB0aGUgcm91dGVyLlxuICAgICAqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBST1VURVJfQ09ORklHVVJBVElPTiA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdST1VURVJfQ09ORklHVVJBVElPTicpO1xuICAgIC8qKlxuICAgICAqIEBkb2NzTm90UmVxdWlyZWRcbiAgICAgKi9cbiAgICB2YXIgUk9VVEVSX0ZPUlJPT1RfR1VBUkQgPSBuZXcgY29yZS5JbmplY3Rpb25Ub2tlbignUk9VVEVSX0ZPUlJPT1RfR1VBUkQnKTtcbiAgICB2YXIgybUwID0geyBlbmFibGVUcmFjaW5nOiBmYWxzZSB9O1xuICAgIHZhciBST1VURVJfUFJPVklERVJTID0gW1xuICAgICAgICBjb21tb24uTG9jYXRpb24sXG4gICAgICAgIHsgcHJvdmlkZTogVXJsU2VyaWFsaXplciwgdXNlQ2xhc3M6IERlZmF1bHRVcmxTZXJpYWxpemVyIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFJvdXRlcixcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHNldHVwUm91dGVyLFxuICAgICAgICAgICAgZGVwczogW1xuICAgICAgICAgICAgICAgIGNvcmUuQXBwbGljYXRpb25SZWYsIFVybFNlcmlhbGl6ZXIsIENoaWxkcmVuT3V0bGV0Q29udGV4dHMsIGNvbW1vbi5Mb2NhdGlvbiwgY29yZS5JbmplY3RvcixcbiAgICAgICAgICAgICAgICBjb3JlLk5nTW9kdWxlRmFjdG9yeUxvYWRlciwgY29yZS5Db21waWxlciwgUk9VVEVTLCBST1VURVJfQ09ORklHVVJBVElPTixcbiAgICAgICAgICAgICAgICBbVXJsSGFuZGxpbmdTdHJhdGVneSwgbmV3IGNvcmUuT3B0aW9uYWwoKV0sIFtSb3V0ZVJldXNlU3RyYXRlZ3ksIG5ldyBjb3JlLk9wdGlvbmFsKCldXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIENoaWxkcmVuT3V0bGV0Q29udGV4dHMsXG4gICAgICAgIHsgcHJvdmlkZTogQWN0aXZhdGVkUm91dGUsIHVzZUZhY3Rvcnk6IHJvb3RSb3V0ZSwgZGVwczogW1JvdXRlcl0gfSxcbiAgICAgICAgeyBwcm92aWRlOiBjb3JlLk5nTW9kdWxlRmFjdG9yeUxvYWRlciwgdXNlQ2xhc3M6IGNvcmUuU3lzdGVtSnNOZ01vZHVsZUxvYWRlciB9LFxuICAgICAgICBSb3V0ZXJQcmVsb2FkZXIsXG4gICAgICAgIE5vUHJlbG9hZGluZyxcbiAgICAgICAgUHJlbG9hZEFsbE1vZHVsZXMsXG4gICAgICAgIHsgcHJvdmlkZTogUk9VVEVSX0NPTkZJR1VSQVRJT04sIHVzZVZhbHVlOiDJtTAgfSxcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHJvdXRlck5nUHJvYmVUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlLk5nUHJvYmVUb2tlbignUm91dGVyJywgUm91dGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqIFJvdXRlck1vZHVsZSBjYW4gYmUgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXM6IG9uY2UgcGVyIGxhemlseS1sb2FkZWQgYnVuZGxlLlxuICAgICAqIFNpbmNlIHRoZSByb3V0ZXIgZGVhbHMgd2l0aCBhIGdsb2JhbCBzaGFyZWQgcmVzb3VyY2UtLWxvY2F0aW9uLCB3ZSBjYW5ub3QgaGF2ZVxuICAgICAqIG1vcmUgdGhhbiBvbmUgcm91dGVyIHNlcnZpY2UgYWN0aXZlLlxuICAgICAqXG4gICAgICogVGhhdCBpcyB3aHkgdGhlcmUgYXJlIHR3byB3YXlzIHRvIGNyZWF0ZSB0aGUgbW9kdWxlOiBgUm91dGVyTW9kdWxlLmZvclJvb3RgIGFuZFxuICAgICAqIGBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGRgLlxuICAgICAqXG4gICAgICogKiBgZm9yUm9vdGAgY3JlYXRlcyBhIG1vZHVsZSB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgZGlyZWN0aXZlcywgdGhlIGdpdmVuIHJvdXRlcywgYW5kIHRoZSByb3V0ZXJcbiAgICAgKiAgIHNlcnZpY2UgaXRzZWxmLlxuICAgICAqICogYGZvckNoaWxkYCBjcmVhdGVzIGEgbW9kdWxlIHRoYXQgY29udGFpbnMgYWxsIHRoZSBkaXJlY3RpdmVzIGFuZCB0aGUgZ2l2ZW4gcm91dGVzLCBidXQgZG9lcyBub3RcbiAgICAgKiAgIGluY2x1ZGUgdGhlIHJvdXRlciBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogV2hlbiByZWdpc3RlcmVkIGF0IHRoZSByb290LCB0aGUgbW9kdWxlIHNob3VsZCBiZSB1c2VkIGFzIGZvbGxvd3NcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbUm91dGVyTW9kdWxlLmZvclJvb3QoUk9VVEVTKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TmdNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEZvciBzdWJtb2R1bGVzIGFuZCBsYXp5IGxvYWRlZCBzdWJtb2R1bGVzIHRoZSBtb2R1bGUgc2hvdWxkIGJlIHVzZWQgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbUm91dGVyTW9kdWxlLmZvckNoaWxkKFJPVVRFUyldXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeU5nTW9kdWxlIHt9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFkZHMgcm91dGVyIGRpcmVjdGl2ZXMgYW5kIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIE1hbmFnaW5nIHN0YXRlIHRyYW5zaXRpb25zIGlzIG9uZSBvZiB0aGUgaGFyZGVzdCBwYXJ0cyBvZiBidWlsZGluZyBhcHBsaWNhdGlvbnMuIFRoaXMgaXNcbiAgICAgKiBlc3BlY2lhbGx5IHRydWUgb24gdGhlIHdlYiwgd2hlcmUgeW91IGFsc28gbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgc3RhdGUgaXMgcmVmbGVjdGVkIGluIHRoZSBVUkwuXG4gICAgICogSW4gYWRkaXRpb24sIHdlIG9mdGVuIHdhbnQgdG8gc3BsaXQgYXBwbGljYXRpb25zIGludG8gbXVsdGlwbGUgYnVuZGxlcyBhbmQgbG9hZCB0aGVtIG9uIGRlbWFuZC5cbiAgICAgKiBEb2luZyB0aGlzIHRyYW5zcGFyZW50bHkgaXMgbm90IHRyaXZpYWwuXG4gICAgICpcbiAgICAgKiBUaGUgQW5ndWxhciByb3V0ZXIgc29sdmVzIHRoZXNlIHByb2JsZW1zLiBVc2luZyB0aGUgcm91dGVyLCB5b3UgY2FuIGRlY2xhcmF0aXZlbHkgc3BlY2lmeVxuICAgICAqIGFwcGxpY2F0aW9uIHN0YXRlcywgbWFuYWdlIHN0YXRlIHRyYW5zaXRpb25zIHdoaWxlIHRha2luZyBjYXJlIG9mIHRoZSBVUkwsIGFuZCBsb2FkIGJ1bmRsZXMgb25cbiAgICAgKiBkZW1hbmQuXG4gICAgICpcbiAgICAgKiBbUmVhZCB0aGlzIGRldmVsb3BlciBndWlkZV0oaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2d1aWRlL3JvdXRlci5odG1sKSB0byBnZXQgYW5cbiAgICAgKiBvdmVydmlldyBvZiBob3cgdGhlIHJvdXRlciBzaG91bGQgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICB2YXIgUm91dGVyTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgaW5qZWN0aW5nIHRoZSBSb3V0ZXIgc28gaXQgZ2V0cyBjcmVhdGVkIGVhZ2VybHkuLi5cbiAgICAgICAgZnVuY3Rpb24gUm91dGVyTW9kdWxlKGd1YXJkLCByb3V0ZXIpIHtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJNb2R1bGVfMSA9IFJvdXRlck1vZHVsZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIHJvdXRlciBwcm92aWRlcnMgYW5kIGRpcmVjdGl2ZXMuIEl0IGFsc28gb3B0aW9uYWxseSBzZXRzIHVwIGFuXG4gICAgICAgICAqIGFwcGxpY2F0aW9uIGxpc3RlbmVyIHRvIHBlcmZvcm0gYW4gaW5pdGlhbCBuYXZpZ2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIE9wdGlvbnM6XG4gICAgICAgICAqXG4gICAgICAgICAqICogYGVuYWJsZVRyYWNpbmdgIFRvZ2dsZXMgd2hldGhlciB0aGUgcm91dGVyIHNob3VsZCBsb2cgYWxsIG5hdmlnYXRpb24gZXZlbnRzIHRvIHRoZSBjb25zb2xlLlxuICAgICAgICAgKiAqIGB1c2VIYXNoYCBFbmFibGVzIHRoZSBsb2NhdGlvbiBzdHJhdGVneSB0aGF0IHVzZXMgdGhlIFVSTCBmcmFnbWVudCBpbnN0ZWFkIG9mIHRoZSBoaXN0b3J5XG4gICAgICAgICAqIEFQSS5cbiAgICAgICAgICogKiBgaW5pdGlhbE5hdmlnYXRpb25gIERpc2FibGVzIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXG4gICAgICAgICAqICogYGVycm9ySGFuZGxlcmAgRGVmaW5lcyBhIGN1c3RvbSBlcnJvciBoYW5kbGVyIGZvciBmYWlsZWQgbmF2aWdhdGlvbnMuXG4gICAgICAgICAqICogYHByZWxvYWRpbmdTdHJhdGVneWAgQ29uZmlndXJlcyBhIHByZWxvYWRpbmcgc3RyYXRlZ3kuIFNlZSBgUHJlbG9hZEFsbE1vZHVsZXNgLlxuICAgICAgICAgKiAqIGBvblNhbWVVcmxOYXZpZ2F0aW9uYCBEZWZpbmUgd2hhdCB0aGUgcm91dGVyIHNob3VsZCBkbyBpZiBpdCByZWNlaXZlcyBhIG5hdmlnYXRpb24gcmVxdWVzdCB0b1xuICAgICAgICAgKiB0aGUgY3VycmVudCBVUkwuXG4gICAgICAgICAqICogYHNjcm9sbFBvc2l0aW9uUmVzdG9yYXRpb25gIENvbmZpZ3VyZXMgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBuZWVkcyB0byBiZSByZXN0b3JlZCB3aGVuXG4gICAgICAgICAqIG5hdmlnYXRpbmcgYmFjay5cbiAgICAgICAgICogKiBgYW5jaG9yU2Nyb2xsaW5nYCBDb25maWd1cmVzIGlmIHRoZSByb3V0ZXIgc2hvdWxkIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aGVuIHRoZSB1cmwgaGFzIGFcbiAgICAgICAgICogZnJhZ21lbnQuXG4gICAgICAgICAqICogYHNjcm9sbE9mZnNldGAgQ29uZmlndXJlcyB0aGUgc2Nyb2xsIG9mZnNldCB0aGUgcm91dGVyIHdpbGwgdXNlIHdoZW4gc2Nyb2xsaW5nIHRvIGFuIGVsZW1lbnQuXG4gICAgICAgICAqICogYHBhcmFtc0luaGVyaXRhbmNlU3RyYXRlZ3lgIERlZmluZXMgaG93IHRoZSByb3V0ZXIgbWVyZ2VzIHBhcmFtcywgZGF0YSBhbmQgcmVzb2x2ZWQgZGF0YSBmcm9tXG4gICAgICAgICAqIHBhcmVudCB0byBjaGlsZCByb3V0ZXMuXG4gICAgICAgICAqICogYG1hbGZvcm1lZFVyaUVycm9ySGFuZGxlcmAgRGVmaW5lcyBhIGN1c3RvbSBtYWxmb3JtZWQgdXJpIGVycm9yIGhhbmRsZXIgZnVuY3Rpb24uIFRoaXNcbiAgICAgICAgICogaGFuZGxlciBpcyBpbnZva2VkIHdoZW4gZW5jb2RlZFVSSSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlciBzZXF1ZW5jZXMuXG4gICAgICAgICAqICogYHVybFVwZGF0ZVN0cmF0ZWd5YCBEZWZpbmVzIHdoZW4gdGhlIHJvdXRlciB1cGRhdGVzIHRoZSBicm93c2VyIFVSTC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXNcbiAgICAgICAgICogdG8gdXBkYXRlIGFmdGVyIHN1Y2Nlc3NmdWwgbmF2aWdhdGlvbi5cbiAgICAgICAgICogKiBgcmVsYXRpdmVMaW5rUmVzb2x1dGlvbmAgRW5hYmxlcyB0aGUgY29ycmVjdCByZWxhdGl2ZSBsaW5rIHJlc29sdXRpb24gaW4gY29tcG9uZW50cyB3aXRoXG4gICAgICAgICAqIGVtcHR5IHBhdGhzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgYEV4dHJhT3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgYWJvdmUgb3B0aW9ucy5cbiAgICAgICAgKi9cbiAgICAgICAgUm91dGVyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAocm91dGVzLCBjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGU6IFJvdXRlck1vZHVsZV8xLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBST1VURVJfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlUm91dGVzKHJvdXRlcyksXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFJPVVRFUl9GT1JST09UX0dVQVJELFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZUZvclJvb3RHdWFyZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtbUm91dGVyLCBuZXcgY29yZS5PcHRpb25hbCgpLCBuZXcgY29yZS5Ta2lwU2VsZigpXV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBST1VURVJfQ09ORklHVVJBVElPTiwgdXNlVmFsdWU6IGNvbmZpZyA/IGNvbmZpZyA6IHt9IH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IGNvbW1vbi5Mb2NhdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZUxvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLlBsYXRmb3JtTG9jYXRpb24sIFtuZXcgY29yZS5JbmplY3QoY29tbW9uLkFQUF9CQVNFX0hSRUYpLCBuZXcgY29yZS5PcHRpb25hbCgpXSwgUk9VVEVSX0NPTkZJR1VSQVRJT05cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUm91dGVyU2Nyb2xsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBjcmVhdGVSb3V0ZXJTY3JvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtSb3V0ZXIsIGNvbW1vbi5WaWV3cG9ydFNjcm9sbGVyLCBST1VURVJfQ09ORklHVVJBVElPTl1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUHJlbG9hZGluZ1N0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGNvbmZpZyAmJiBjb25maWcucHJlbG9hZGluZ1N0cmF0ZWd5ID8gY29uZmlnLnByZWxvYWRpbmdTdHJhdGVneSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTm9QcmVsb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogY29yZS5OZ1Byb2JlVG9rZW4sIG11bHRpOiB0cnVlLCB1c2VGYWN0b3J5OiByb3V0ZXJOZ1Byb2JlVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZVJvdXRlckluaXRpYWxpemVyKCksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbW9kdWxlIHdpdGggYWxsIHRoZSByb3V0ZXIgZGlyZWN0aXZlcyBhbmQgYSBwcm92aWRlciByZWdpc3RlcmluZyByb3V0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQgPSBmdW5jdGlvbiAocm91dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuZ01vZHVsZTogUm91dGVyTW9kdWxlXzEsIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMocm91dGVzKV0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFJvdXRlck1vZHVsZV8xO1xuICAgICAgICBSb3V0ZXJNb2R1bGUgPSBSb3V0ZXJNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBST1VURVJfRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBST1VURVJfRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFvJtUVtcHR5T3V0bGV0Q29tcG9uZW50XVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBfX3BhcmFtKDAsIGNvcmUuT3B0aW9uYWwoKSksIF9fcGFyYW0oMCwgY29yZS5JbmplY3QoUk9VVEVSX0ZPUlJPT1RfR1VBUkQpKSwgX19wYXJhbSgxLCBjb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIFJvdXRlcl0pXG4gICAgICAgIF0sIFJvdXRlck1vZHVsZSk7XG4gICAgICAgIHJldHVybiBSb3V0ZXJNb2R1bGU7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIHZpZXdwb3J0U2Nyb2xsZXIsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLnNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgdmlld3BvcnRTY3JvbGxlci5zZXRPZmZzZXQoY29uZmlnLnNjcm9sbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZXJTY3JvbGxlcihyb3V0ZXIsIHZpZXdwb3J0U2Nyb2xsZXIsIGNvbmZpZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3ZpZGVMb2NhdGlvblN0cmF0ZWd5KHBsYXRmb3JtTG9jYXRpb25TdHJhdGVneSwgYmFzZUhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMudXNlSGFzaCA/IG5ldyBjb21tb24uSGFzaExvY2F0aW9uU3RyYXRlZ3kocGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5LCBiYXNlSHJlZikgOlxuICAgICAgICAgICAgbmV3IGNvbW1vbi5QYXRoTG9jYXRpb25TdHJhdGVneShwbGF0Zm9ybUxvY2F0aW9uU3RyYXRlZ3ksIGJhc2VIcmVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvdmlkZUZvclJvb3RHdWFyZChyb3V0ZXIpIHtcbiAgICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm91dGVyTW9kdWxlLmZvclJvb3QoKSBjYWxsZWQgdHdpY2UuIExhenkgbG9hZGVkIG1vZHVsZXMgc2hvdWxkIHVzZSBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2d1YXJkZWQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyByb3V0ZXMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1JvdXRlck1vZHVsZS5mb3JDaGlsZChST1VURVMpXSxcbiAgICAgKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMoRVhUUkFfUk9VVEVTKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15TmdNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNBcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm92aWRlUm91dGVzKHJvdXRlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBjb3JlLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIG11bHRpOiB0cnVlLCB1c2VWYWx1ZTogcm91dGVzIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IFJPVVRFUywgbXVsdGk6IHRydWUsIHVzZVZhbHVlOiByb3V0ZXMgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dXBSb3V0ZXIocmVmLCB1cmxTZXJpYWxpemVyLCBjb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBjb25maWcsIG9wdHMsIHVybEhhbmRsaW5nU3RyYXRlZ3ksIHJvdXRlUmV1c2VTdHJhdGVneSkge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgICAgICB2YXIgcm91dGVyID0gbmV3IFJvdXRlcihudWxsLCB1cmxTZXJpYWxpemVyLCBjb250ZXh0cywgbG9jYXRpb24sIGluamVjdG9yLCBsb2FkZXIsIGNvbXBpbGVyLCBmbGF0dGVuKGNvbmZpZykpO1xuICAgICAgICBpZiAodXJsSGFuZGxpbmdTdHJhdGVneSkge1xuICAgICAgICAgICAgcm91dGVyLnVybEhhbmRsaW5nU3RyYXRlZ3kgPSB1cmxIYW5kbGluZ1N0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZVJldXNlU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHJvdXRlci5yb3V0ZVJldXNlU3RyYXRlZ3kgPSByb3V0ZVJldXNlU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIuZXJyb3JIYW5kbGVyID0gb3B0cy5lcnJvckhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICByb3V0ZXIubWFsZm9ybWVkVXJpRXJyb3JIYW5kbGVyID0gb3B0cy5tYWxmb3JtZWRVcmlFcnJvckhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZW5hYmxlVHJhY2luZykge1xuICAgICAgICAgICAgdmFyIGRvbV8xID0gcGxhdGZvcm1Ccm93c2VyLsm1Z2V0RE9NKCk7XG4gICAgICAgICAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGRvbV8xLmxvZ0dyb3VwKFwiUm91dGVyIEV2ZW50OiBcIiArIGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgZG9tXzEubG9nKGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgZG9tXzEubG9nKGUpO1xuICAgICAgICAgICAgICAgIGRvbV8xLmxvZ0dyb3VwRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5vblNhbWVVcmxOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICByb3V0ZXIub25TYW1lVXJsTmF2aWdhdGlvbiA9IG9wdHMub25TYW1lVXJsTmF2aWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wYXJhbXNJbmhlcml0YW5jZVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByb3V0ZXIucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneSA9IG9wdHMucGFyYW1zSW5oZXJpdGFuY2VTdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy51cmxVcGRhdGVTdHJhdGVneSkge1xuICAgICAgICAgICAgcm91dGVyLnVybFVwZGF0ZVN0cmF0ZWd5ID0gb3B0cy51cmxVcGRhdGVTdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZWxhdGl2ZUxpbmtSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVsYXRpdmVMaW5rUmVzb2x1dGlvbiA9IG9wdHMucmVsYXRpdmVMaW5rUmVzb2x1dGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91dGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb290Um91dGUocm91dGVyKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXIucm91dGVyU3RhdGUucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gaW5pdGlhbGl6ZSB0aGUgcm91dGVyIHByb3Blcmx5IHdlIG5lZWQgdG8gZG8gaW4gdHdvIHN0ZXBzOlxuICAgICAqXG4gICAgICogV2UgbmVlZCB0byBzdGFydCB0aGUgbmF2aWdhdGlvbiBpbiBhIEFQUF9JTklUSUFMSVpFUiB0byBibG9jayB0aGUgYm9vdHN0cmFwIGlmXG4gICAgICogYSByZXNvbHZlciBvciBhIGd1YXJkcyBleGVjdXRlcyBhc3luY2hyb25vdXNseS4gU2Vjb25kLCB3ZSBuZWVkIHRvIGFjdHVhbGx5IHJ1blxuICAgICAqIGFjdGl2YXRpb24gaW4gYSBCT09UU1RSQVBfTElTVEVORVIuIFdlIHV0aWxpemUgdGhlIGFmdGVyUHJlYWN0aXZhdGlvblxuICAgICAqIGhvb2sgcHJvdmlkZWQgYnkgdGhlIHJvdXRlciB0byBkbyB0aGF0LlxuICAgICAqXG4gICAgICogVGhlIHJvdXRlciBuYXZpZ2F0aW9uIHN0YXJ0cywgcmVhY2hlcyB0aGUgcG9pbnQgd2hlbiBwcmVhY3RpdmF0aW9uIGlzIGRvbmUsIGFuZCB0aGVuXG4gICAgICogcGF1c2VzLiBJdCB3YWl0cyBmb3IgdGhlIGhvb2sgdG8gYmUgcmVzb2x2ZWQuIFdlIHRoZW4gcmVzb2x2ZSBpdCBvbmx5IGluIGEgYm9vdHN0cmFwIGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHZhciBSb3V0ZXJJbml0aWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUm91dGVySW5pdGlhbGl6ZXIoaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuaW5pdE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZSA9IG5ldyByeGpzLlN1YmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBSb3V0ZXJJbml0aWFsaXplci5wcm90b3R5cGUuYXBwSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLmluamVjdG9yLmdldChjb21tb24uTE9DQVRJT05fSU5JVElBTElaRUQsIFByb21pc2UucmVzb2x2ZShudWxsKSk7XG4gICAgICAgICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlciA9IF90aGlzLmluamVjdG9yLmdldChSb3V0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuaW5qZWN0b3IuZ2V0KFJPVVRFUl9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNMZWdhY3lEaXNhYmxlZChvcHRzKSB8fCBfdGhpcy5pc0xlZ2FjeUVuYWJsZWQob3B0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0cy5pbml0aWFsTmF2aWdhdGlvbiA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuc2V0VXBMb2NhdGlvbkNoYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuaG9va3MuYWZ0ZXJQcmVhY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uIHNob3VsZCBiZSBkZWxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmluaXROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdE5hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc3VsdE9mUHJlYWN0aXZhdGlvbkRvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBuYXZpZ2F0aW9ucyBzaG91bGQgbm90IGJlIGRlbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXIuaW5pdGlhbE5hdmlnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5pdGlhbE5hdmlnYXRpb24gb3B0aW9uczogJ1wiICsgb3B0cy5pbml0aWFsTmF2aWdhdGlvbiArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJJbml0aWFsaXplci5wcm90b3R5cGUuYm9vdHN0cmFwTGlzdGVuZXIgPSBmdW5jdGlvbiAoYm9vdHN0cmFwcGVkQ29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuaW5qZWN0b3IuZ2V0KFJPVVRFUl9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZXIgPSB0aGlzLmluamVjdG9yLmdldChSb3V0ZXJQcmVsb2FkZXIpO1xuICAgICAgICAgICAgdmFyIHJvdXRlclNjcm9sbGVyID0gdGhpcy5pbmplY3Rvci5nZXQoUm91dGVyU2Nyb2xsZXIpO1xuICAgICAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuaW5qZWN0b3IuZ2V0KFJvdXRlcik7XG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcy5pbmplY3Rvci5nZXQoY29yZS5BcHBsaWNhdGlvblJlZik7XG4gICAgICAgICAgICBpZiAoYm9vdHN0cmFwcGVkQ29tcG9uZW50UmVmICE9PSByZWYuY29tcG9uZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGVnYWN5RW5hYmxlZChvcHRzKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlci5pbml0aWFsTmF2aWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0xlZ2FjeURpc2FibGVkKG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnNldFVwTG9jYXRpb25DaGFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlbG9hZGVyLnNldFVwUHJlbG9hZGluZygpO1xuICAgICAgICAgICAgcm91dGVyU2Nyb2xsZXIuaW5pdCgpO1xuICAgICAgICAgICAgcm91dGVyLnJlc2V0Um9vdENvbXBvbmVudFR5cGUocmVmLmNvbXBvbmVudFR5cGVzWzBdKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0T2ZQcmVhY3RpdmF0aW9uRG9uZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRPZlByZWFjdGl2YXRpb25Eb25lLmNvbXBsZXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIFJvdXRlckluaXRpYWxpemVyLnByb3RvdHlwZS5pc0xlZ2FjeUVuYWJsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdsZWdhY3lfZW5hYmxlZCcgfHwgb3B0cy5pbml0aWFsTmF2aWdhdGlvbiA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVySW5pdGlhbGl6ZXIucHJvdG90eXBlLmlzTGVnYWN5RGlzYWJsZWQgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09ICdsZWdhY3lfZGlzYWJsZWQnIHx8IG9wdHMuaW5pdGlhbE5hdmlnYXRpb24gPT09IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBSb3V0ZXJJbml0aWFsaXplciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW2NvcmUuSW5qZWN0b3JdKVxuICAgICAgICBdLCBSb3V0ZXJJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybiBSb3V0ZXJJbml0aWFsaXplcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGdldEFwcEluaXRpYWxpemVyKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuYXBwSW5pdGlhbGl6ZXIuYmluZChyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Qm9vdHN0cmFwTGlzdGVuZXIocikge1xuICAgICAgICByZXR1cm4gci5ib290c3RyYXBMaXN0ZW5lci5iaW5kKHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHRva2VuIGZvciB0aGUgcm91dGVyIGluaXRpYWxpemVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFwcCBpcyBib290c3RyYXBwZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljQXBpXG4gICAgICovXG4gICAgdmFyIFJPVVRFUl9JTklUSUFMSVpFUiA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdSb3V0ZXIgSW5pdGlhbGl6ZXInKTtcbiAgICBmdW5jdGlvbiBwcm92aWRlUm91dGVySW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBSb3V0ZXJJbml0aWFsaXplcixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBjb3JlLkFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBnZXRBcHBJbml0aWFsaXplcixcbiAgICAgICAgICAgICAgICBkZXBzOiBbUm91dGVySW5pdGlhbGl6ZXJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBST1VURVJfSU5JVElBTElaRVIsIHVzZUZhY3Rvcnk6IGdldEJvb3RzdHJhcExpc3RlbmVyLCBkZXBzOiBbUm91dGVySW5pdGlhbGl6ZXJdIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IGNvcmUuQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgbXVsdGk6IHRydWUsIHVzZUV4aXN0aW5nOiBST1VURVJfSU5JVElBTElaRVIgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHB1YmxpY0FwaVxuICAgICAqL1xuICAgIHZhciBWRVJTSU9OID0gbmV3IGNvcmUuVmVyc2lvbignOC4wLjAnKTtcblxuICAgIHZhciBfX2RlY29yYXRlJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgICB9O1xuICAgIHZhciBfX21ldGFkYXRhJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG4gICAgfTtcbiAgICB2YXIgQW5ndWxhckZpcmVBdXRoR3VhcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmd1bGFyRmlyZUF1dGhHdWFyZChhZkF1dGgsIHJvdXRlcikge1xuICAgICAgICAgICAgdGhpcy5hZkF1dGggPSBhZkF1dGg7XG4gICAgICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgfVxuICAgICAgICBBbmd1bGFyRmlyZUF1dGhHdWFyZC5wcm90b3R5cGUuY2FuQWN0aXZhdGUgPSBmdW5jdGlvbiAobmV4dCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXV0aFBpcGVGYWN0b3J5ID0gbmV4dC5kYXRhLmF1dGhHdWFyZFBpcGUgfHwgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dlZEluOyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFmQXV0aC51c2VyLnBpcGUob3BlcmF0b3JzLnRha2UoMSksIGF1dGhQaXBlRmFjdG9yeShuZXh0LCBzdGF0ZSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGNhbkFjdGl2YXRlKSB7IHJldHVybiB0eXBlb2YgY2FuQWN0aXZhdGUgPT0gXCJib29sZWFuXCIgPyBjYW5BY3RpdmF0ZSA6IF90aGlzLnJvdXRlci5jcmVhdGVVcmxUcmVlKGNhbkFjdGl2YXRlKTsgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBBbmd1bGFyRmlyZUF1dGhHdWFyZCA9IF9fZGVjb3JhdGUkMShbXG4gICAgICAgICAgICBjb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgICAgIF9fbWV0YWRhdGEkMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFthdXRoLkFuZ3VsYXJGaXJlQXV0aCwgUm91dGVyXSlcbiAgICAgICAgXSwgQW5ndWxhckZpcmVBdXRoR3VhcmQpO1xuICAgICAgICByZXR1cm4gQW5ndWxhckZpcmVBdXRoR3VhcmQ7XG4gICAgfSgpKTtcbiAgICB2YXIgY2FuQWN0aXZhdGUgPSBmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gKHtcbiAgICAgICAgY2FuQWN0aXZhdGU6IFtBbmd1bGFyRmlyZUF1dGhHdWFyZF0sIGRhdGE6IHsgYXV0aEd1YXJkUGlwZTogcGlwZS5uYW1lID09PSBcIlwiID8gcGlwZSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpcGU7IH0gfVxuICAgIH0pOyB9O1xuICAgIHZhciDJtTAkMSA9IGZ1bmN0aW9uICh1c2VyKSB7IHJldHVybiAhIXVzZXI7IH07XG4gICAgdmFyIGxvZ2dlZEluID0gb3BlcmF0b3JzLm1hcCjJtTAkMSk7XG4gICAgdmFyIMm1MSA9IGZ1bmN0aW9uICh1c2VyKSB7IHJldHVybiAhIXVzZXIgJiYgIXVzZXIuaXNBbm9ueW1vdXM7IH07XG4gICAgdmFyIGlzTm90QW5vbnltb3VzID0gb3BlcmF0b3JzLm1hcCjJtTEpO1xuICAgIHZhciDJtTIgPSBmdW5jdGlvbiAodXNlcikgeyByZXR1cm4gdXNlciA/IHVzZXIuZ2V0SWRUb2tlblJlc3VsdCgpIDogcnhqcy5vZihudWxsKTsgfTtcbiAgICB2YXIgaWRUb2tlblJlc3VsdCA9IG9wZXJhdG9ycy5zd2l0Y2hNYXAoybUyKTtcbiAgICB2YXIgybUzID0gZnVuY3Rpb24gKHVzZXIpIHsgcmV0dXJuICEhdXNlciAmJiB1c2VyLmVtYWlsVmVyaWZpZWQ7IH07XG4gICAgdmFyIGVtYWlsVmVyaWZpZWQgPSBvcGVyYXRvcnMubWFwKMm1Myk7XG4gICAgdmFyIMm1NCA9IGZ1bmN0aW9uIChpZFRva2VuUmVzdWx0KSB7IHJldHVybiBpZFRva2VuUmVzdWx0ID8gaWRUb2tlblJlc3VsdC5jbGFpbXMgOiBbXTsgfTtcbiAgICB2YXIgY3VzdG9tQ2xhaW1zID0gcnhqcy5waXBlKGlkVG9rZW5SZXN1bHQsIG9wZXJhdG9ycy5tYXAoybU0KSk7XG4gICAgdmFyIGhhc0N1c3RvbUNsYWltID0gZnVuY3Rpb24gKGNsYWltKSB7IHJldHVybiByeGpzLnBpcGUoY3VzdG9tQ2xhaW1zLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChjbGFpbXMpIHsgcmV0dXJuIGNsYWltcy5oYXNPd25Qcm9wZXJ0eShjbGFpbSk7IH0pKTsgfTtcbiAgICB2YXIgcmVkaXJlY3RVbmF1dGhvcml6ZWRUbyA9IGZ1bmN0aW9uIChyZWRpcmVjdCkgeyByZXR1cm4gcnhqcy5waXBlKGxvZ2dlZEluLCBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uIChsb2dnZWRJbikgeyByZXR1cm4gbG9nZ2VkSW4gfHwgcmVkaXJlY3Q7IH0pKTsgfTtcbiAgICB2YXIgcmVkaXJlY3RMb2dnZWRJblRvID0gZnVuY3Rpb24gKHJlZGlyZWN0KSB7IHJldHVybiByeGpzLnBpcGUobG9nZ2VkSW4sIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGxvZ2dlZEluKSB7IHJldHVybiBsb2dnZWRJbiAmJiByZWRpcmVjdCB8fCB0cnVlOyB9KSk7IH07XG5cbiAgICB2YXIgX19kZWNvcmF0ZSQyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG4gICAgfTtcbiAgICB2YXIgQW5ndWxhckZpcmVBdXRoR3VhcmRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmd1bGFyRmlyZUF1dGhHdWFyZE1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBBbmd1bGFyRmlyZUF1dGhHdWFyZE1vZHVsZSA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgICAgICBjb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtBbmd1bGFyRmlyZUF1dGhHdWFyZF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0sIEFuZ3VsYXJGaXJlQXV0aEd1YXJkTW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJGaXJlQXV0aEd1YXJkTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICBleHBvcnRzLkFuZ3VsYXJGaXJlQXV0aEd1YXJkID0gQW5ndWxhckZpcmVBdXRoR3VhcmQ7XG4gICAgZXhwb3J0cy5jYW5BY3RpdmF0ZSA9IGNhbkFjdGl2YXRlO1xuICAgIGV4cG9ydHMubG9nZ2VkSW4gPSBsb2dnZWRJbjtcbiAgICBleHBvcnRzLmlzTm90QW5vbnltb3VzID0gaXNOb3RBbm9ueW1vdXM7XG4gICAgZXhwb3J0cy5pZFRva2VuUmVzdWx0ID0gaWRUb2tlblJlc3VsdDtcbiAgICBleHBvcnRzLmVtYWlsVmVyaWZpZWQgPSBlbWFpbFZlcmlmaWVkO1xuICAgIGV4cG9ydHMuY3VzdG9tQ2xhaW1zID0gY3VzdG9tQ2xhaW1zO1xuICAgIGV4cG9ydHMuaGFzQ3VzdG9tQ2xhaW0gPSBoYXNDdXN0b21DbGFpbTtcbiAgICBleHBvcnRzLnJlZGlyZWN0VW5hdXRob3JpemVkVG8gPSByZWRpcmVjdFVuYXV0aG9yaXplZFRvO1xuICAgIGV4cG9ydHMucmVkaXJlY3RMb2dnZWRJblRvID0gcmVkaXJlY3RMb2dnZWRJblRvO1xuICAgIGV4cG9ydHMuybUwID0gybUwJDE7XG4gICAgZXhwb3J0cy7JtTEgPSDJtTE7XG4gICAgZXhwb3J0cy7JtTIgPSDJtTI7XG4gICAgZXhwb3J0cy7JtTMgPSDJtTM7XG4gICAgZXhwb3J0cy7JtTQgPSDJtTQ7XG4gICAgZXhwb3J0cy5Bbmd1bGFyRmlyZUF1dGhHdWFyZE1vZHVsZSA9IEFuZ3VsYXJGaXJlQXV0aEd1YXJkTW9kdWxlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdfQ==