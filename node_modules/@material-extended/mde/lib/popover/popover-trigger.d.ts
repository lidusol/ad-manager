import { AfterViewInit, ElementRef, EventEmitter, OnDestroy, ViewContainerRef, ChangeDetectorRef } from '@angular/core';
import { Direction, Directionality } from '@angular/cdk/bidi';
import { Overlay } from '@angular/cdk/overlay';
import { MdePopoverPanel, MdeTarget } from './popover-interfaces';
import { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent } from './popover-types';
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
import * as ɵngcc0 from '@angular/core';
export declare class MdePopoverTrigger implements AfterViewInit, OnDestroy {
    private _overlay;
    _elementRef: ElementRef;
    private _viewContainerRef;
    private _dir;
    private _changeDetectorRef;
    ariaHaspopup: boolean;
    private _portal;
    private _overlayRef;
    private _popoverOpen;
    private _halt;
    private _backdropSubscription;
    private _positionSubscription;
    private _mouseoverTimer;
    private _openedByMouse;
    /** References the popover instance that the trigger is associated with. */
    popover: MdePopoverPanel;
    /** References the popover target instance that the trigger is associated with. */
    targetElement: MdeTarget;
    /** Position of the popover in the X axis */
    positionX: MdePopoverPositionX;
    /** Position of the popover in the Y axis */
    positionY: MdePopoverPositionY;
    /** Popover trigger event */
    triggerEvent: MdePopoverTriggerEvent;
    /** Popover delay */
    enterDelay: number;
    /** Popover delay */
    leaveDelay: number;
    /** Popover overlap trigger */
    overlapTrigger: boolean;
    /** Popover target offset x */
    targetOffsetX: number;
    /** Popover target offset y */
    targetOffsetY: number;
    /** Popover arrow offset x */
    arrowOffsetX: number;
    /** Popover arrow width */
    arrowWidth: number;
    /** Popover arrow color */
    arrowColor: string;
    /** Popover container close on click */
    closeOnClick: boolean;
    /** Popover backdrop close on click */
    backdropCloseOnClick: boolean;
    /** Event emitted when the associated popover is opened. */
    opened: EventEmitter<void>;
    /** Event emitted when the associated popover is closed. */
    closed: EventEmitter<void>;
    constructor(_overlay: Overlay, _elementRef: ElementRef, _viewContainerRef: ViewContainerRef, _dir: Directionality, _changeDetectorRef: ChangeDetectorRef);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private _setCurrentConfig;
    /** Whether the popover is open. */
    get popoverOpen(): boolean;
    onClick(event: MouseEvent): void;
    onMouseEnter(event: MouseEvent): void;
    onMouseLeave(event: MouseEvent): void;
    /** Toggles the popover between the open and closed states. */
    togglePopover(): void;
    /** Opens the popover. */
    openPopover(): void;
    /** Closes the popover. */
    closePopover(): void;
    /** Removes the popover from the DOM. */
    destroyPopover(): void;
    /** Focuses the popover trigger. */
    focus(): void;
    /** The text direction of the containing app. */
    get dir(): Direction;
    /**
    * This method ensures that the popover closes when the overlay backdrop is clicked.
    * We do not use first() here because doing so would not catch clicks from within
    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
    * explicitly when the popover is closed or destroyed.
    */
    private _subscribeToBackdrop;
    /**
    * This method sets the popover state to open and focuses the first item if
    * the popover was opened via the keyboard.
    */
    private _initPopover;
    /**
    * This method resets the popover when it's closed, most importantly restoring
    * focus to the popover trigger if the popover was opened via the keyboard.
    */
    private _resetPopover;
    /** set state rather than toggle to support triggers sharing a popover */
    private _setIsPopoverOpen;
    /**
    *  This method checks that a valid instance of MdPopover has been passed into
    *  mdPopoverTriggerFor. If not, an exception is thrown.
    */
    private _checkPopover;
    /**
    *  This method creates the overlay from the provided popover's template and saves its
    *  OverlayRef so that it can be attached to the DOM when openPopover is called.
    */
    private _createOverlay;
    /**
    * This method builds the configuration object needed to create the overlay, the OverlayConfig.
    * @returns OverlayConfig
    */
    private _getOverlayConfig;
    /**
    * Listens to changes in the position of the overlay and sets the correct classes
    * on the popover based on the new position. This ensures the animation origin is always
    * correct, even if a fallback position is used for the overlay.
    */
    private _subscribeToPositions;
    /**
    * This method builds the position strategy for the overlay, so the popover is properly connected
    * to the trigger.
    * @returns ConnectedPositionStrategy
    */
    private _getPosition;
    private _cleanUpSubscriptions;
    _handleMousedown(event: MouseEvent): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MdePopoverTrigger, [null, null, null, { optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MdePopoverTrigger, "[mdePopoverTriggerFor]", ["mdePopoverTrigger"], { "backdropCloseOnClick": "mdePopoverBackdropCloseOnClick"; "popover": "mdePopoverTriggerFor"; "targetElement": "mdePopoverTargetAt"; "positionX": "mdePopoverPositionX"; "positionY": "mdePopoverPositionY"; "triggerEvent": "mdePopoverTriggerOn"; "enterDelay": "mdePopoverEnterDelay"; "leaveDelay": "mdePopoverLeaveDelay"; "overlapTrigger": "mdePopoverOverlapTrigger"; "targetOffsetX": "mdePopoverOffsetX"; "targetOffsetY": "mdePopoverOffsetY"; "arrowOffsetX": "mdePopoverArrowOffsetX"; "arrowWidth": "mdePopoverArrowWidth"; "arrowColor": "mdePopoverArrowColor"; "closeOnClick": "mdePopoverCloseOnClick"; }, { "opened": "opened"; "closed": "closed"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmQudHMiLCJzb3VyY2VzIjpbInBvcG92ZXItdHJpZ2dlci5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgVmlld0NvbnRhaW5lclJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBPdmVybGF5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsLCBNZGVUYXJnZXQgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kZS1wb3BvdmVyIHRhZy4gSXQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgcG9wb3ZlciBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWRlUG9wb3ZlclRyaWdnZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX292ZXJsYXk7XG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIF9kaXI7XG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgYXJpYUhhc3BvcHVwOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3BvcnRhbDtcbiAgICBwcml2YXRlIF9vdmVybGF5UmVmO1xuICAgIHByaXZhdGUgX3BvcG92ZXJPcGVuO1xuICAgIHByaXZhdGUgX2hhbHQ7XG4gICAgcHJpdmF0ZSBfYmFja2Ryb3BTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfbW91c2VvdmVyVGltZXI7XG4gICAgcHJpdmF0ZSBfb3BlbmVkQnlNb3VzZTtcbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgcG9wb3ZlciBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cbiAgICBwb3BvdmVyOiBNZGVQb3BvdmVyUGFuZWw7XG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgdGFyZ2V0IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgIHRhcmdldEVsZW1lbnQ6IE1kZVRhcmdldDtcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFggYXhpcyAqL1xuICAgIHBvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWDtcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFkgYXhpcyAqL1xuICAgIHBvc2l0aW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWTtcbiAgICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXG4gICAgdHJpZ2dlckV2ZW50OiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50O1xuICAgIC8qKiBQb3BvdmVyIGRlbGF5ICovXG4gICAgZW50ZXJEZWxheTogbnVtYmVyO1xuICAgIC8qKiBQb3BvdmVyIGRlbGF5ICovXG4gICAgbGVhdmVEZWxheTogbnVtYmVyO1xuICAgIC8qKiBQb3BvdmVyIG92ZXJsYXAgdHJpZ2dlciAqL1xuICAgIG92ZXJsYXBUcmlnZ2VyOiBib29sZWFuO1xuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xuICAgIHRhcmdldE9mZnNldFg6IG51bWJlcjtcbiAgICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cbiAgICB0YXJnZXRPZmZzZXRZOiBudW1iZXI7XG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgb2Zmc2V0IHggKi9cbiAgICBhcnJvd09mZnNldFg6IG51bWJlcjtcbiAgICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xuICAgIGFycm93V2lkdGg6IG51bWJlcjtcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBjb2xvciAqL1xuICAgIGFycm93Q29sb3I6IHN0cmluZztcbiAgICAvKiogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2sgKi9cbiAgICBjbG9zZU9uQ2xpY2s6IGJvb2xlYW47XG4gICAgLyoqIFBvcG92ZXIgYmFja2Ryb3AgY2xvc2Ugb24gY2xpY2sgKi9cbiAgICBiYWNrZHJvcENsb3NlT25DbGljazogYm9vbGVhbjtcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHBvcG92ZXIgaXMgb3BlbmVkLiAqL1xuICAgIG9wZW5lZDogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBjbG9zZWQuICovXG4gICAgY2xvc2VkOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgY29uc3RydWN0b3IoX292ZXJsYXk6IE92ZXJsYXksIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgX2RpcjogRGlyZWN0aW9uYWxpdHksIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfc2V0Q3VycmVudENvbmZpZztcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBvcGVuLiAqL1xuICAgIGdldCBwb3BvdmVyT3BlbigpOiBib29sZWFuO1xuICAgIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkO1xuICAgIG9uTW91c2VFbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQ7XG4gICAgb25Nb3VzZUxlYXZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZDtcbiAgICAvKiogVG9nZ2xlcyB0aGUgcG9wb3ZlciBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZDtcbiAgICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXG4gICAgb3BlblBvcG92ZXIoKTogdm9pZDtcbiAgICAvKiogQ2xvc2VzIHRoZSBwb3BvdmVyLiAqL1xuICAgIGNsb3NlUG9wb3ZlcigpOiB2b2lkO1xuICAgIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gKi9cbiAgICBkZXN0cm95UG9wb3ZlcigpOiB2b2lkO1xuICAgIC8qKiBGb2N1c2VzIHRoZSBwb3BvdmVyIHRyaWdnZXIuICovXG4gICAgZm9jdXMoKTogdm9pZDtcbiAgICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgICBnZXQgZGlyKCk6IERpcmVjdGlvbjtcbiAgICAvKipcbiAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgcG9wb3ZlciBjbG9zZXMgd2hlbiB0aGUgb3ZlcmxheSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgICogV2UgZG8gbm90IHVzZSBmaXJzdCgpIGhlcmUgYmVjYXVzZSBkb2luZyBzbyB3b3VsZCBub3QgY2F0Y2ggY2xpY2tzIGZyb20gd2l0aGluXG4gICAgKiB0aGUgcG9wb3ZlciwgYW5kIGl0IHdvdWxkIGZhaWwgdG8gdW5zdWJzY3JpYmUgcHJvcGVybHkuIEluc3RlYWQsIHdlIHVuc3Vic2NyaWJlXG4gICAgKiBleHBsaWNpdGx5IHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkIG9yIGRlc3Ryb3llZC5cbiAgICAqL1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3A7XG4gICAgLyoqXG4gICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBwb3BvdmVyIHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcbiAgICAqIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAqL1xuICAgIHByaXZhdGUgX2luaXRQb3BvdmVyO1xuICAgIC8qKlxuICAgICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBwb3BvdmVyIHdoZW4gaXQncyBjbG9zZWQsIG1vc3QgaW1wb3J0YW50bHkgcmVzdG9yaW5nXG4gICAgKiBmb2N1cyB0byB0aGUgcG9wb3ZlciB0cmlnZ2VyIGlmIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAqL1xuICAgIHByaXZhdGUgX3Jlc2V0UG9wb3ZlcjtcbiAgICAvKiogc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBwb3BvdmVyICovXG4gICAgcHJpdmF0ZSBfc2V0SXNQb3BvdmVyT3BlbjtcbiAgICAvKipcbiAgICAqICBUaGlzIG1ldGhvZCBjaGVja3MgdGhhdCBhIHZhbGlkIGluc3RhbmNlIG9mIE1kUG9wb3ZlciBoYXMgYmVlbiBwYXNzZWQgaW50b1xuICAgICogIG1kUG9wb3ZlclRyaWdnZXJGb3IuIElmIG5vdCwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHByaXZhdGUgX2NoZWNrUG9wb3ZlcjtcbiAgICAvKipcbiAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIHBvcG92ZXIncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXG4gICAgKiAgT3ZlcmxheVJlZiBzbyB0aGF0IGl0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZW4gb3BlblBvcG92ZXIgaXMgY2FsbGVkLlxuICAgICovXG4gICAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheTtcbiAgICAvKipcbiAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgb3ZlcmxheSwgdGhlIE92ZXJsYXlDb25maWcuXG4gICAgKiBAcmV0dXJucyBPdmVybGF5Q29uZmlnXG4gICAgKi9cbiAgICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnO1xuICAgIC8qKlxuICAgICogTGlzdGVucyB0byBjaGFuZ2VzIGluIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzc2VzXG4gICAgKiBvbiB0aGUgcG9wb3ZlciBiYXNlZCBvbiB0aGUgbmV3IHBvc2l0aW9uLiBUaGlzIGVuc3VyZXMgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgYWx3YXlzXG4gICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXG4gICAgKi9cbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb1Bvc2l0aW9ucztcbiAgICAvKipcbiAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgcG9wb3ZlciBpcyBwcm9wZXJseSBjb25uZWN0ZWRcbiAgICAqIHRvIHRoZSB0cmlnZ2VyLlxuICAgICogQHJldHVybnMgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxuICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0UG9zaXRpb247XG4gICAgcHJpdmF0ZSBfY2xlYW5VcFN1YnNjcmlwdGlvbnM7XG4gICAgX2hhbmRsZU1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQ7XG59XG4iXX0=