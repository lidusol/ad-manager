import { EventEmitter, OnDestroy, TemplateRef, ElementRef, NgZone } from '@angular/core';
import { AnimationEvent } from '@angular/animations';
import { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent } from './popover-types';
import { MdePopoverPanel } from './popover-interfaces';
import * as ɵngcc0 from '@angular/core';
export declare class MdePopover implements MdePopoverPanel, OnDestroy {
    private _elementRef;
    zone: NgZone;
    role: string;
    /** Settings for popover, view setters and getters for more detail */
    private _positionX;
    private _positionY;
    private _triggerEvent;
    private _enterDelay;
    private _leaveDelay;
    private _overlapTrigger;
    private _disableAnimation;
    private _targetOffsetX;
    private _targetOffsetY;
    private _arrowOffsetX;
    private _arrowWidth;
    private _arrowColor;
    private _closeOnClick;
    private _focusTrapEnabled;
    private _focusTrapAutoCaptureEnabled;
    /** Config object to be passed into the popover's ngClass */
    _classList: {
        [key: string]: boolean;
    };
    /** */
    containerPositioning: boolean;
    /** Closing disabled on popover */
    closeDisabled: boolean;
    /** Config object to be passed into the popover's arrow ngStyle */
    popoverPanelStyles: {};
    /** Config object to be passed into the popover's arrow ngStyle */
    popoverArrowStyles: {};
    /** Config object to be passed into the popover's content ngStyle */
    popoverContentStyles: {};
    /** Emits the current animation state whenever it changes. */
    _onAnimationStateChange: EventEmitter<AnimationEvent>;
    /** Position of the popover in the X axis. */
    get positionX(): MdePopoverPositionX;
    set positionX(value: MdePopoverPositionX);
    /** Position of the popover in the Y axis. */
    get positionY(): MdePopoverPositionY;
    set positionY(value: MdePopoverPositionY);
    /** Popover trigger event */
    get triggerEvent(): MdePopoverTriggerEvent;
    set triggerEvent(value: MdePopoverTriggerEvent);
    /** Popover enter delay */
    get enterDelay(): number;
    set enterDelay(value: number);
    /** Popover leave delay */
    get leaveDelay(): number;
    set leaveDelay(value: number);
    /** Popover overlap trigger */
    get overlapTrigger(): boolean;
    set overlapTrigger(value: boolean);
    /** Popover target offset x */
    get targetOffsetX(): number;
    set targetOffsetX(value: number);
    /** Popover target offset y */
    get targetOffsetY(): number;
    set targetOffsetY(value: number);
    /** Popover arrow offset x */
    get arrowOffsetX(): number;
    set arrowOffsetX(value: number);
    /** Popover arrow width */
    get arrowWidth(): number;
    set arrowWidth(value: number);
    /** Popover arrow color */
    get arrowColor(): string;
    set arrowColor(value: string);
    /**
     * Popover container close on click
     * default: true
     */
    get closeOnClick(): boolean;
    set closeOnClick(value: boolean);
    /**
     * Disable animations of popover and all child elements
     * default: false
     */
    get disableAnimation(): boolean;
    set disableAnimation(value: boolean);
    /**
     * Popover focus trap using cdkTrapFocus
     * default: true
     */
    get focusTrapEnabled(): boolean;
    set focusTrapEnabled(value: boolean);
    /**
     * Popover focus trap auto capture using cdkTrapFocusAutoCapture
     * default: true
     */
    get focusTrapAutoCaptureEnabled(): boolean;
    set focusTrapAutoCaptureEnabled(value: boolean);
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @param classes list of class names
     */
    set panelClass(classes: string);
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @deprecated Use `panelClass` instead.
     */
    get classList(): string;
    set classList(classes: string);
    /** Event emitted when the popover is closed. */
    close: EventEmitter<void>;
    templateRef: TemplateRef<any>;
    constructor(_elementRef: ElementRef, zone: NgZone);
    ngOnDestroy(): void;
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    _handleKeydown(event: KeyboardEvent): void;
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    _emitCloseEvent(): void;
    /** Close popover on click if closeOnClick is true */
    onClick(): void;
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    onMouseOver(): void;
    /** Enables close of popover when mouse leaving popover element */
    onMouseLeave(): void;
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    setCurrentStyles(): void;
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    setPositionClasses(posX?: MdePopoverPositionX, posY?: MdePopoverPositionY): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MdePopover, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MdePopover, "mde-popover", ["mdePopover"], { "positionX": "mdePopoverPositionX"; "positionY": "mdePopoverPositionY"; "triggerEvent": "mdePopoverTriggerOn"; "enterDelay": "mdePopoverEnterDelay"; "leaveDelay": "mdePopoverLeaveDelay"; "overlapTrigger": "mdePopoverOverlapTrigger"; "targetOffsetX": "mdePopoverOffsetX"; "targetOffsetY": "mdePopoverOffsetY"; "arrowOffsetX": "mdePopoverArrowOffsetX"; "arrowWidth": "mdePopoverArrowWidth"; "arrowColor": "mdePopoverArrowColor"; "closeOnClick": "mdePopoverCloseOnClick"; "disableAnimation": "mdePopoverDisableAnimation"; "focusTrapEnabled": "mdeFocusTrapEnabled"; "focusTrapAutoCaptureEnabled": "mdeFocusTrapAutoCaptureEnabled"; "panelClass": "class"; "classList": "classList"; }, { "close": "close"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5kLnRzIiwic291cmNlcyI6WyJwb3BvdmVyLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYsIEVsZW1lbnRSZWYsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IE1kZVBvcG92ZXJQb3NpdGlvblgsIE1kZVBvcG92ZXJQb3NpdGlvblksIE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgfSBmcm9tICcuL3BvcG92ZXItdHlwZXMnO1xuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsIH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTWRlUG9wb3ZlciBpbXBsZW1lbnRzIE1kZVBvcG92ZXJQYW5lbCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmO1xuICAgIHpvbmU6IE5nWm9uZTtcbiAgICByb2xlOiBzdHJpbmc7XG4gICAgLyoqIFNldHRpbmdzIGZvciBwb3BvdmVyLCB2aWV3IHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIG1vcmUgZGV0YWlsICovXG4gICAgcHJpdmF0ZSBfcG9zaXRpb25YO1xuICAgIHByaXZhdGUgX3Bvc2l0aW9uWTtcbiAgICBwcml2YXRlIF90cmlnZ2VyRXZlbnQ7XG4gICAgcHJpdmF0ZSBfZW50ZXJEZWxheTtcbiAgICBwcml2YXRlIF9sZWF2ZURlbGF5O1xuICAgIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyO1xuICAgIHByaXZhdGUgX2Rpc2FibGVBbmltYXRpb247XG4gICAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WDtcbiAgICBwcml2YXRlIF90YXJnZXRPZmZzZXRZO1xuICAgIHByaXZhdGUgX2Fycm93T2Zmc2V0WDtcbiAgICBwcml2YXRlIF9hcnJvd1dpZHRoO1xuICAgIHByaXZhdGUgX2Fycm93Q29sb3I7XG4gICAgcHJpdmF0ZSBfY2xvc2VPbkNsaWNrO1xuICAgIHByaXZhdGUgX2ZvY3VzVHJhcEVuYWJsZWQ7XG4gICAgcHJpdmF0ZSBfZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkO1xuICAgIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgbmdDbGFzcyAqL1xuICAgIF9jbGFzc0xpc3Q6IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgICB9O1xuICAgIC8qKiAqL1xuICAgIGNvbnRhaW5lclBvc2l0aW9uaW5nOiBib29sZWFuO1xuICAgIC8qKiBDbG9zaW5nIGRpc2FibGVkIG9uIHBvcG92ZXIgKi9cbiAgICBjbG9zZURpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgYXJyb3cgbmdTdHlsZSAqL1xuICAgIHBvcG92ZXJQYW5lbFN0eWxlczoge307XG4gICAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXG4gICAgcG9wb3ZlckFycm93U3R5bGVzOiB7fTtcbiAgICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGNvbnRlbnQgbmdTdHlsZSAqL1xuICAgIHBvcG92ZXJDb250ZW50U3R5bGVzOiB7fTtcbiAgICAvKiogRW1pdHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIHdoZW5ldmVyIGl0IGNoYW5nZXMuICovXG4gICAgX29uQW5pbWF0aW9uU3RhdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxBbmltYXRpb25FdmVudD47XG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBYIGF4aXMuICovXG4gICAgZ2V0IHBvc2l0aW9uWCgpOiBNZGVQb3BvdmVyUG9zaXRpb25YO1xuICAgIHNldCBwb3NpdGlvblgodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblgpO1xuICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWSBheGlzLiAqL1xuICAgIGdldCBwb3NpdGlvblkoKTogTWRlUG9wb3ZlclBvc2l0aW9uWTtcbiAgICBzZXQgcG9zaXRpb25ZKHZhbHVlOiBNZGVQb3BvdmVyUG9zaXRpb25ZKTtcbiAgICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXG4gICAgZ2V0IHRyaWdnZXJFdmVudCgpOiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50O1xuICAgIHNldCB0cmlnZ2VyRXZlbnQodmFsdWU6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQpO1xuICAgIC8qKiBQb3BvdmVyIGVudGVyIGRlbGF5ICovXG4gICAgZ2V0IGVudGVyRGVsYXkoKTogbnVtYmVyO1xuICAgIHNldCBlbnRlckRlbGF5KHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKiBQb3BvdmVyIGxlYXZlIGRlbGF5ICovXG4gICAgZ2V0IGxlYXZlRGVsYXkoKTogbnVtYmVyO1xuICAgIHNldCBsZWF2ZURlbGF5KHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKiBQb3BvdmVyIG92ZXJsYXAgdHJpZ2dlciAqL1xuICAgIGdldCBvdmVybGFwVHJpZ2dlcigpOiBib29sZWFuO1xuICAgIHNldCBvdmVybGFwVHJpZ2dlcih2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB4ICovXG4gICAgZ2V0IHRhcmdldE9mZnNldFgoKTogbnVtYmVyO1xuICAgIHNldCB0YXJnZXRPZmZzZXRYKHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xuICAgIGdldCB0YXJnZXRPZmZzZXRZKCk6IG51bWJlcjtcbiAgICBzZXQgdGFyZ2V0T2Zmc2V0WSh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xuICAgIGdldCBhcnJvd09mZnNldFgoKTogbnVtYmVyO1xuICAgIHNldCBhcnJvd09mZnNldFgodmFsdWU6IG51bWJlcik7XG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgd2lkdGggKi9cbiAgICBnZXQgYXJyb3dXaWR0aCgpOiBudW1iZXI7XG4gICAgc2V0IGFycm93V2lkdGgodmFsdWU6IG51bWJlcik7XG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgY29sb3IgKi9cbiAgICBnZXQgYXJyb3dDb2xvcigpOiBzdHJpbmc7XG4gICAgc2V0IGFycm93Q29sb3IodmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2tcbiAgICAgKiBkZWZhdWx0OiB0cnVlXG4gICAgICovXG4gICAgZ2V0IGNsb3NlT25DbGljaygpOiBib29sZWFuO1xuICAgIHNldCBjbG9zZU9uQ2xpY2sodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgYW5pbWF0aW9ucyBvZiBwb3BvdmVyIGFuZCBhbGwgY2hpbGQgZWxlbWVudHNcbiAgICAgKiBkZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlQW5pbWF0aW9uKCk6IGJvb2xlYW47XG4gICAgc2V0IGRpc2FibGVBbmltYXRpb24odmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFBvcG92ZXIgZm9jdXMgdHJhcCB1c2luZyBjZGtUcmFwRm9jdXNcbiAgICAgKiBkZWZhdWx0OiB0cnVlXG4gICAgICovXG4gICAgZ2V0IGZvY3VzVHJhcEVuYWJsZWQoKTogYm9vbGVhbjtcbiAgICBzZXQgZm9jdXNUcmFwRW5hYmxlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogUG9wb3ZlciBmb2N1cyB0cmFwIGF1dG8gY2FwdHVyZSB1c2luZyBjZGtUcmFwRm9jdXNBdXRvQ2FwdHVyZVxuICAgICAqIGRlZmF1bHQ6IHRydWVcbiAgICAgKi9cbiAgICBnZXQgZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgc2V0IGZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCh2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXG4gICAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcbiAgICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBwb3BvdmVyIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBjbGFzc2VzIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICAgKi9cbiAgICBzZXQgcGFuZWxDbGFzcyhjbGFzc2VzOiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLXBvcG92ZXIgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxuICAgICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XG4gICAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHBhbmVsQ2xhc3NgIGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0IGNsYXNzTGlzdCgpOiBzdHJpbmc7XG4gICAgc2V0IGNsYXNzTGlzdChjbGFzc2VzOiBzdHJpbmcpO1xuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xuICAgIGNsb3NlOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHpvbmU6IE5nWm9uZSk7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgcG9wb3ZlciwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLiAqL1xuICAgIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcbiAgICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIHBvcG92ZXIuXG4gICAgICovXG4gICAgX2VtaXRDbG9zZUV2ZW50KCk6IHZvaWQ7XG4gICAgLyoqIENsb3NlIHBvcG92ZXIgb24gY2xpY2sgaWYgY2xvc2VPbkNsaWNrIGlzIHRydWUgKi9cbiAgICBvbkNsaWNrKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVE9ETzogUmVmYWN0b3Igd2hlbiBAYW5ndWxhci9jZGsgaW5jbHVkZXMgZmVhdHVyZSBJIG1lbnRpb25lZCBvbiBnaXRodWIgc2VlIGxpbmsgYmVsb3cuXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvbWF0ZXJpYWwyL3B1bGwvNTQ5MyNpc3N1ZWNvbW1lbnQtMzEzMDg1MzIzXG4gICAgICovXG4gICAgLyoqIERpc2FibGVzIGNsb3NlIG9mIHBvcG92ZXIgd2hlbiBsZWF2aW5nIHRyaWdnZXIgZWxlbWVudCBhbmQgbW91c2Ugb3ZlciB0aGUgcG9wb3ZlciAqL1xuICAgIG9uTW91c2VPdmVyKCk6IHZvaWQ7XG4gICAgLyoqIEVuYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIG1vdXNlIGxlYXZpbmcgcG9wb3ZlciBlbGVtZW50ICovXG4gICAgb25Nb3VzZUxlYXZlKCk6IHZvaWQ7XG4gICAgLyoqIFNldHMgdGhlIGN1cnJlbnQgc3R5bGVzIGZvciB0aGUgcG9wb3ZlciB0byBhbGxvdyBmb3IgZHluYW1pY2FsbHkgY2hhbmdpbmcgc2V0dGluZ3MgKi9cbiAgICBzZXRDdXJyZW50U3R5bGVzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBwb3BvdmVyIHBhbmVsIGFuaW1hdGlvblxuICAgICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkNsYXNzZXMocG9zWD86IE1kZVBvcG92ZXJQb3NpdGlvblgsIHBvc1k/OiBNZGVQb3BvdmVyUG9zaXRpb25ZKTogdm9pZDtcbn1cbiJdfQ==