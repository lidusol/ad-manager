import { __decorate } from "tslib";
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { line } from 'd3-shape';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
let GaugeAxisComponent = class GaugeAxisComponent {
    constructor() {
        this.rotate = '';
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = `rotate(${this.rotationAngle})`;
        this.ticks = this.getTicks();
    }
    getTicks() {
        const bigTickSegment = this.angleSpan / this.bigSegments;
        const smallTickSegment = bigTickSegment / this.smallSegments;
        const tickLength = 20;
        const ticks = {
            big: [],
            small: []
        };
        const startDistance = this.radius + 10;
        const textDist = startDistance + tickLength + 10;
        for (let i = 0; i <= this.bigSegments; i++) {
            const angleDeg = i * bigTickSegment;
            const angle = (angleDeg * Math.PI) / 180;
            const textAnchor = this.getTextAnchor(angleDeg);
            let skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                let text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor,
                    text,
                    textTransform: `
            translate(${textDist * Math.cos(angle)}, ${textDist * Math.sin(angle)}) rotate(${-this.rotationAngle})
          `
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (let j = 1; j <= this.smallSegments; j++) {
                const smallAngleDeg = angleDeg + j * smallTickSegment;
                const smallAngle = (smallAngleDeg * Math.PI) / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    }
    getTextAnchor(angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        let textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    }
    getTickPath(startDistance, tickLength, angle) {
        const y1 = startDistance * Math.sin(angle);
        const y2 = (startDistance + tickLength) * Math.sin(angle);
        const x1 = startDistance * Math.cos(angle);
        const x2 = (startDistance + tickLength) * Math.cos(angle);
        const points = [
            { x: x1, y: y1 },
            { x: x2, y: y2 }
        ];
        const lineGenerator = line()
            .x(d => d.x)
            .y(d => d.y);
        return lineGenerator(points);
    }
};
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], GaugeAxisComponent.prototype, "bigSegments", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "smallSegments", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "min", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "max", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "angleSpan", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "startAngle", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "radius", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "valueScale", void 0);
__decorate([
    Input()
], GaugeAxisComponent.prototype, "tickFormatting", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: `
    <svg:g [attr.transform]="rotate">
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:text
          [style.textAnchor]="tick.textAnchor"
          [attr.transform]="tick.textTransform"
          alignment-baseline="central"
        >
          {{ tick.text }}
        </svg:text>
      </svg:g>
      <svg:g *ngFor="let tick of ticks.small" class="gauge-tick gauge-tick-small">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
    </svg:g>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
export { GaugeAxisComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F1Z2UtYXhpcy5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIm5nOi9Ac3dpbWxhbmUvbmd4LWNoYXJ0cy9saWIvZ2F1Z2UvZ2F1Z2UtYXhpcy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUE0Qix1QkFBdUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwRyxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJoQyxJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtBQUFHLElBQWxDO0FBQWdCLFFBYWQsV0FBTSxHQUFXLEVBQUUsQ0FBQztBQUN0QixJQWlHQSxDQUFDO0FBQ0QsSUFqR0UsV0FBVyxDQUFDLE9BQXNCO0FBQ3BDLFFBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2xCLElBQUUsQ0FBQztBQUNILElBQ0UsTUFBTTtBQUFLLFFBQ1QsSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQy9DLFFBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQztBQUNsRCxRQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ2pDLElBQUUsQ0FBQztBQUNILElBQ0UsUUFBUTtBQUFLLFFBQ1gsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0FBQzdELFFBQUksTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztBQUNqRSxRQUFJLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUMxQixRQUFJLE1BQU0sS0FBSyxHQUFHO0FBQ2xCLFlBQU0sR0FBRyxFQUFFLEVBQUU7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LENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsYUFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsUUFBSSxPQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNqQyxJQUFFLENBQUM7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OzsrRUFBQTtBQTlHVTtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHVEQUFpQjtBQUNqQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHlEQUFtQjtBQUNuQjtBQUNSLElBREEsS0FBSyxFQUFFO0FBQUMsK0NBQVM7QUFDVDtBQUNSLElBREEsS0FBSyxFQUFFO0FBQUMsK0NBQVM7QUFDVDtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUFrQjtBQUNsQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUFtQjtBQUNuQjtBQUNYLElBREcsS0FBSyxFQUFFO0FBQUMsa0RBQVk7QUFDWjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLHNEQUFnQjtBQUNoQjtBQUFhLElBQXJCLEtBQUssRUFBRTtBQUFDLDBEQUFvQjtBQVRsQixrQkFBa0Isb0JBdkI5QixTQUFTLENBQUMsVUFDVCxRQUFRLEVBQUU7aUJBQTBCO0VBQ3BDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozt1RUFrQlQsVUFDRDthQUFlLEVBQUUsdUJBQXVCLENBQUM7R0FBTSxNQUNoRCxDQUFDLElBQ1c7O0lBQWtCO0FBK0c5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQ0Q7QUFBQyxTQWhIWSxrQkFBa0I7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGxpbmUgfSBmcm9tICdkMy1zaGFwZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1nYXVnZS1heGlzXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XCJyb3RhdGVcIj5cbiAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgdGljayBvZiB0aWNrcy5iaWdcIiBjbGFzcz1cImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVwiPlxuICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XCJ0aWNrLmxpbmVcIiAvPlxuICAgICAgPC9zdmc6Zz5cbiAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgdGljayBvZiB0aWNrcy5iaWdcIiBjbGFzcz1cImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVwiPlxuICAgICAgICA8c3ZnOnRleHRcbiAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XCJ0aWNrLnRleHRBbmNob3JcIlxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XCJ0aWNrLnRleHRUcmFuc2Zvcm1cIlxuICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cImNlbnRyYWxcIlxuICAgICAgICA+XG4gICAgICAgICAge3sgdGljay50ZXh0IH19XG4gICAgICAgIDwvc3ZnOnRleHQ+XG4gICAgICA8L3N2ZzpnPlxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzLnNtYWxsXCIgY2xhc3M9XCJnYXVnZS10aWNrIGdhdWdlLXRpY2stc21hbGxcIj5cbiAgICAgICAgPHN2ZzpwYXRoIFthdHRyLmRdPVwidGljay5saW5lXCIgLz5cbiAgICAgIDwvc3ZnOmc+XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgR2F1Z2VBeGlzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgYmlnU2VnbWVudHM6IGFueTtcbiAgQElucHV0KCkgc21hbGxTZWdtZW50czogYW55O1xuICBASW5wdXQoKSBtaW46IGFueTtcbiAgQElucHV0KCkgbWF4OiBhbnk7XG4gIEBJbnB1dCgpIGFuZ2xlU3BhbjogbnVtYmVyO1xuICBASW5wdXQoKSBzdGFydEFuZ2xlOiBudW1iZXI7XG4gIEBJbnB1dCgpIHJhZGl1czogYW55O1xuICBASW5wdXQoKSB2YWx1ZVNjYWxlOiBhbnk7XG4gIEBJbnB1dCgpIHRpY2tGb3JtYXR0aW5nOiBhbnk7XG5cbiAgdGlja3M6IGFueTtcbiAgcm90YXRpb25BbmdsZTogbnVtYmVyO1xuICByb3RhdGU6IHN0cmluZyA9ICcnO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlKCk6IHZvaWQge1xuICAgIHRoaXMucm90YXRpb25BbmdsZSA9IC05MCArIHRoaXMuc3RhcnRBbmdsZTtcbiAgICB0aGlzLnJvdGF0ZSA9IGByb3RhdGUoJHt0aGlzLnJvdGF0aW9uQW5nbGV9KWA7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcbiAgfVxuXG4gIGdldFRpY2tzKCk6IGFueSB7XG4gICAgY29uc3QgYmlnVGlja1NlZ21lbnQgPSB0aGlzLmFuZ2xlU3BhbiAvIHRoaXMuYmlnU2VnbWVudHM7XG4gICAgY29uc3Qgc21hbGxUaWNrU2VnbWVudCA9IGJpZ1RpY2tTZWdtZW50IC8gdGhpcy5zbWFsbFNlZ21lbnRzO1xuICAgIGNvbnN0IHRpY2tMZW5ndGggPSAyMDtcbiAgICBjb25zdCB0aWNrcyA9IHtcbiAgICAgIGJpZzogW10sXG4gICAgICBzbWFsbDogW11cbiAgICB9O1xuXG4gICAgY29uc3Qgc3RhcnREaXN0YW5jZSA9IHRoaXMucmFkaXVzICsgMTA7XG4gICAgY29uc3QgdGV4dERpc3QgPSBzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCArIDEwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5iaWdTZWdtZW50czsgaSsrKSB7XG4gICAgICBjb25zdCBhbmdsZURlZyA9IGkgKiBiaWdUaWNrU2VnbWVudDtcbiAgICAgIGNvbnN0IGFuZ2xlID0gKGFuZ2xlRGVnICogTWF0aC5QSSkgLyAxODA7XG5cbiAgICAgIGNvbnN0IHRleHRBbmNob3IgPSB0aGlzLmdldFRleHRBbmNob3IoYW5nbGVEZWcpO1xuXG4gICAgICBsZXQgc2tpcCA9IGZhbHNlO1xuICAgICAgaWYgKGkgPT09IDAgJiYgdGhpcy5hbmdsZVNwYW4gPT09IDM2MCkge1xuICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gTnVtYmVyLnBhcnNlRmxvYXQodGhpcy52YWx1ZVNjYWxlLmludmVydChhbmdsZURlZykudG9TdHJpbmcoKSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGhpcy50aWNrRm9ybWF0dGluZyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aWNrcy5iaWcucHVzaCh7XG4gICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSksXG4gICAgICAgICAgdGV4dEFuY2hvcixcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRleHRUcmFuc2Zvcm06IGBcbiAgICAgICAgICAgIHRyYW5zbGF0ZSgke3RleHREaXN0ICogTWF0aC5jb3MoYW5nbGUpfSwgJHt0ZXh0RGlzdCAqIE1hdGguc2luKGFuZ2xlKX0pIHJvdGF0ZSgkey10aGlzLnJvdGF0aW9uQW5nbGV9KVxuICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSB0aGlzLmJpZ1NlZ21lbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSB0aGlzLnNtYWxsU2VnbWVudHM7IGorKykge1xuICAgICAgICBjb25zdCBzbWFsbEFuZ2xlRGVnID0gYW5nbGVEZWcgKyBqICogc21hbGxUaWNrU2VnbWVudDtcbiAgICAgICAgY29uc3Qgc21hbGxBbmdsZSA9IChzbWFsbEFuZ2xlRGVnICogTWF0aC5QSSkgLyAxODA7XG5cbiAgICAgICAgdGlja3Muc21hbGwucHVzaCh7XG4gICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoIC8gMiwgc21hbGxBbmdsZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0VGV4dEFuY2hvcihhbmdsZSkge1xuICAgIC8vIFswLCA0NV0gPSAnbWlkZGxlJztcbiAgICAvLyBbNDYsIDEzNV0gPSAnc3RhcnQnO1xuICAgIC8vIFsxMzYsIDIyNV0gPSAnbWlkZGxlJztcbiAgICAvLyBbMjI2LCAzMTVdID0gJ2VuZCc7XG5cbiAgICBhbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyBhbmdsZSkgJSAzNjA7XG4gICAgbGV0IHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICBpZiAoYW5nbGUgPiA0NSAmJiBhbmdsZSA8PSAxMzUpIHtcbiAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPiAyMjUgJiYgYW5nbGUgPD0gMzE1KSB7XG4gICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0QW5jaG9yO1xuICB9XG5cbiAgZ2V0VGlja1BhdGgoc3RhcnREaXN0YW5jZSwgdGlja0xlbmd0aCwgYW5nbGUpOiBhbnkge1xuICAgIGNvbnN0IHkxID0gc3RhcnREaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB5MiA9IChzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgeDEgPSBzdGFydERpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHgyID0gKHN0YXJ0RGlzdGFuY2UgKyB0aWNrTGVuZ3RoKSAqIE1hdGguY29zKGFuZ2xlKTtcblxuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgIHsgeDogeDEsIHk6IHkxIH0sXG4gICAgICB7IHg6IHgyLCB5OiB5MiB9XG4gICAgXTtcbiAgICBjb25zdCBsaW5lR2VuZXJhdG9yID0gbGluZTxhbnk+KClcbiAgICAgIC54KGQgPT4gZC54KVxuICAgICAgLnkoZCA9PiBkLnkpO1xuICAgIHJldHVybiBsaW5lR2VuZXJhdG9yKHBvaW50cyk7XG4gIH1cbn1cbiJdfQ==