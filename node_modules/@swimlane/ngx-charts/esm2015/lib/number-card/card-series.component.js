import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { invertColor } from '../utils/color-utils';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from './card.component';

const _c0 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 2);
} if (rf & 2) {
    const c_r2 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r0.emptyColor);
    ɵngcc0.ɵɵattribute("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height);
} }
function CardSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CardSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const c_r3 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("color", c_r3.color)("bandColor", c_r3.bandColor)("textColor", c_r3.textColor)("data", c_r3.data)("label", c_r3.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
} }
let CardSeriesComponent = class CardSeriesComponent {
    constructor() {
        this.innerPadding = 15;
        this.emptyColor = 'rgba(0, 0, 0, 0)';
        this.animations = true;
        this.select = new EventEmitter();
    }
    ngOnChanges(changes) {
        this.update();
    }
    update() {
        if (this.data.length > 2) {
            const valueFormatting = this.valueFormatting || (card => card.value.toLocaleString());
            const sortedLengths = this.data
                .map(d => {
                const hasValue = d && d.data && typeof d.data.value !== 'undefined' && d.data.value !== null;
                return hasValue
                    ? valueFormatting({
                        data: d.data,
                        label: d ? d.data.name : '',
                        value: d && d.data ? d.data.value : ''
                    }).length
                    : 0;
            })
                .sort((a, b) => b - a);
            const idx = Math.ceil(this.data.length / 2);
            this.medianSize = sortedLengths[idx];
        }
        const cards = this.getCards();
        this.cards = cards.filter(d => d.data.value !== null);
        this.emptySlots = cards.filter(d => d.data.value === null);
    }
    getCards() {
        const yPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
        const xPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
        return this.data.map((d, index) => {
            let label = d.data.name;
            if (label && label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label ? label.toLocaleString() : label;
            }
            const value = d.data.value;
            const valueColor = label ? this.colors.getColor(label) : this.emptyColor;
            const color = this.cardColor || valueColor || '#000';
            return {
                x: d.x,
                y: d.y,
                width: d.width - xPadding,
                height: d.height - yPadding,
                color,
                bandColor: this.bandColor || valueColor,
                textColor: this.textColor || invertColor(color),
                label,
                data: d.data,
                tooltipText: `${label}: ${value}`
            };
        });
    }
    trackBy(index, card) {
        return card.label;
    }
    onClick(data) {
        this.select.emit(data);
    }
};
CardSeriesComponent.ɵfac = function CardSeriesComponent_Factory(t) { return new (t || CardSeriesComponent)(); };
CardSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardSeriesComponent, selectors: [["g", "ngx-charts-card-series", ""]], inputs: { innerPadding: "innerPadding", emptyColor: "emptyColor", animations: "animations", data: "data", slots: "slots", dims: "dims", colors: "colors", cardColor: "cardColor", bandColor: "bandColor", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 4, consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select"]], template: function CardSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0);
        ɵngcc0.ɵɵtemplate(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc2.CardComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], CardSeriesComponent.prototype, "data", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "slots", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "dims", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "colors", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "innerPadding", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "cardColor", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "bandColor", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "emptyColor", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "textColor", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "valueFormatting", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "labelFormatting", void 0);
__decorate([
    Input()
], CardSeriesComponent.prototype, "animations", void 0);
__decorate([
    Output()
], CardSeriesComponent.prototype, "select", void 0);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card-series]',
                template: `
    <svg:rect
      *ngFor="let c of emptySlots; trackBy: trackBy"
      class="card-empty"
      [attr.x]="c.x"
      [attr.y]="c.y"
      [style.fill]="emptyColor"
      [attr.width]="c.width"
      [attr.height]="c.height"
      rx="3"
      ry="3"
    />
    <svg:g
      ngx-charts-card
      *ngFor="let c of cards; trackBy: trackBy"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [color]="c.color"
      [bandColor]="c.bandColor"
      [textColor]="c.textColor"
      [data]="c.data"
      [label]="c.label"
      [medianSize]="medianSize"
      [valueFormatting]="valueFormatting"
      [labelFormatting]="labelFormatting"
      [animations]="animations"
      (select)="onClick($event)"
    />
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { innerPadding: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], slots: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
export { CardSeriesComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZC1zZXJpZXMuY29tcG9uZW50LmpzIiwic291cmNlcyI6WyJuZzovQHN3aW1sYW5lL25neC1jaGFydHMvbGliL251bWJlci1jYXJkL2NhcmQtc2VyaWVzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFHWix1QkFBdUIsRUFDeEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHNCQUFzQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdEbkQsSUFBYSxtQkFBbUIsR0FBaEMsTUFBYSxtQkFBbUI7QUFBRyxJQUFuQztBQUFnQixRQUtMLGlCQUFZLEdBQUcsRUFBRSxDQUFDO0FBQzdCLFFBR1csZUFBVSxHQUFHLGtCQUFrQixDQUFDO0FBQzNDLFFBR1csZUFBVSxHQUFZLElBQUksQ0FBQztBQUN0QyxRQUNZLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ3hDLElBeUVBLENBQUM7QUFDRCxJQXJFRSxXQUFXLENBQUMsT0FBc0I7QUFBSSxRQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEIsSUFBRSxDQUFDO0FBQ0gsSUFDRSxNQUFNO0FBQUssUUFDVCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUM5QixZQUFNLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztBQUM1RixZQUNNLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxJQUFJO0FBQ3JDLGlCQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNqQixnQkFBVSxNQUFNLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxP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O0FBQ0osSUFESixLQUFLLEVBQUU7QUFBQyxpREFBSztBQUNMO0FBQ04sSUFERixLQUFLLEVBQUU7QUFBQyxtREFBTztBQUNQO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMseURBQWtCO0FBRWxCO0FBQ1QsSUFEQyxLQUFLLEVBQUU7QUFBQyxzREFBVTtBQUNWO0FBQ1QsSUFEQyxLQUFLLEVBQUU7QUFBQyxzREFBVTtBQUNWO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsdURBQWdDO0FBQ2hDO0FBQ1QsSUFEQyxLQUFLLEVBQUU7QUFBQyxzREFBVTtBQUNWO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsNERBQXFCO0FBQ3JCO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsNERBQXFCO0FBQ3JCO0FBQWEsSUFBckIsS0FBSyxFQUFFO0FBQUMsdURBQTJCO0FBRTFCO0FBQWEsSUFBdEIsTUFBTSxFQUFFO0FBQUMsbURBQTRCO0FBZjNCLG1CQUFtQixvQkFuQy9CLFNBQVMsQ0FBQyxVQUNULFFBQVEsRUFBRTtrQkFBMkI7R0FDckMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQThCVDtBQUNELGVBQWUsRUFBRTtRQUF1QixDQUFDLE1BQU0sTUFDaEQsQ0FBQyxJQUNXOzs7QUFBbUIsQ0F5Ri9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsU0ExRlksbUJBQW1CO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgT25DaGFuZ2VzLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGludmVydENvbG9yIH0gZnJvbSAnLi4vdXRpbHMvY29sb3ItdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhcmRNb2RlbCB7XG4gIHg7XG4gIHk7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBjb2xvcjogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xuICBkYXRhO1xuICB0b29sdGlwVGV4dDogc3RyaW5nO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtY2FyZC1zZXJpZXNdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOnJlY3RcbiAgICAgICpuZ0Zvcj1cImxldCBjIG9mIGVtcHR5U2xvdHM7IHRyYWNrQnk6IHRyYWNrQnlcIlxuICAgICAgY2xhc3M9XCJjYXJkLWVtcHR5XCJcbiAgICAgIFthdHRyLnhdPVwiYy54XCJcbiAgICAgIFthdHRyLnldPVwiYy55XCJcbiAgICAgIFtzdHlsZS5maWxsXT1cImVtcHR5Q29sb3JcIlxuICAgICAgW2F0dHIud2lkdGhdPVwiYy53aWR0aFwiXG4gICAgICBbYXR0ci5oZWlnaHRdPVwiYy5oZWlnaHRcIlxuICAgICAgcng9XCIzXCJcbiAgICAgIHJ5PVwiM1wiXG4gICAgLz5cbiAgICA8c3ZnOmdcbiAgICAgIG5neC1jaGFydHMtY2FyZFxuICAgICAgKm5nRm9yPVwibGV0IGMgb2YgY2FyZHM7IHRyYWNrQnk6IHRyYWNrQnlcIlxuICAgICAgW3hdPVwiYy54XCJcbiAgICAgIFt5XT1cImMueVwiXG4gICAgICBbd2lkdGhdPVwiYy53aWR0aFwiXG4gICAgICBbaGVpZ2h0XT1cImMuaGVpZ2h0XCJcbiAgICAgIFtjb2xvcl09XCJjLmNvbG9yXCJcbiAgICAgIFtiYW5kQ29sb3JdPVwiYy5iYW5kQ29sb3JcIlxuICAgICAgW3RleHRDb2xvcl09XCJjLnRleHRDb2xvclwiXG4gICAgICBbZGF0YV09XCJjLmRhdGFcIlxuICAgICAgW2xhYmVsXT1cImMubGFiZWxcIlxuICAgICAgW21lZGlhblNpemVdPVwibWVkaWFuU2l6ZVwiXG4gICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cInZhbHVlRm9ybWF0dGluZ1wiXG4gICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cImxhYmVsRm9ybWF0dGluZ1wiXG4gICAgICBbYW5pbWF0aW9uc109XCJhbmltYXRpb25zXCJcbiAgICAgIChzZWxlY3QpPVwib25DbGljaygkZXZlbnQpXCJcbiAgICAvPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYXJkU2VyaWVzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgZGF0YTogYW55W107XG4gIEBJbnB1dCgpIHNsb3RzOiBhbnlbXTtcbiAgQElucHV0KCkgZGltcztcbiAgQElucHV0KCkgY29sb3JzO1xuICBASW5wdXQoKSBpbm5lclBhZGRpbmcgPSAxNTtcblxuICBASW5wdXQoKSBjYXJkQ29sb3I7XG4gIEBJbnB1dCgpIGJhbmRDb2xvcjtcbiAgQElucHV0KCkgZW1wdHlDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJztcbiAgQElucHV0KCkgdGV4dENvbG9yO1xuICBASW5wdXQoKSB2YWx1ZUZvcm1hdHRpbmc6IGFueTtcbiAgQElucHV0KCkgbGFiZWxGb3JtYXR0aW5nOiBhbnk7XG4gIEBJbnB1dCgpIGFuaW1hdGlvbnM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgY2FyZHM6IENhcmRNb2RlbFtdO1xuICBlbXB0eVNsb3RzOiBhbnlbXTtcbiAgbWVkaWFuU2l6ZTogbnVtYmVyO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdXBkYXRlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gMikge1xuICAgICAgY29uc3QgdmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGNhcmQgPT4gY2FyZC52YWx1ZS50b0xvY2FsZVN0cmluZygpKTtcblxuICAgICAgY29uc3Qgc29ydGVkTGVuZ3RocyA9IHRoaXMuZGF0YVxuICAgICAgICAubWFwKGQgPT4ge1xuICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gZCAmJiBkLmRhdGEgJiYgdHlwZW9mIGQuZGF0YS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZC5kYXRhLnZhbHVlICE9PSBudWxsO1xuICAgICAgICAgIHJldHVybiBoYXNWYWx1ZVxuICAgICAgICAgICAgPyB2YWx1ZUZvcm1hdHRpbmcoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICBsYWJlbDogZCA/IGQuZGF0YS5uYW1lIDogJycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGQgJiYgZC5kYXRhID8gZC5kYXRhLnZhbHVlIDogJydcbiAgICAgICAgICAgICAgfSkubGVuZ3RoXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgIH0pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiIC0gYSk7XG4gICAgICBjb25zdCBpZHggPSBNYXRoLmNlaWwodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xuICAgICAgdGhpcy5tZWRpYW5TaXplID0gc29ydGVkTGVuZ3Roc1tpZHhdO1xuICAgIH1cblxuICAgIGNvbnN0IGNhcmRzID0gdGhpcy5nZXRDYXJkcygpO1xuICAgIHRoaXMuY2FyZHMgPSBjYXJkcy5maWx0ZXIoZCA9PiBkLmRhdGEudmFsdWUgIT09IG51bGwpO1xuICAgIHRoaXMuZW1wdHlTbG90cyA9IGNhcmRzLmZpbHRlcihkID0+IGQuZGF0YS52YWx1ZSA9PT0gbnVsbCk7XG4gIH1cblxuICBnZXRDYXJkcygpOiBhbnlbXSB7XG4gICAgY29uc3QgeVBhZGRpbmcgPVxuICAgICAgdHlwZW9mIHRoaXMuaW5uZXJQYWRkaW5nID09PSAnbnVtYmVyJyA/IHRoaXMuaW5uZXJQYWRkaW5nIDogdGhpcy5pbm5lclBhZGRpbmdbMF0gKyB0aGlzLmlubmVyUGFkZGluZ1syXTtcbiAgICBjb25zdCB4UGFkZGluZyA9XG4gICAgICB0eXBlb2YgdGhpcy5pbm5lclBhZGRpbmcgPT09ICdudW1iZXInID8gdGhpcy5pbm5lclBhZGRpbmcgOiB0aGlzLmlubmVyUGFkZGluZ1sxXSArIHRoaXMuaW5uZXJQYWRkaW5nWzNdO1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoKGQsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgbGFiZWwgPSBkLmRhdGEubmFtZTtcbiAgICAgIGlmIChsYWJlbCAmJiBsYWJlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvY2FsZURhdGVTdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsID0gbGFiZWwgPyBsYWJlbC50b0xvY2FsZVN0cmluZygpIDogbGFiZWw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZC5kYXRhLnZhbHVlO1xuICAgICAgY29uc3QgdmFsdWVDb2xvciA9IGxhYmVsID8gdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpIDogdGhpcy5lbXB0eUNvbG9yO1xuICAgICAgY29uc3QgY29sb3IgPSB0aGlzLmNhcmRDb2xvciB8fCB2YWx1ZUNvbG9yIHx8ICcjMDAwJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGQueCxcbiAgICAgICAgeTogZC55LFxuICAgICAgICB3aWR0aDogZC53aWR0aCAtIHhQYWRkaW5nLFxuICAgICAgICBoZWlnaHQ6IGQuaGVpZ2h0IC0geVBhZGRpbmcsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBiYW5kQ29sb3I6IHRoaXMuYmFuZENvbG9yIHx8IHZhbHVlQ29sb3IsXG4gICAgICAgIHRleHRDb2xvcjogdGhpcy50ZXh0Q29sb3IgfHwgaW52ZXJ0Q29sb3IoY29sb3IpLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZGF0YTogZC5kYXRhLFxuICAgICAgICB0b29sdGlwVGV4dDogYCR7bGFiZWx9OiAke3ZhbHVlfWBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICB0cmFja0J5KGluZGV4LCBjYXJkKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY2FyZC5sYWJlbDtcbiAgfVxuXG4gIG9uQ2xpY2soZGF0YSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XG4gIH1cbn1cbiJdfQ==