import { __decorate } from "tslib";
import { Component, Input, OnChanges, SimpleChanges, ChangeDetectionStrategy, ElementRef, Output, EventEmitter } from '@angular/core';
import { formatLabel } from '../common/label.helper';
import * as ɵngcc0 from '@angular/core';

var _c0 = ["ngx-charts-bar-label", ""];
var BarLabelComponent = /** @class */ (function () {
    function BarLabelComponent(element) {
        this.dimensionsChanged = new EventEmitter();
        this.horizontalPadding = 2;
        this.verticalPadding = 5;
        this.element = element.nativeElement;
    }
    BarLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BarLabelComponent.prototype.getSize = function () {
        var h = this.element.getBoundingClientRect().height;
        var w = this.element.getBoundingClientRect().width;
        return { height: h, width: w, negative: this.value < 0 };
    };
    BarLabelComponent.prototype.ngAfterViewInit = function () {
        this.dimensionsChanged.emit(this.getSize());
    };
    BarLabelComponent.prototype.update = function () {
        if (this.valueFormatting) {
            this.formatedValue = this.valueFormatting(this.value);
        }
        else {
            this.formatedValue = formatLabel(this.value);
        }
        if (this.orientation === 'horizontal') {
            this.x = this.barX + this.barWidth;
            // if the value is negative then it's on the left of the x0.
            // we need to put the data label in front of the bar
            if (this.value < 0) {
                this.x = this.x - this.horizontalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.x = this.x + this.horizontalPadding;
                this.textAnchor = 'start';
            }
            this.y = this.barY + this.barHeight / 2;
        }
        else {
            // orientation must be "vertical"
            this.x = this.barX + this.barWidth / 2;
            this.y = this.barY + this.barHeight;
            if (this.value < 0) {
                this.y = this.y + this.verticalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.y = this.y - this.verticalPadding;
                this.textAnchor = 'start';
            }
            this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
        }
    };
    BarLabelComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "value", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barX", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barY", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barWidth", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "barHeight", void 0);
    __decorate([
        Input()
    ], BarLabelComponent.prototype, "orientation", void 0);
    __decorate([
        Output()
    ], BarLabelComponent.prototype, "dimensionsChanged", void 0);
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
BarLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "\n    <svg:text\n      class=\"textDataLabel\"\n      alignment-baseline=\"middle\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n    >\n      {{ formatedValue }}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".textDataLabel{font-size:11px}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { dimensionsChanged: [{
            type: Output
        }], value: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], barX: [{
            type: Input
        }], barY: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], barHeight: [{
            type: Input
        }], orientation: [{
            type: Input
        }] }); })();
    return BarLabelComponent;
}());
export { BarLabelComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFyLWxhYmVsLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L0Bzd2ltbGFuZS9uZ3gtY2hhcnRzL2xpYi9iYXItY2hhcnQvYmFyLWxhYmVsLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsU0FBUyxFQUNULGFBQWEsRUFDYix1QkFBdUIsRUFDdkIsVUFBVSxFQUNWLE1BQU0sRUFDTixZQUFZLEVBQ2IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHdCQUF3QixDQUFDOzs7O0FBbUJyRDtBQUFxRCxJQW9CbkQsMkJBQVksT0FBbUI7QUFDakMsUUFaWSxzQkFBaUIsR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUN0RSxRQUlFLHNCQUFpQixHQUFXLENBQUMsQ0FBQztBQUNoQyxRQUFFLG9CQUFlLEdBQVcsQ0FBQyxDQUFDO0FBQzlCLFFBS0ksSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3pDLElBQUUsQ0FBQztBQUNILElBQ0UsdUNBQVcsR0FBWCxVQUFZLE9BQXNCO0FBQUksUUFDcEMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2xCLElBQUUsQ0FBQztBQUVILElBQUUsbUNBQU8sR0FBUDtBQUFjLFFBQ1osSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sQ0FBQztBQUMxRCxRQUFJLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUM7QUFDekQsUUFBSSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDO0FBQzdELElBQUUsQ0FBQztBQUVILElBQUUsMkNBQWUs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WTtBQUFhLFFBQXRCLE1BQU0sRUFBRTtBQUFDLGdFQUEwRDtJQVR6RCxpQkFBaUIsd0JBakI3QixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUseUJBQXlCLGNBQ25DLFFBQVEsRUFBRTtpUEFXVCxjQUVELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNLGtFQUNoRCxDQUFDLFFBQ1csaUJBQWlCLENBd0U3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFDRDtBQUFDLElBREQsd0JBQUM7QUFDQSxDQURBLEFBeEVELElBd0VDO0FBQ0QsU0F6RWEsaUJBQWlCO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBFbGVtZW50UmVmLFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZvcm1hdExhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsLmhlbHBlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1iYXItbGFiZWxdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOnRleHRcbiAgICAgIGNsYXNzPVwidGV4dERhdGFMYWJlbFwiXG4gICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XCJtaWRkbGVcIlxuICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVwidGV4dEFuY2hvclwiXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVwidHJhbnNmb3JtXCJcbiAgICAgIFthdHRyLnhdPVwieFwiXG4gICAgICBbYXR0ci55XT1cInlcIlxuICAgID5cbiAgICAgIHt7IGZvcm1hdGVkVmFsdWUgfX1cbiAgICA8L3N2Zzp0ZXh0PlxuICBgLFxuICBzdHlsZVVybHM6IFsnLi9iYXItbGFiZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQmFyTGFiZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSB2YWx1ZTtcbiAgQElucHV0KCkgdmFsdWVGb3JtYXR0aW5nOiBhbnk7XG4gIEBJbnB1dCgpIGJhclg7XG4gIEBJbnB1dCgpIGJhclk7XG4gIEBJbnB1dCgpIGJhcldpZHRoO1xuICBASW5wdXQoKSBiYXJIZWlnaHQ7XG4gIEBJbnB1dCgpIG9yaWVudGF0aW9uO1xuXG4gIEBPdXRwdXQoKSBkaW1lbnNpb25zQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgZWxlbWVudDogYW55O1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgaG9yaXpvbnRhbFBhZGRpbmc6IG51bWJlciA9IDI7XG4gIHZlcnRpY2FsUGFkZGluZzogbnVtYmVyID0gNTtcbiAgZm9ybWF0ZWRWYWx1ZTogc3RyaW5nO1xuICB0cmFuc2Zvcm06IHN0cmluZztcbiAgdGV4dEFuY2hvcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIGdldFNpemUoKTogYW55IHtcbiAgICBjb25zdCBoID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICBjb25zdCB3ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIHJldHVybiB7IGhlaWdodDogaCwgd2lkdGg6IHcsIG5lZ2F0aXZlOiB0aGlzLnZhbHVlIDwgMCB9O1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh0aGlzLmdldFNpemUoKSk7XG4gIH1cblxuICB1cGRhdGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XG4gICAgICB0aGlzLmZvcm1hdGVkVmFsdWUgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JtYXRlZFZhbHVlID0gZm9ybWF0TGFiZWwodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy54ID0gdGhpcy5iYXJYICsgdGhpcy5iYXJXaWR0aDtcbiAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZSB0aGVuIGl0J3Mgb24gdGhlIGxlZnQgb2YgdGhlIHgwLlxuICAgICAgLy8gd2UgbmVlZCB0byBwdXQgdGhlIGRhdGEgbGFiZWwgaW4gZnJvbnQgb2YgdGhlIGJhclxuICAgICAgaWYgKHRoaXMudmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCAtIHRoaXMuaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgdGhpcy5ob3Jpem9udGFsUGFkZGluZztcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH1cbiAgICAgIHRoaXMueSA9IHRoaXMuYmFyWSArIHRoaXMuYmFySGVpZ2h0IC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3JpZW50YXRpb24gbXVzdCBiZSBcInZlcnRpY2FsXCJcbiAgICAgIHRoaXMueCA9IHRoaXMuYmFyWCArIHRoaXMuYmFyV2lkdGggLyAyO1xuICAgICAgdGhpcy55ID0gdGhpcy5iYXJZICsgdGhpcy5iYXJIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgKyB0aGlzLnZlcnRpY2FsUGFkZGluZztcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgLSB0aGlzLnZlcnRpY2FsUGFkZGluZztcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtID0gYHJvdGF0ZSgtNDUsICR7dGhpcy54fSAsICR7dGhpcy55fSlgO1xuICAgIH1cbiAgfVxufVxuIl19