import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, ViewChild, ChangeDetectionStrategy } from '@angular/core';
import { trimLabel } from '../trim-label.helper';
import { reduceTicks } from './ticks.helper';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["ticksel"];
var _c1 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.tickTransform(tick_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r1.textAnchor)("transform", ctx_r1.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r3)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r5.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", 0 - ctx_r5.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r2.tickTransform(tick_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showGridLines);
} }
var XAxisTicksComponent = /** @class */ (function () {
    function XAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.rotateTicks = true;
        this.dimensionsChanged = new EventEmitter();
        this.verticalSpacing = 20;
        this.rotateLabels = false;
        this.innerTickSize = 6;
        this.outerTickSize = 6;
        this.tickPadding = 3;
        this.textAnchor = 'middle';
        this.maxTicksLength = 0;
        this.maxAllowedLength = 16;
        this.height = 0;
    }
    XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
        if (height !== this.height) {
            this.height = height;
            this.dimensionsChanged.emit({ height: height });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    XAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
        this.adjustedScale = this.scale.bandwidth
            ? function (d) {
                return this.scale(d) + this.scale.bandwidth() * 0.5;
            }
            : this.scale;
        this.textTransform = '';
        if (angle && angle !== 0) {
            this.textTransform = "rotate(" + angle + ")";
            this.textAnchor = 'end';
            this.verticalSpacing = 10;
        }
        else {
            this.textAnchor = 'middle';
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
        var angle = 0;
        this.maxTicksLength = 0;
        for (var i = 0; i < ticks.length; i++) {
            var tick = this.tickFormat(ticks[i]).toString();
            var tickLength = tick.length;
            if (this.trimTicks) {
                tickLength = this.tickTrim(tick).length;
            }
            if (tickLength > this.maxTicksLength) {
                this.maxTicksLength = tickLength;
            }
        }
        var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
        var charWidth = 8; // need to measure this
        var wordWidth = len * charWidth;
        var baseWidth = wordWidth;
        var maxBaseWidth = Math.floor(this.width / ticks.length);
        // calculate optimal angle
        while (baseWidth > maxBaseWidth && angle > -90) {
            angle -= 30;
            baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
        }
        return angle;
    };
    XAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(100);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
        return Math.floor(this.width / tickWidth);
    };
    XAxisTicksComponent.prototype.tickTransform = function (tick) {
        return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
    };
    XAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(0," + (-this.verticalSpacing - 5) + ")";
    };
    XAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "gridLineHeight", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "width", void 0);
    __decorate([
        Input()
    ], XAxisTicksComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Output()
    ], XAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel')
    ], XAxisTicksComponent.prototype, "ticksElement", void 0);
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(); };
XAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c1, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], rotateTicks: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineHeight: [{
            type: Input
        }], width: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel']
        }] }); })();
    return XAxisTicksComponent;
}());
export { XAxisTicksComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieC1heGlzLXRpY2tzLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L0Bzd2ltbGFuZS9uZ3gtY2hhcnRzL2xpYi9jb21tb24vYXhlcy94LWF4aXMtdGlja3MuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUdaLFNBQVMsRUFHVCx1QkFBdUIsRUFDeEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkI3QztBQUF1RCxJQUF2RDtBQUFpQyxRQUd0QixrQkFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0IsUUFDVyxlQUFVLEdBQUcsTUFBTSxDQUFDO0FBQy9CLFFBQVcsY0FBUyxHQUFZLElBQUksQ0FBQztBQUNyQyxRQUFXLGtCQUFhLEdBQVcsRUFBRSxDQUFDO0FBQ3RDLFFBQ1csa0JBQWEsR0FBRyxLQUFLLENBQUM7QUFDakMsUUFFVyxnQkFBVyxHQUFZLElBQUksQ0FBQztBQUN2QyxRQUNZLHNCQUFpQixHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7QUFDbkQsUUFDRSxvQkFBZSxHQUFXLEVBQUUsQ0FBQztBQUMvQixRQUFFLGlCQUFZLEdBQVksS0FBSyxDQUFDO0FBQ2hDLFFBQUUsa0JBQWEsR0FBVyxDQUFDLENBQUM7QUFDNUIsUUFBRSxrQkFBYSxHQUFXLENBQUMsQ0FBQztBQUM1QixRQUFFLGdCQUFXLEdBQVcsQ0FBQyxDQUFDO0FBQzFCLFFBQUUsZUFBVSxHQUFXLFFBQVEsQ0FBQztBQUNoQyxRQUFFLG1CQUFjLEdBQVcsQ0FBQyxDQUFDO0FBQzdCLFFBQUUscUJBQWdCLEdBQVcsRUFBRSxDQUFD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QWEsUUFBckIsS0FBSyxFQUFFO0FBQUMsMERBQTBCO0FBQ3BDLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyw4REFBMkI7QUFDckMsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLCtEQUFlO0FBQ3pCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyw4REFBc0I7QUFDaEMsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLCtEQUFlO0FBQ3pCLElBQVU7QUFDTCxRQURILEtBQUssRUFBRTtBQUFDLHNEQUFNO0FBQ2hCLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQyw0REFBNEI7QUFFdkMsSUFBWTtBQUFhLFFBQXRCLE1BQU0sRUFBRTtBQUFDLGtFQUF1QztBQUVuRCxJQWN3QjtBQUFhLFFBQWxDLFNBQVMsQ0FBQyxTQUFTLENBQUM7QUFBQyw2REFBeUI7SUE5QnBDLG1CQUFtQix3QkF6Qi9CLFNBQVMsQ0FBQyxjQUNULFFBQVEsRUFBRSw0QkFBNEI7VUFDdEMsUUFBUSxFQUFFOzs7OztrYUFvQlQsY0FDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTSxVQUNoRCxDQUFDLFFBQ1csbUJBQW1CLENBcUovQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCwwQkFBQztBQUNBLENBREEsQUFySkQsSUFxSkM7QUFDRCxTQXRKYSxtQkFBbUI7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBPbkNoYW5nZXMsXG4gIEVsZW1lbnRSZWYsXG4gIFZpZXdDaGlsZCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0cmltTGFiZWwgfSBmcm9tICcuLi90cmltLWxhYmVsLmhlbHBlcic7XG5pbXBvcnQgeyByZWR1Y2VUaWNrcyB9IGZyb20gJy4vdGlja3MuaGVscGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXgtYXhpcy10aWNrc10nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6ZyAjdGlja3NlbD5cbiAgICAgIDxzdmc6ZyAqbmdGb3I9XCJsZXQgdGljayBvZiB0aWNrc1wiIGNsYXNzPVwidGlja1wiIFthdHRyLnRyYW5zZm9ybV09XCJ0aWNrVHJhbnNmb3JtKHRpY2spXCI+XG4gICAgICAgIDx0aXRsZT57eyB0aWNrRm9ybWF0KHRpY2spIH19PC90aXRsZT5cbiAgICAgICAgPHN2Zzp0ZXh0XG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMC4wMVwiXG4gICAgICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVwidGV4dEFuY2hvclwiXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cInRleHRUcmFuc2Zvcm1cIlxuICAgICAgICAgIFtzdHlsZS5mb250LXNpemVdPVwiJzEycHgnXCJcbiAgICAgICAgPlxuICAgICAgICAgIHt7IHRpY2tUcmltKHRpY2tGb3JtYXQodGljaykpIH19XG4gICAgICAgIDwvc3ZnOnRleHQ+XG4gICAgICA8L3N2ZzpnPlxuICAgIDwvc3ZnOmc+XG5cbiAgICA8c3ZnOmcgKm5nRm9yPVwibGV0IHRpY2sgb2YgdGlja3NcIiBbYXR0ci50cmFuc2Zvcm1dPVwidGlja1RyYW5zZm9ybSh0aWNrKVwiPlxuICAgICAgPHN2ZzpnICpuZ0lmPVwic2hvd0dyaWRMaW5lc1wiIFthdHRyLnRyYW5zZm9ybV09XCJncmlkTGluZVRyYW5zZm9ybSgpXCI+XG4gICAgICAgIDxzdmc6bGluZSBjbGFzcz1cImdyaWRsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC12ZXJ0aWNhbFwiIFthdHRyLnkxXT1cIi1ncmlkTGluZUhlaWdodFwiIHkyPVwiMFwiIC8+XG4gICAgICA8L3N2ZzpnPlxuICAgIDwvc3ZnOmc+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFhBeGlzVGlja3NDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoKSBzY2FsZTtcbiAgQElucHV0KCkgb3JpZW50O1xuICBASW5wdXQoKSB0aWNrQXJndW1lbnRzID0gWzVdO1xuICBASW5wdXQoKSB0aWNrVmFsdWVzOiBhbnlbXTtcbiAgQElucHV0KCkgdGlja1N0cm9rZSA9ICcjY2NjJztcbiAgQElucHV0KCkgdHJpbVRpY2tzOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgbWF4VGlja0xlbmd0aDogbnVtYmVyID0gMTY7XG4gIEBJbnB1dCgpIHRpY2tGb3JtYXR0aW5nO1xuICBASW5wdXQoKSBzaG93R3JpZExpbmVzID0gZmFsc2U7XG4gIEBJbnB1dCgpIGdyaWRMaW5lSGVpZ2h0O1xuICBASW5wdXQoKSB3aWR0aDtcbiAgQElucHV0KCkgcm90YXRlVGlja3M6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIEBPdXRwdXQoKSBkaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICB2ZXJ0aWNhbFNwYWNpbmc6IG51bWJlciA9IDIwO1xuICByb3RhdGVMYWJlbHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgaW5uZXJUaWNrU2l6ZTogbnVtYmVyID0gNjtcbiAgb3V0ZXJUaWNrU2l6ZTogbnVtYmVyID0gNjtcbiAgdGlja1BhZGRpbmc6IG51bWJlciA9IDM7XG4gIHRleHRBbmNob3I6IHN0cmluZyA9ICdtaWRkbGUnO1xuICBtYXhUaWNrc0xlbmd0aDogbnVtYmVyID0gMDtcbiAgbWF4QWxsb3dlZExlbmd0aDogbnVtYmVyID0gMTY7XG4gIGFkanVzdGVkU2NhbGU6IGFueTtcbiAgdGV4dFRyYW5zZm9ybTogYW55O1xuICB0aWNrczogYW55O1xuICB0aWNrRm9ybWF0OiAobzogYW55KSA9PiBhbnk7XG4gIGhlaWdodDogbnVtYmVyID0gMDtcblxuICBAVmlld0NoaWxkKCd0aWNrc2VsJykgdGlja3NFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVEaW1zKCkpO1xuICB9XG5cbiAgdXBkYXRlRGltcygpOiB2b2lkIHtcbiAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludCh0aGlzLnRpY2tzRWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCwgMTApO1xuICAgIGlmIChoZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh7IGhlaWdodCB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVEaW1zKCkpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblxuICAgIGlmICh0aGlzLnRpY2tGb3JtYXR0aW5nKSB7XG4gICAgICB0aGlzLnRpY2tGb3JtYXQgPSB0aGlzLnRpY2tGb3JtYXR0aW5nO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUudGlja0Zvcm1hdCkge1xuICAgICAgdGhpcy50aWNrRm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGhpcy50aWNrQXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKGQuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RhdGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLnJvdGF0ZVRpY2tzID8gdGhpcy5nZXRSb3RhdGlvbkFuZ2xlKHRoaXMudGlja3MpIDogbnVsbDtcblxuICAgIHRoaXMuYWRqdXN0ZWRTY2FsZSA9IHRoaXMuc2NhbGUuYmFuZHdpZHRoXG4gICAgICA/IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoZCkgKyB0aGlzLnNjYWxlLmJhbmR3aWR0aCgpICogMC41O1xuICAgICAgICB9XG4gICAgICA6IHRoaXMuc2NhbGU7XG5cbiAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSAnJztcbiAgICBpZiAoYW5nbGUgJiYgYW5nbGUgIT09IDApIHtcbiAgICAgIHRoaXMudGV4dFRyYW5zZm9ybSA9IGByb3RhdGUoJHthbmdsZX0pYDtcbiAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZURpbXMoKSk7XG4gIH1cblxuICBnZXRSb3RhdGlvbkFuZ2xlKHRpY2tzKTogbnVtYmVyIHtcbiAgICBsZXQgYW5nbGUgPSAwO1xuICAgIHRoaXMubWF4VGlja3NMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tGb3JtYXQodGlja3NbaV0pLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgdGlja0xlbmd0aCA9IHRpY2subGVuZ3RoO1xuICAgICAgaWYgKHRoaXMudHJpbVRpY2tzKSB7XG4gICAgICAgIHRpY2tMZW5ndGggPSB0aGlzLnRpY2tUcmltKHRpY2spLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpY2tMZW5ndGggPiB0aGlzLm1heFRpY2tzTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWF4VGlja3NMZW5ndGggPSB0aWNrTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKHRoaXMubWF4VGlja3NMZW5ndGgsIHRoaXMubWF4QWxsb3dlZExlbmd0aCk7XG4gICAgY29uc3QgY2hhcldpZHRoID0gODsgLy8gbmVlZCB0byBtZWFzdXJlIHRoaXNcbiAgICBjb25zdCB3b3JkV2lkdGggPSBsZW4gKiBjaGFyV2lkdGg7XG5cbiAgICBsZXQgYmFzZVdpZHRoID0gd29yZFdpZHRoO1xuICAgIGNvbnN0IG1heEJhc2VXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIHRpY2tzLmxlbmd0aCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb3B0aW1hbCBhbmdsZVxuICAgIHdoaWxlIChiYXNlV2lkdGggPiBtYXhCYXNlV2lkdGggJiYgYW5nbGUgPiAtOTApIHtcbiAgICAgIGFuZ2xlIC09IDMwO1xuICAgICAgYmFzZVdpZHRoID0gTWF0aC5jb3MoYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpICogd29yZFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBhbmdsZTtcbiAgfVxuXG4gIGdldFRpY2tzKCkge1xuICAgIGxldCB0aWNrcztcbiAgICBjb25zdCBtYXhUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMjApO1xuICAgIGNvbnN0IG1heFNjYWxlVGlja3MgPSB0aGlzLmdldE1heFRpY2tzKDEwMCk7XG5cbiAgICBpZiAodGhpcy50aWNrVmFsdWVzKSB7XG4gICAgICB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NhbGUudGlja3MpIHtcbiAgICAgIHRpY2tzID0gdGhpcy5zY2FsZS50aWNrcy5hcHBseSh0aGlzLnNjYWxlLCBbbWF4U2NhbGVUaWNrc10pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcyA9IHRoaXMuc2NhbGUuZG9tYWluKCk7XG4gICAgICB0aWNrcyA9IHJlZHVjZVRpY2tzKHRpY2tzLCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TWF4VGlja3ModGlja1dpZHRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMud2lkdGggLyB0aWNrV2lkdGgpO1xuICB9XG5cbiAgdGlja1RyYW5zZm9ybSh0aWNrKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJywnICsgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgKyAnKSc7XG4gIH1cblxuICBncmlkTGluZVRyYW5zZm9ybSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgdHJhbnNsYXRlKDAsJHstdGhpcy52ZXJ0aWNhbFNwYWNpbmcgLSA1fSlgO1xuICB9XG5cbiAgdGlja1RyaW0obGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudHJpbVRpY2tzID8gdHJpbUxhYmVsKGxhYmVsLCB0aGlzLm1heFRpY2tMZW5ndGgpIDogbGFiZWw7XG4gIH1cbn1cbiJdfQ==