/// <reference types="@types/google.visualization" />
import { EventEmitter, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { FilterType } from '../../models/control-type.model';
import { ChartErrorEvent } from '../../models/events.model';
import { ScriptLoaderService } from '../../script-loader/script-loader.service';
import { ChartBase } from '../chart-base/chart-base.component';
import * as ɵngcc0 from '@angular/core';
export declare class ControlWrapperComponent implements OnInit, OnChanges {
    private loaderService;
    /**
     * Charts controlled by this control wrapper. Can be a single chart or an array of charts.
     */
    for: ChartBase | ChartBase[];
    /**
     * The class name of the control.
     * The `google.visualization` package name can be omitted for Google controls.
     *
     * @example
     *
     * ```html
     * <control-wrapper type="CategoryFilter"></control-wrapper>
     * ```
     */
    type: FilterType;
    /**
     * An object describing the options for the control.
     * You can use either JavaScript literal notation, or provide a handle to the object.
     *
     * @example
     *
     * ```html
     * <control-wrapper [options]="{'filterColumnLabel': 'Age', 'minValue': 10, 'maxValue': 80}"></control-wrapper>
     * ```
     */
    options?: object;
    /**
     * An object describing the state of the control.
     * The state collects all the variables that the user operating the control can affect.
     *
     * For example, a range slider state can be described in term of the positions that the low and high thumb
     * of the slider occupy.
     * You can use either Javascript literal notation, or provide a handle to the object.
     *
     * @example
     *
     *  ```html
     * <control-wrapper [state]="{'lowValue': 20, 'highValue': 50}"></control-wrapper>
     * ```
     */
    state?: object;
    /**
     * Emits when an error occurs when attempting to render the control.
     */
    error: EventEmitter<ChartErrorEvent>;
    /**
     * The control is ready to accept user interaction and for external method calls.
     *
     * Alternatively, you can listen for a ready event on the dashboard holding the control
     * and call control methods only after the event was fired.
     */
    ready: EventEmitter<void>;
    /**
     * Emits when the user interacts with the control, affecting its state.
     * For example, a `stateChange` event will be emitted whenever you move the thumbs of a range slider control.
     *
     * To retrieve an updated control state after the event fired, call `ControlWrapper.getState()`.
     */
    stateChange: EventEmitter<void>;
    /**
     * A generated id assigned to this components DOM element.
     */
    readonly id: string;
    private _controlWrapper;
    private wrapperReadySubject;
    private initialized;
    constructor(loaderService: ScriptLoaderService);
    /**
     * Emits after the `ControlWrapper` was created.
     */
    get wrapperReady$(): import("rxjs").Observable<google.visualization.ControlWrapper>;
    get controlWrapper(): google.visualization.ControlWrapper | null;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private createControlWrapper;
    private addEventListeners;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ControlWrapperComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ControlWrapperComponent, "control-wrapper", ["controlWrapper"], { "for": "for"; "type": "type"; "options": "options"; "state": "state"; }, { "error": "error"; "ready": "ready"; "stateChange": "stateChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC13cmFwcGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJjb250cm9sLXdyYXBwZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0eXBlcy9nb29nbGUudmlzdWFsaXphdGlvblwiIC8+XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWx0ZXJUeXBlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2NvbnRyb2wtdHlwZS5tb2RlbCc7XG5pbXBvcnQgeyBDaGFydEVycm9yRXZlbnQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZXZlbnRzLm1vZGVsJztcbmltcG9ydCB7IFNjcmlwdExvYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zY3JpcHQtbG9hZGVyL3NjcmlwdC1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDaGFydEJhc2UgfSBmcm9tICcuLi9jaGFydC1iYXNlL2NoYXJ0LWJhc2UuY29tcG9uZW50JztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENvbnRyb2xXcmFwcGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICAgIHByaXZhdGUgbG9hZGVyU2VydmljZTtcbiAgICAvKipcbiAgICAgKiBDaGFydHMgY29udHJvbGxlZCBieSB0aGlzIGNvbnRyb2wgd3JhcHBlci4gQ2FuIGJlIGEgc2luZ2xlIGNoYXJ0IG9yIGFuIGFycmF5IG9mIGNoYXJ0cy5cbiAgICAgKi9cbiAgICBmb3I6IENoYXJ0QmFzZSB8IENoYXJ0QmFzZVtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBjb250cm9sLlxuICAgICAqIFRoZSBgZ29vZ2xlLnZpc3VhbGl6YXRpb25gIHBhY2thZ2UgbmFtZSBjYW4gYmUgb21pdHRlZCBmb3IgR29vZ2xlIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8Y29udHJvbC13cmFwcGVyIHR5cGU9XCJDYXRlZ29yeUZpbHRlclwiPjwvY29udHJvbC13cmFwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHR5cGU6IEZpbHRlclR5cGU7XG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG9wdGlvbnMgZm9yIHRoZSBjb250cm9sLlxuICAgICAqIFlvdSBjYW4gdXNlIGVpdGhlciBKYXZhU2NyaXB0IGxpdGVyYWwgbm90YXRpb24sIG9yIHByb3ZpZGUgYSBoYW5kbGUgdG8gdGhlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGNvbnRyb2wtd3JhcHBlciBbb3B0aW9uc109XCJ7J2ZpbHRlckNvbHVtbkxhYmVsJzogJ0FnZScsICdtaW5WYWx1ZSc6IDEwLCAnbWF4VmFsdWUnOiA4MH1cIj48L2NvbnRyb2wtd3JhcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcHRpb25zPzogb2JqZWN0O1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29udHJvbC5cbiAgICAgKiBUaGUgc3RhdGUgY29sbGVjdHMgYWxsIHRoZSB2YXJpYWJsZXMgdGhhdCB0aGUgdXNlciBvcGVyYXRpbmcgdGhlIGNvbnRyb2wgY2FuIGFmZmVjdC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCBhIHJhbmdlIHNsaWRlciBzdGF0ZSBjYW4gYmUgZGVzY3JpYmVkIGluIHRlcm0gb2YgdGhlIHBvc2l0aW9ucyB0aGF0IHRoZSBsb3cgYW5kIGhpZ2ggdGh1bWJcbiAgICAgKiBvZiB0aGUgc2xpZGVyIG9jY3VweS5cbiAgICAgKiBZb3UgY2FuIHVzZSBlaXRoZXIgSmF2YXNjcmlwdCBsaXRlcmFsIG5vdGF0aW9uLCBvciBwcm92aWRlIGEgaGFuZGxlIHRvIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8Y29udHJvbC13cmFwcGVyIFtzdGF0ZV09XCJ7J2xvd1ZhbHVlJzogMjAsICdoaWdoVmFsdWUnOiA1MH1cIj48L2NvbnRyb2wtd3JhcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0ZT86IG9iamVjdDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIGFuIGVycm9yIG9jY3VycyB3aGVuIGF0dGVtcHRpbmcgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICAqL1xuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8Q2hhcnRFcnJvckV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBpcyByZWFkeSB0byBhY2NlcHQgdXNlciBpbnRlcmFjdGlvbiBhbmQgZm9yIGV4dGVybmFsIG1ldGhvZCBjYWxscy5cbiAgICAgKlxuICAgICAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gbGlzdGVuIGZvciBhIHJlYWR5IGV2ZW50IG9uIHRoZSBkYXNoYm9hcmQgaG9sZGluZyB0aGUgY29udHJvbFxuICAgICAqIGFuZCBjYWxsIGNvbnRyb2wgbWV0aG9kcyBvbmx5IGFmdGVyIHRoZSBldmVudCB3YXMgZmlyZWQuXG4gICAgICovXG4gICAgcmVhZHk6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBjb250cm9sLCBhZmZlY3RpbmcgaXRzIHN0YXRlLlxuICAgICAqIEZvciBleGFtcGxlLCBhIGBzdGF0ZUNoYW5nZWAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdoZW5ldmVyIHlvdSBtb3ZlIHRoZSB0aHVtYnMgb2YgYSByYW5nZSBzbGlkZXIgY29udHJvbC5cbiAgICAgKlxuICAgICAqIFRvIHJldHJpZXZlIGFuIHVwZGF0ZWQgY29udHJvbCBzdGF0ZSBhZnRlciB0aGUgZXZlbnQgZmlyZWQsIGNhbGwgYENvbnRyb2xXcmFwcGVyLmdldFN0YXRlKClgLlxuICAgICAqL1xuICAgIHN0YXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqXG4gICAgICogQSBnZW5lcmF0ZWQgaWQgYXNzaWduZWQgdG8gdGhpcyBjb21wb25lbnRzIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGlkOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfY29udHJvbFdyYXBwZXI7XG4gICAgcHJpdmF0ZSB3cmFwcGVyUmVhZHlTdWJqZWN0O1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZWQ7XG4gICAgY29uc3RydWN0b3IobG9hZGVyU2VydmljZTogU2NyaXB0TG9hZGVyU2VydmljZSk7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYWZ0ZXIgdGhlIGBDb250cm9sV3JhcHBlcmAgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0IHdyYXBwZXJSZWFkeSQoKTogaW1wb3J0KFwicnhqc1wiKS5PYnNlcnZhYmxlPGdvb2dsZS52aXN1YWxpemF0aW9uLkNvbnRyb2xXcmFwcGVyPjtcbiAgICBnZXQgY29udHJvbFdyYXBwZXIoKTogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ29udHJvbFdyYXBwZXIgfCBudWxsO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBjcmVhdGVDb250cm9sV3JhcHBlcjtcbiAgICBwcml2YXRlIGFkZEV2ZW50TGlzdGVuZXJzO1xufVxuIl19