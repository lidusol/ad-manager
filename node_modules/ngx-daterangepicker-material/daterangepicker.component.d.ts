import { ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { FormControl } from '@angular/forms';
import * as _moment from 'moment';
import { Subject } from 'rxjs';
import { LocaleConfig } from './daterangepicker.config';
import { LocaleService } from './locale.service';
import * as ɵngcc0 from '@angular/core';
export declare enum SideEnum {
    left = "left",
    right = "right"
}
export declare class DaterangepickerComponent implements OnInit, OnDestroy {
    private el;
    private _ref;
    private _localeService;
    private _old;
    chosenLabel: string;
    calendarVariables: {
        left: any;
        right: any;
    };
    tooltiptext: any[];
    timepickerVariables: {
        left: any;
        right: any;
    };
    daterangepicker: {
        start: FormControl;
        end: FormControl;
    };
    fromMonthControl: FormControl;
    fromYearControl: FormControl;
    toMonthControl: FormControl;
    toYearControl: FormControl;
    applyBtn: {
        disabled: boolean;
    };
    startDate: _moment.Moment;
    endDate: _moment.Moment;
    dateLimit: number;
    sideEnum: typeof SideEnum;
    minDate: _moment.Moment;
    maxDate: _moment.Moment;
    autoApply: boolean;
    singleDatePicker: boolean;
    showDropdowns: boolean;
    showWeekNumbers: boolean;
    showISOWeekNumbers: boolean;
    linkedCalendars: boolean;
    autoUpdateInput: boolean;
    alwaysShowCalendars: boolean;
    maxSpan: boolean;
    lockStartDate: boolean;
    timePicker: boolean;
    timePicker24Hour: boolean;
    timePickerIncrement: number;
    timePickerSeconds: boolean;
    showClearButton: boolean;
    firstMonthDayClass: string;
    lastMonthDayClass: string;
    emptyWeekRowClass: string;
    firstDayOfNextMonthClass: string;
    lastDayOfPreviousMonthClass: string;
    _locale: LocaleConfig;
    set locale(value: any);
    get locale(): any;
    _ranges: any;
    set ranges(value: any);
    get ranges(): any;
    showCustomRangeLabel: boolean;
    showCancel: boolean;
    keepCalendarOpeningWithRange: boolean;
    showRangeLabelOnInput: boolean;
    customRangeDirection: boolean;
    isInvalidDate(date: _moment.Moment): boolean;
    isCustomDate(date: _moment.Moment): boolean;
    isTooltipDate(date: _moment.Moment): string;
    chosenRange: string;
    rangesArray: Array<any>;
    nowHoveredDate: any;
    pickingDate: boolean;
    isShown: Boolean;
    inline: boolean;
    leftCalendar: {
        month: _moment.Moment;
        calendar?: _moment.Moment[][];
    };
    rightCalendar: {
        month: _moment.Moment;
        calendar?: _moment.Moment[][];
    };
    showCalInRanges: Boolean;
    closeOnAutoApply: boolean;
    chosenDate: EventEmitter<{
        chosenLabel: string;
        startDate: _moment.Moment;
        endDate: _moment.Moment;
    }>;
    rangeClicked: EventEmitter<{
        label: string;
        dates: [_moment.Moment, _moment.Moment];
    }>;
    datesUpdated: EventEmitter<{
        startDate: _moment.Moment;
        endDate: _moment.Moment;
    }>;
    startDateChanged: EventEmitter<{
        startDate: _moment.Moment;
    }>;
    endDateChanged: EventEmitter<{
        endDate: _moment.Moment;
    }>;
    closeDateRangePicker: EventEmitter<void>;
    pickerContainer: ElementRef;
    constructor(el: ElementRef, _ref: ChangeDetectorRef, _localeService: LocaleService);
    destroy$: Subject<unknown>;
    ngOnInit(): void;
    ngOnDestroy(): void;
    renderRanges(): void;
    renderTimePicker(side: SideEnum): void;
    renderCalendar(side: SideEnum): void;
    setStartDate(startDate: any): void;
    setEndDate(endDate: any): void;
    updateView(): void;
    updateMonthsInView(): void;
    /**
     *  This is responsible for updating the calendars
     */
    updateCalendars(): void;
    updateElement(): void;
    /**
     * this should calculate the label
     */
    calculateChosenLabel(): void;
    clickApply(e?: any): void;
    clickCancel(): void;
    /**
     * called when month is changed
     * @param month month represented by a number (0 through 11)
     * @param side left or right
     */
    monthChanged(month: number, side: SideEnum): void;
    /**
     * called when year is changed
     * @param year year represented by a number
     * @param side left or right
     */
    yearChanged(year: number, side: SideEnum): void;
    /**
     * called when time is changed
     * @param side left or right
     */
    timeChanged(side: SideEnum): void;
    /**
     *  call when month or year changed
     * @param month month number 0 -11
     * @param year year eg: 1995
     * @param side left or right
     */
    monthOrYearChanged(month: number, year: number, side: SideEnum): void;
    /**
     * Click on previous month
     * @param side left or right calendar
     */
    clickPrev(side: SideEnum): void;
    /**
     * Click on next month
     * @param side left or right calendar
     */
    clickNext(side: SideEnum): void;
    /**
     * When hovering a date
     * @param e event: get value by e.target.value
     * @param side left or right
     * @param row row position of the current date clicked
     * @param col col position of the current date clicked
     */
    hoverDate(e: any, side: SideEnum, row: number, col: number): void;
    /**
     * When selecting a date
     * @param e event: get value by e.target.value
     * @param side left or right
     * @param row row position of the current date clicked
     * @param col col position of the current date clicked
     */
    clickDate(e: any, side: SideEnum, row: number, col: number): void;
    /**
     *  Click on the custom range
     * @param label
     */
    clickRange(label: string): void;
    show(e?: any): void;
    hide(): void;
    /**
     * handle click on all element in the component, useful for outside of click
     * @param e event
     */
    handleInternalClick(e: any): void;
    /**
     * update the locale options
     * @param locale
     */
    updateLocale(locale: any): void;
    /**
     *  clear the daterange picker
     */
    clear(): void;
    /**
     * Find out if the selected range should be disabled if it doesn't
     * fit into minDate and maxDate limitations.
     */
    disableRange(range: any): any;
    /**
     *
     * @param date the date to add time
     * @param side left or right
     */
    private _getDateWithTime;
    /**
     *  build the locale config
     */
    private _buildLocale;
    private _buildCells;
    /**
     * Find out if the current calendar row has current month days
     * (as opposed to consisting of only previous/next month days)
     */
    hasCurrentMonthDays(currentMonth: any, row: any): boolean;
    /**
     * Returns true when a date within the range of dates is invalid
     */
    private _isDateRangeInvalid;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DaterangepickerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DaterangepickerComponent, "ngx-daterangepicker-material", never, { "startDate": "startDate"; "endDate": "endDate"; "dateLimit": "dateLimit"; "minDate": "minDate"; "maxDate": "maxDate"; "autoApply": "autoApply"; "singleDatePicker": "singleDatePicker"; "showDropdowns": "showDropdowns"; "showWeekNumbers": "showWeekNumbers"; "showISOWeekNumbers": "showISOWeekNumbers"; "linkedCalendars": "linkedCalendars"; "autoUpdateInput": "autoUpdateInput"; "alwaysShowCalendars": "alwaysShowCalendars"; "maxSpan": "maxSpan"; "lockStartDate": "lockStartDate"; "timePicker": "timePicker"; "timePicker24Hour": "timePicker24Hour"; "timePickerIncrement": "timePickerIncrement"; "timePickerSeconds": "timePickerSeconds"; "showClearButton": "showClearButton"; "firstMonthDayClass": "firstMonthDayClass"; "lastMonthDayClass": "lastMonthDayClass"; "emptyWeekRowClass": "emptyWeekRowClass"; "firstDayOfNextMonthClass": "firstDayOfNextMonthClass"; "lastDayOfPreviousMonthClass": "lastDayOfPreviousMonthClass"; "showCancel": "showCancel"; "keepCalendarOpeningWithRange": "keepCalendarOpeningWithRange"; "showRangeLabelOnInput": "showRangeLabelOnInput"; "customRangeDirection": "customRangeDirection"; "closeOnAutoApply": "closeOnAutoApply"; "locale": "locale"; "ranges": "ranges"; "isInvalidDate": "isInvalidDate"; "isCustomDate": "isCustomDate"; "isTooltipDate": "isTooltipDate"; "showCustomRangeLabel": "showCustomRangeLabel"; }, { "chosenDate": "chosenDate"; "rangeClicked": "rangeClicked"; "datesUpdated": "datesUpdated"; "startDateChanged": "startDateChanged"; "endDateChanged": "endDateChanged"; "closeDateRangePicker": "closeDateRangePicker"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXJhbmdlcGlja2VyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJkYXRlcmFuZ2VwaWNrZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMb2NhbGVDb25maWcgfSBmcm9tICcuL2RhdGVyYW5nZXBpY2tlci5jb25maWcnO1xuaW1wb3J0IHsgTG9jYWxlU2VydmljZSB9IGZyb20gJy4vbG9jYWxlLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBTaWRlRW51bSB7XG4gICAgbGVmdCA9IFwibGVmdFwiLFxuICAgIHJpZ2h0ID0gXCJyaWdodFwiXG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBEYXRlcmFuZ2VwaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbDtcbiAgICBwcml2YXRlIF9yZWY7XG4gICAgcHJpdmF0ZSBfbG9jYWxlU2VydmljZTtcbiAgICBwcml2YXRlIF9vbGQ7XG4gICAgY2hvc2VuTGFiZWw6IHN0cmluZztcbiAgICBjYWxlbmRhclZhcmlhYmxlczoge1xuICAgICAgICBsZWZ0OiBhbnk7XG4gICAgICAgIHJpZ2h0OiBhbnk7XG4gICAgfTtcbiAgICB0b29sdGlwdGV4dDogYW55W107XG4gICAgdGltZXBpY2tlclZhcmlhYmxlczoge1xuICAgICAgICBsZWZ0OiBhbnk7XG4gICAgICAgIHJpZ2h0OiBhbnk7XG4gICAgfTtcbiAgICBkYXRlcmFuZ2VwaWNrZXI6IHtcbiAgICAgICAgc3RhcnQ6IEZvcm1Db250cm9sO1xuICAgICAgICBlbmQ6IEZvcm1Db250cm9sO1xuICAgIH07XG4gICAgZnJvbU1vbnRoQ29udHJvbDogRm9ybUNvbnRyb2w7XG4gICAgZnJvbVllYXJDb250cm9sOiBGb3JtQ29udHJvbDtcbiAgICB0b01vbnRoQ29udHJvbDogRm9ybUNvbnRyb2w7XG4gICAgdG9ZZWFyQ29udHJvbDogRm9ybUNvbnRyb2w7XG4gICAgYXBwbHlCdG46IHtcbiAgICAgICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgfTtcbiAgICBzdGFydERhdGU6IF9tb21lbnQuTW9tZW50O1xuICAgIGVuZERhdGU6IF9tb21lbnQuTW9tZW50O1xuICAgIGRhdGVMaW1pdDogbnVtYmVyO1xuICAgIHNpZGVFbnVtOiB0eXBlb2YgU2lkZUVudW07XG4gICAgbWluRGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgbWF4RGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgYXV0b0FwcGx5OiBib29sZWFuO1xuICAgIHNpbmdsZURhdGVQaWNrZXI6IGJvb2xlYW47XG4gICAgc2hvd0Ryb3Bkb3duczogYm9vbGVhbjtcbiAgICBzaG93V2Vla051bWJlcnM6IGJvb2xlYW47XG4gICAgc2hvd0lTT1dlZWtOdW1iZXJzOiBib29sZWFuO1xuICAgIGxpbmtlZENhbGVuZGFyczogYm9vbGVhbjtcbiAgICBhdXRvVXBkYXRlSW5wdXQ6IGJvb2xlYW47XG4gICAgYWx3YXlzU2hvd0NhbGVuZGFyczogYm9vbGVhbjtcbiAgICBtYXhTcGFuOiBib29sZWFuO1xuICAgIGxvY2tTdGFydERhdGU6IGJvb2xlYW47XG4gICAgdGltZVBpY2tlcjogYm9vbGVhbjtcbiAgICB0aW1lUGlja2VyMjRIb3VyOiBib29sZWFuO1xuICAgIHRpbWVQaWNrZXJJbmNyZW1lbnQ6IG51bWJlcjtcbiAgICB0aW1lUGlja2VyU2Vjb25kczogYm9vbGVhbjtcbiAgICBzaG93Q2xlYXJCdXR0b246IGJvb2xlYW47XG4gICAgZmlyc3RNb250aERheUNsYXNzOiBzdHJpbmc7XG4gICAgbGFzdE1vbnRoRGF5Q2xhc3M6IHN0cmluZztcbiAgICBlbXB0eVdlZWtSb3dDbGFzczogc3RyaW5nO1xuICAgIGZpcnN0RGF5T2ZOZXh0TW9udGhDbGFzczogc3RyaW5nO1xuICAgIGxhc3REYXlPZlByZXZpb3VzTW9udGhDbGFzczogc3RyaW5nO1xuICAgIF9sb2NhbGU6IExvY2FsZUNvbmZpZztcbiAgICBzZXQgbG9jYWxlKHZhbHVlOiBhbnkpO1xuICAgIGdldCBsb2NhbGUoKTogYW55O1xuICAgIF9yYW5nZXM6IGFueTtcbiAgICBzZXQgcmFuZ2VzKHZhbHVlOiBhbnkpO1xuICAgIGdldCByYW5nZXMoKTogYW55O1xuICAgIHNob3dDdXN0b21SYW5nZUxhYmVsOiBib29sZWFuO1xuICAgIHNob3dDYW5jZWw6IGJvb2xlYW47XG4gICAga2VlcENhbGVuZGFyT3BlbmluZ1dpdGhSYW5nZTogYm9vbGVhbjtcbiAgICBzaG93UmFuZ2VMYWJlbE9uSW5wdXQ6IGJvb2xlYW47XG4gICAgY3VzdG9tUmFuZ2VEaXJlY3Rpb246IGJvb2xlYW47XG4gICAgaXNJbnZhbGlkRGF0ZShkYXRlOiBfbW9tZW50Lk1vbWVudCk6IGJvb2xlYW47XG4gICAgaXNDdXN0b21EYXRlKGRhdGU6IF9tb21lbnQuTW9tZW50KTogYm9vbGVhbjtcbiAgICBpc1Rvb2x0aXBEYXRlKGRhdGU6IF9tb21lbnQuTW9tZW50KTogc3RyaW5nO1xuICAgIGNob3NlblJhbmdlOiBzdHJpbmc7XG4gICAgcmFuZ2VzQXJyYXk6IEFycmF5PGFueT47XG4gICAgbm93SG92ZXJlZERhdGU6IGFueTtcbiAgICBwaWNraW5nRGF0ZTogYm9vbGVhbjtcbiAgICBpc1Nob3duOiBCb29sZWFuO1xuICAgIGlubGluZTogYm9vbGVhbjtcbiAgICBsZWZ0Q2FsZW5kYXI6IHtcbiAgICAgICAgbW9udGg6IF9tb21lbnQuTW9tZW50O1xuICAgICAgICBjYWxlbmRhcj86IF9tb21lbnQuTW9tZW50W11bXTtcbiAgICB9O1xuICAgIHJpZ2h0Q2FsZW5kYXI6IHtcbiAgICAgICAgbW9udGg6IF9tb21lbnQuTW9tZW50O1xuICAgICAgICBjYWxlbmRhcj86IF9tb21lbnQuTW9tZW50W11bXTtcbiAgICB9O1xuICAgIHNob3dDYWxJblJhbmdlczogQm9vbGVhbjtcbiAgICBjbG9zZU9uQXV0b0FwcGx5OiBib29sZWFuO1xuICAgIGNob3NlbkRhdGU6IEV2ZW50RW1pdHRlcjx7XG4gICAgICAgIGNob3NlbkxhYmVsOiBzdHJpbmc7XG4gICAgICAgIHN0YXJ0RGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgICAgIGVuZERhdGU6IF9tb21lbnQuTW9tZW50O1xuICAgIH0+O1xuICAgIHJhbmdlQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgbGFiZWw6IHN0cmluZztcbiAgICAgICAgZGF0ZXM6IFtfbW9tZW50Lk1vbWVudCwgX21vbWVudC5Nb21lbnRdO1xuICAgIH0+O1xuICAgIGRhdGVzVXBkYXRlZDogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgc3RhcnREYXRlOiBfbW9tZW50Lk1vbWVudDtcbiAgICAgICAgZW5kRGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgfT47XG4gICAgc3RhcnREYXRlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgc3RhcnREYXRlOiBfbW9tZW50Lk1vbWVudDtcbiAgICB9PjtcbiAgICBlbmREYXRlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgZW5kRGF0ZTogX21vbWVudC5Nb21lbnQ7XG4gICAgfT47XG4gICAgY2xvc2VEYXRlUmFuZ2VQaWNrZXI6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICBwaWNrZXJDb250YWluZXI6IEVsZW1lbnRSZWY7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIF9yZWY6IENoYW5nZURldGVjdG9yUmVmLCBfbG9jYWxlU2VydmljZTogTG9jYWxlU2VydmljZSk7XG4gICAgZGVzdHJveSQ6IFN1YmplY3Q8dW5rbm93bj47XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHJlbmRlclJhbmdlcygpOiB2b2lkO1xuICAgIHJlbmRlclRpbWVQaWNrZXIoc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIHJlbmRlckNhbGVuZGFyKHNpZGU6IFNpZGVFbnVtKTogdm9pZDtcbiAgICBzZXRTdGFydERhdGUoc3RhcnREYXRlOiBhbnkpOiB2b2lkO1xuICAgIHNldEVuZERhdGUoZW5kRGF0ZTogYW55KTogdm9pZDtcbiAgICB1cGRhdGVWaWV3KCk6IHZvaWQ7XG4gICAgdXBkYXRlTW9udGhzSW5WaWV3KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSBjYWxlbmRhcnNcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxlbmRhcnMoKTogdm9pZDtcbiAgICB1cGRhdGVFbGVtZW50KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogdGhpcyBzaG91bGQgY2FsY3VsYXRlIHRoZSBsYWJlbFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUNob3NlbkxhYmVsKCk6IHZvaWQ7XG4gICAgY2xpY2tBcHBseShlPzogYW55KTogdm9pZDtcbiAgICBjbGlja0NhbmNlbCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIG1vbnRoIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gbW9udGggbW9udGggcmVwcmVzZW50ZWQgYnkgYSBudW1iZXIgKDAgdGhyb3VnaCAxMSlcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICovXG4gICAgbW9udGhDaGFuZ2VkKG1vbnRoOiBudW1iZXIsIHNpZGU6IFNpZGVFbnVtKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiB5ZWFyIGlzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0geWVhciB5ZWFyIHJlcHJlc2VudGVkIGJ5IGEgbnVtYmVyXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodFxuICAgICAqL1xuICAgIHllYXJDaGFuZ2VkKHllYXI6IG51bWJlciwgc2lkZTogU2lkZUVudW0pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGNhbGxlZCB3aGVuIHRpbWUgaXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSBzaWRlIGxlZnQgb3IgcmlnaHRcbiAgICAgKi9cbiAgICB0aW1lQ2hhbmdlZChzaWRlOiBTaWRlRW51bSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIGNhbGwgd2hlbiBtb250aCBvciB5ZWFyIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gbW9udGggbW9udGggbnVtYmVyIDAgLTExXG4gICAgICogQHBhcmFtIHllYXIgeWVhciBlZzogMTk5NVxuICAgICAqIEBwYXJhbSBzaWRlIGxlZnQgb3IgcmlnaHRcbiAgICAgKi9cbiAgICBtb250aE9yWWVhckNoYW5nZWQobW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyLCBzaWRlOiBTaWRlRW51bSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xpY2sgb24gcHJldmlvdXMgbW9udGhcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0IGNhbGVuZGFyXG4gICAgICovXG4gICAgY2xpY2tQcmV2KHNpZGU6IFNpZGVFbnVtKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDbGljayBvbiBuZXh0IG1vbnRoXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodCBjYWxlbmRhclxuICAgICAqL1xuICAgIGNsaWNrTmV4dChzaWRlOiBTaWRlRW51bSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogV2hlbiBob3ZlcmluZyBhIGRhdGVcbiAgICAgKiBAcGFyYW0gZSBldmVudDogZ2V0IHZhbHVlIGJ5IGUudGFyZ2V0LnZhbHVlXG4gICAgICogQHBhcmFtIHNpZGUgbGVmdCBvciByaWdodFxuICAgICAqIEBwYXJhbSByb3cgcm93IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGUgY2xpY2tlZFxuICAgICAqIEBwYXJhbSBjb2wgY29sIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGUgY2xpY2tlZFxuICAgICAqL1xuICAgIGhvdmVyRGF0ZShlOiBhbnksIHNpZGU6IFNpZGVFbnVtLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFdoZW4gc2VsZWN0aW5nIGEgZGF0ZVxuICAgICAqIEBwYXJhbSBlIGV2ZW50OiBnZXQgdmFsdWUgYnkgZS50YXJnZXQudmFsdWVcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICogQHBhcmFtIHJvdyByb3cgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0ZSBjbGlja2VkXG4gICAgICogQHBhcmFtIGNvbCBjb2wgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZGF0ZSBjbGlja2VkXG4gICAgICovXG4gICAgY2xpY2tEYXRlKGU6IGFueSwgc2lkZTogU2lkZUVudW0sIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIENsaWNrIG9uIHRoZSBjdXN0b20gcmFuZ2VcbiAgICAgKiBAcGFyYW0gbGFiZWxcbiAgICAgKi9cbiAgICBjbGlja1JhbmdlKGxhYmVsOiBzdHJpbmcpOiB2b2lkO1xuICAgIHNob3coZT86IGFueSk6IHZvaWQ7XG4gICAgaGlkZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBjbGljayBvbiBhbGwgZWxlbWVudCBpbiB0aGUgY29tcG9uZW50LCB1c2VmdWwgZm9yIG91dHNpZGUgb2YgY2xpY2tcbiAgICAgKiBAcGFyYW0gZSBldmVudFxuICAgICAqL1xuICAgIGhhbmRsZUludGVybmFsQ2xpY2soZTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGxvY2FsZSBvcHRpb25zXG4gICAgICogQHBhcmFtIGxvY2FsZVxuICAgICAqL1xuICAgIHVwZGF0ZUxvY2FsZShsb2NhbGU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogIGNsZWFyIHRoZSBkYXRlcmFuZ2UgcGlja2VyXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGaW5kIG91dCBpZiB0aGUgc2VsZWN0ZWQgcmFuZ2Ugc2hvdWxkIGJlIGRpc2FibGVkIGlmIGl0IGRvZXNuJ3RcbiAgICAgKiBmaXQgaW50byBtaW5EYXRlIGFuZCBtYXhEYXRlIGxpbWl0YXRpb25zLlxuICAgICAqL1xuICAgIGRpc2FibGVSYW5nZShyYW5nZTogYW55KTogYW55O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gYWRkIHRpbWVcbiAgICAgKiBAcGFyYW0gc2lkZSBsZWZ0IG9yIHJpZ2h0XG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0RGF0ZVdpdGhUaW1lO1xuICAgIC8qKlxuICAgICAqICBidWlsZCB0aGUgbG9jYWxlIGNvbmZpZ1xuICAgICAqL1xuICAgIHByaXZhdGUgX2J1aWxkTG9jYWxlO1xuICAgIHByaXZhdGUgX2J1aWxkQ2VsbHM7XG4gICAgLyoqXG4gICAgICogRmluZCBvdXQgaWYgdGhlIGN1cnJlbnQgY2FsZW5kYXIgcm93IGhhcyBjdXJyZW50IG1vbnRoIGRheXNcbiAgICAgKiAoYXMgb3Bwb3NlZCB0byBjb25zaXN0aW5nIG9mIG9ubHkgcHJldmlvdXMvbmV4dCBtb250aCBkYXlzKVxuICAgICAqL1xuICAgIGhhc0N1cnJlbnRNb250aERheXMoY3VycmVudE1vbnRoOiBhbnksIHJvdzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiBhIGRhdGUgd2l0aGluIHRoZSByYW5nZSBvZiBkYXRlcyBpcyBpbnZhbGlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfaXNEYXRlUmFuZ2VJbnZhbGlkO1xufVxuIl19