import { __decorate, __metadata } from "tslib";
import { Directive, Input, ComponentFactoryResolver, ViewContainerRef, ComponentFactory, ComponentRef, ElementRef, EventEmitter, Output, OnInit } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged } from 'rxjs/operators';
import { EmojiPickerComponent } from '../components/emoji-picker.component';
import { DIRECTIONS } from '../misc/picker-directions';
import { EmojiEvent } from '../misc/emoji-event';
import * as ɵngcc0 from '@angular/core';
let EmojiPickerApiDirective = class EmojiPickerApiDirective {
    constructor(_cfr, _vcr, _el) {
        this._cfr = _cfr;
        this._vcr = _vcr;
        this._el = _el;
        this._directionCode = DIRECTIONS.bottom;
        this._searchBar = false;
        this.emojiPickerIfEmitter = new EventEmitter();
        this.selectEmitter = new EventEmitter();
        this._emojiPickerOpenState = new Subject();
        this._destroyed = new Subject();
        this._emojiSubs = [];
        this.initPicker();
        this._emojiPickerOpenState
            .pipe(takeUntil(this._destroyed), distinctUntilChanged())
            .subscribe(value => {
            var _a, _b, _c, _d, _e, _f;
            if (value) {
                (_c = (_b = (_a = this._emojiPickerRef) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.show) === null || _c === void 0 ? void 0 : _c.call(_b);
            }
            else {
                (_f = (_e = (_d = this._emojiPickerRef) === null || _d === void 0 ? void 0 : _d.instance) === null || _e === void 0 ? void 0 : _e.hide) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
        });
    }
    set emojiPickerDirection(direction) {
        if (DIRECTIONS[direction] === undefined) {
            console.error(`Emoji-Picker: direction '${direction}' passed as input does not exist in DIRECTIONS table, defaulting to 'bottom'`);
            this._directionCode = DIRECTIONS.bottom;
        }
        else {
            this._directionCode = DIRECTIONS[direction];
        }
    }
    set emojiPickerIf(condition) {
        this._emojiPickerOpenState.next(condition);
    }
    initPicker() {
        this._emojiPickerFactory = this._emojiPickerFactory || this._cfr.resolveComponentFactory(EmojiPickerComponent);
        this._emojiPickerRef = this._emojiPickerRef || this._vcr.createComponent(this._emojiPickerFactory);
        this._emojiPickerRef.instance.setPosition(this._el, this._directionCode);
        this._emojiSubs.push(this._emojiPickerRef.instance.pickerCloseEmitter.subscribe(event => this.emojiPickerIfEmitter.emit(false)), this._emojiPickerRef.instance.selectionEmitter.subscribe(event => this.selectEmitter.emit(EmojiEvent.fromArray(event))));
    }
    closePicker() {
        if (!this._emojiPickerRef || !this._emojiPickerRef.destroy) {
            return;
        }
        this._emojiSubs.forEach((subscription) => subscription.unsubscribe());
        this._emojiPickerRef.destroy();
        this._emojiSubs = [];
        delete this._emojiPickerRef;
    }
    ngOnDestroy() {
        this._destroyed.next(true);
    }
};
EmojiPickerApiDirective.ɵfac = function EmojiPickerApiDirective_Factory(t) { return new (t || EmojiPickerApiDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
EmojiPickerApiDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: EmojiPickerApiDirective, selectors: [["", "emojiPickerIf", ""]], hostBindings: function EmojiPickerApiDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function EmojiPickerApiDirective_click_HostBindingHandler($event) { return $event.emojiPickerExempt = true; });
    } }, inputs: { emojiPickerDirection: "emojiPickerDirection", emojiPickerIf: "emojiPickerIf" }, outputs: { emojiPickerIfEmitter: "emojiPickerIfChange", selectEmitter: "emojiPickerSelect" } });
EmojiPickerApiDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: ElementRef }
];
__decorate([
    Input('emojiPickerDirection'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], EmojiPickerApiDirective.prototype, "emojiPickerDirection", null);
__decorate([
    Input('emojiPickerIf'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], EmojiPickerApiDirective.prototype, "emojiPickerIf", null);
__decorate([
    Output('emojiPickerIfChange'),
    __metadata("design:type", Object)
], EmojiPickerApiDirective.prototype, "emojiPickerIfEmitter", void 0);
__decorate([
    Output('emojiPickerSelect'),
    __metadata("design:type", Object)
], EmojiPickerApiDirective.prototype, "selectEmitter", void 0);
EmojiPickerApiDirective = __decorate([ __metadata("design:paramtypes", [ComponentFactoryResolver,
        ViewContainerRef,
        ElementRef])
], EmojiPickerApiDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmojiPickerApiDirective, [{
        type: Directive,
        args: [{
                selector: '[emojiPickerIf]',
                host: {
                    '(click)': '$event.emojiPickerExempt = true' // marking off event listening on anchor
                }
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ElementRef }]; }, { emojiPickerIfEmitter: [{
            type: Output,
            args: ['emojiPickerIfChange']
        }], selectEmitter: [{
            type: Output,
            args: ['emojiPickerSelect']
        }], emojiPickerDirection: [{
            type: Input,
            args: ['emojiPickerDirection']
        }], emojiPickerIf: [{
            type: Input,
            args: ['emojiPickerIf']
        }] }); })();
export { EmojiPickerApiDirective };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1vamktcGlja2VyLWFwaS5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIm5nOi9uZ3gtZW1vamktcGlja2VyL2xpYi9kaXJlY3RpdmVzL2Vtb2ppLXBpY2tlci1hcGkuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCx3QkFBd0IsRUFDeEIsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQixZQUFZLEVBQ1osVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sTUFBTSxFQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQWtCLE1BQU0sTUFBTSxDQUFDO0FBQy9DLE9BQU8sRUFBRSxTQUFTLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUdoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUM1RSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDdkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHFCQUFxQixDQUFDOztBQVFqRCxJQUFhLHVCQUF1QixHQUFwQyxNQUFhLHVCQUF1QjtBQUNwQyxJQTJCRSxZQUNVLElBQThCLEVBQzlCLElBQXNCLEVBQ3RCLEdBQWU7QUFDeEIsUUFIUyxTQUFJLEdBQUosSUFBSSxDQUEwQjtBQUFDLFFBQy9CLFNBQUksR0FBSixJQUFJLENBQWtCO0FBQUMsUUFDdkIsUUFBRyxHQUFILEdBQUcsQ0FBWTtBQUMzQixRQS9CVSxtQkFBYyxHQUFlLFVBQVUsQ0FBQyxNQUFNLENBQUM7QUFDekQsUUFBVSxlQUFVLEdBQVksS0FBSyxDQUFDO0FBQ3RDLFFBY2lDLHlCQUFvQixHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7QUFDcEYsUUFDK0Isa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ2xFLFFBQ1UsMEJBQXFCLEdBQUcsSUFBSSxPQUFPLEVBQVcs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Q25DLFFBQ0ksSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDekIsUUFBSSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7QUFDaEMsSUFBRSxDQUFDO0FBQ0gsSUFDRSxXQUFXO0FBQ2IsUUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixJQUFFLENBQUM7QUFDSCxDQUFDOzs7O21NQUFBO0FBQ0Q7QUFBaUQsWUEvQy9CLHdCQUF3QjtBQUN4QyxZQUFnQixnQkFBZ0I7QUFDaEMsWUFBZSxVQUFVO0FBQ3pCO0FBNUIrQjtBQUFhLElBQTNDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQztBQUFFO0FBQXVDO0FBQ2pDLG1FQU1yQztBQUd1QjtBQUFhLElBQXBDLEtBQUssQ0FBQyxlQUFlLENBQUM7QUFBRTtBQUMxQjtBQUNELDREQUFHO0FBQzhCO0FBQWEsSUFBM0MsTUFBTSxDQUFDLHFCQUFxQixDQUFDO0FBQUU7QUFBc0MscUVBQVk7QUFFckQ7QUFBYSxJQUF6QyxNQUFNLENBQUMsbUJBQW1CLENBQUM7QUFBRTtBQUU5Qiw4REFGZ0U7QUFuQnJELHVCQUF1QixvQkFObkMsU0FBUyxDQUFDLFVBQ1QsUUFBUSxFQUFFLGlCQUFpQixwREFLekIsa0NBNkJjLHdCQUF3QjtFQWpDeEMsSUFBSSxFQUFFLGNBQ0osdEJBaUNKLFFBQWtCLGdCQUFnQjtLQWpDckIsRUFBRSxQQWtDZixRQUFpQixVQUFVO21CQWxDcUIsQ0FBQyxwQkFtQy9DLEdBaENXLHVCQUF1QixDQTJFbkM7K0JBOUV3RixVQUN0RixNQUNELENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQTZFSDtBQUFDLFNBNUVZLHVCQUF1QjtBQUNuQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgSW5wdXQsXG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgQ29tcG9uZW50RmFjdG9yeSxcbiAgQ29tcG9uZW50UmVmLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIE91dHB1dCxcbiAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCAsICBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuXG5pbXBvcnQgeyBFbW9qaVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudHMvZW1vamktcGlja2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBESVJFQ1RJT05TIH0gZnJvbSAnLi4vbWlzYy9waWNrZXItZGlyZWN0aW9ucyc7XG5pbXBvcnQgeyBFbW9qaUV2ZW50IH0gZnJvbSAnLi4vbWlzYy9lbW9qaS1ldmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbW9qaVBpY2tlcklmXScsXG4gIGhvc3Q6IHtcbiAgICAnKGNsaWNrKSc6ICckZXZlbnQuZW1vamlQaWNrZXJFeGVtcHQgPSB0cnVlJyAvLyBtYXJraW5nIG9mZiBldmVudCBsaXN0ZW5pbmcgb24gYW5jaG9yXG4gIH1cbiB9KVxuZXhwb3J0IGNsYXNzIEVtb2ppUGlja2VyQXBpRGlyZWN0aXZlIHtcbiAgcHJpdmF0ZSBfZGlyZWN0aW9uQ29kZTogRElSRUNUSU9OUyA9IERJUkVDVElPTlMuYm90dG9tO1xuICBwcml2YXRlIF9zZWFyY2hCYXI6IEJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoJ2Vtb2ppUGlja2VyRGlyZWN0aW9uJykgc2V0IGVtb2ppUGlja2VyRGlyZWN0aW9uKGRpcmVjdGlvbjogc3RyaW5nKSB7XG4gICAgaWYgKERJUkVDVElPTlNbZGlyZWN0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFbW9qaS1QaWNrZXI6IGRpcmVjdGlvbiAnJHtkaXJlY3Rpb259JyBwYXNzZWQgYXMgaW5wdXQgZG9lcyBub3QgZXhpc3QgaW4gRElSRUNUSU9OUyB0YWJsZSwgZGVmYXVsdGluZyB0byAnYm90dG9tJ2ApO1xuICAgICAgdGhpcy5fZGlyZWN0aW9uQ29kZSA9IERJUkVDVElPTlMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb25Db2RlID0gRElSRUNUSU9OU1tkaXJlY3Rpb25dO1xuICAgIH1cbiAgfVxuXG5cbiAgQElucHV0KCdlbW9qaVBpY2tlcklmJykgc2V0IGVtb2ppUGlja2VySWYoY29uZGl0aW9uOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZW1vamlQaWNrZXJPcGVuU3RhdGUubmV4dChjb25kaXRpb24pO1xuICB9XG4gIEBPdXRwdXQoJ2Vtb2ppUGlja2VySWZDaGFuZ2UnKSBlbW9qaVBpY2tlcklmRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgXG4gIEBPdXRwdXQoJ2Vtb2ppUGlja2VyU2VsZWN0Jykgc2VsZWN0RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIF9lbW9qaVBpY2tlck9wZW5TdGF0ZSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByaXZhdGUgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgcHJpdmF0ZSBfZW1vamlQaWNrZXJGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PEVtb2ppUGlja2VyQ29tcG9uZW50PjtcbiAgcHJpdmF0ZSBfZW1vamlQaWNrZXJSZWY6IENvbXBvbmVudFJlZjxFbW9qaVBpY2tlckNvbXBvbmVudD47XG4gIHByaXZhdGUgX2Vtb2ppU3ViczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9jZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIF92Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBfZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5pbml0UGlja2VyKCk7XG5cbiAgICB0aGlzLl9lbW9qaVBpY2tlck9wZW5TdGF0ZVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgIFxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9lbW9qaVBpY2tlclJlZj8uaW5zdGFuY2U/LnNob3c/LigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2Vtb2ppUGlja2VyUmVmPy5pbnN0YW5jZT8uaGlkZT8uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgaW5pdFBpY2tlcigpIHtcbiAgICB0aGlzLl9lbW9qaVBpY2tlckZhY3RvcnkgPSB0aGlzLl9lbW9qaVBpY2tlckZhY3RvcnkgfHwgdGhpcy5fY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KEVtb2ppUGlja2VyQ29tcG9uZW50KTtcbiAgICB0aGlzLl9lbW9qaVBpY2tlclJlZiA9IHRoaXMuX2Vtb2ppUGlja2VyUmVmIHx8IHRoaXMuX3Zjci5jcmVhdGVDb21wb25lbnQodGhpcy5fZW1vamlQaWNrZXJGYWN0b3J5KTtcblxuICAgIHRoaXMuX2Vtb2ppUGlja2VyUmVmLmluc3RhbmNlLnNldFBvc2l0aW9uKHRoaXMuX2VsLCB0aGlzLl9kaXJlY3Rpb25Db2RlKTtcbiAgICB0aGlzLl9lbW9qaVN1YnMucHVzaChcbiAgICAgIHRoaXMuX2Vtb2ppUGlja2VyUmVmLmluc3RhbmNlLnBpY2tlckNsb3NlRW1pdHRlci5zdWJzY3JpYmUoZXZlbnQgPT4gdGhpcy5lbW9qaVBpY2tlcklmRW1pdHRlci5lbWl0KGZhbHNlKSksXG4gICAgICB0aGlzLl9lbW9qaVBpY2tlclJlZi5pbnN0YW5jZS5zZWxlY3Rpb25FbWl0dGVyLnN1YnNjcmliZShldmVudCA9PiB0aGlzLnNlbGVjdEVtaXR0ZXIuZW1pdChFbW9qaUV2ZW50LmZyb21BcnJheShldmVudCkpKVxuICAgICk7XG4gIH1cblxuICBjbG9zZVBpY2tlcigpIHtcbiAgICBpZiAoIXRoaXMuX2Vtb2ppUGlja2VyUmVmIHx8ICF0aGlzLl9lbW9qaVBpY2tlclJlZi5kZXN0cm95KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZW1vamlTdWJzLmZvckVhY2goKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fZW1vamlQaWNrZXJSZWYuZGVzdHJveSgpO1xuICAgIFxuICAgIHRoaXMuX2Vtb2ppU3VicyA9IFtdO1xuICAgIGRlbGV0ZSB0aGlzLl9lbW9qaVBpY2tlclJlZjtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KHRydWUpO1xuICB9XG59XG4iXX0=