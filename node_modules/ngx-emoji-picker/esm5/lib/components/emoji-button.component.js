import { __decorate, __metadata } from "tslib";
import { Component, Input, EventEmitter, Output } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../pipes/emoji-fallback.pipe';
var EmojiButtonComponent = /** @class */ (function () {
    function EmojiButtonComponent() {
        this.selectionEmitter = new EventEmitter();
    }
    EmojiButtonComponent.prototype.ngOnChanges = function () { };
    __decorate([
        Input('emoji'),
        __metadata("design:type", Object)
    ], EmojiButtonComponent.prototype, "emoji", void 0);
    __decorate([
        Input('dataToEmit'),
        __metadata("design:type", Object)
    ], EmojiButtonComponent.prototype, "dataToEmit", void 0);
    __decorate([
        Input('options'),
        __metadata("design:type", Object)
    ], EmojiButtonComponent.prototype, "options", void 0);
    __decorate([
        Input('fitzpatrick'),
        __metadata("design:type", Object)
    ], EmojiButtonComponent.prototype, "fitzpatrick", void 0);
    __decorate([
        Output('selection'),
        __metadata("design:type", EventEmitter)
    ], EmojiButtonComponent.prototype, "selectionEmitter", void 0);
    EmojiButtonComponent = __decorate([ __metadata("design:paramtypes", [])
    ], EmojiButtonComponent);
EmojiButtonComponent.ɵfac = function EmojiButtonComponent_Factory(t) { return new (t || EmojiButtonComponent)(); };
EmojiButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EmojiButtonComponent, selectors: [["emoji-button"]], inputs: { emoji: "emoji", dataToEmit: "dataToEmit", options: "options", fitzpatrick: "fitzpatrick" }, outputs: { selectionEmitter: "selection" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 3, consts: [[1, "emoji-button", 3, "innerHTML", "click"]], template: function EmojiButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function EmojiButtonComponent_Template_button_click_0_listener() { return ctx.selectionEmitter.emit(ctx.dataToEmit || ctx.emoji); });
        ɵngcc0.ɵɵpipe(1, "emojiFallback");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("innerHTML", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.emoji[0]), ɵngcc0.ɵɵsanitizeHtml);
    } }, pipes: [ɵngcc1.EmojiFallback], styles: ["[_nghost-%COMP%]{display:inline-block}.emoji-button[_ngcontent-%COMP%]{padding:0;border:none;outline:0;background:0 0;width:34px;height:34px;border-radius:3px;font-size:24px;line-height:1.1;cursor:pointer;transition:.2s}.emoji-button[_ngcontent-%COMP%]:focus, .emoji-button[_ngcontent-%COMP%]:hover{background:#f1f1f1;border-color:#f1f1f1}.emoji-button[_ngcontent-%COMP%]     img{width:20px}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmojiButtonComponent, [{
        type: Component,
        args: [{
                selector: 'emoji-button',
                template: "\n    <button\n      class=\"emoji-button\" \n      (click)=\"selectionEmitter.emit(dataToEmit || emoji)\" [innerHTML]=\"emoji[0] | emojiFallback\">\n    </button>\n  ",
                styles: [":host{display:inline-block}.emoji-button{padding:0;border:none;outline:0;background:0 0;width:34px;height:34px;border-radius:3px;font-size:24px;line-height:1.1;cursor:pointer;transition:.2s}.emoji-button:focus,.emoji-button:hover{background:#f1f1f1;border-color:#f1f1f1}.emoji-button ::ng-deep img{width:20px}"]
            }]
    }], function () { return []; }, { selectionEmitter: [{
            type: Output,
            args: ['selection']
        }], emoji: [{
            type: Input,
            args: ['emoji']
        }], dataToEmit: [{
            type: Input,
            args: ['dataToEmit']
        }], options: [{
            type: Input,
            args: ['options']
        }], fitzpatrick: [{
            type: Input,
            args: ['fitzpatrick']
        }] }); })();
    return EmojiButtonComponent;
}());
export { EmojiButtonComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1vamktYnV0dG9uLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L25neC1lbW9qaS1waWNrZXIvbGliL2NvbXBvbmVudHMvZW1vamktYnV0dG9uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQTs7O0FBWXRFO0FBQ29CLElBT2xCO0FBRWMsUUFKTyxxQkFBZ0IsR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQTtBQUMvRSxJQUNpQixDQUFDO0FBQ2xCLElBQ0UsMENBQVcsR0FBWCxjQUFlLENBQUM7QUFDakIsSUFWaUI7QUFDWCxRQURKLEtBQUssQ0FBQyxPQUFPLENBQUM7QUFBRTtBQUVoQix1REFGb0I7QUFDdEIsSUFBc0I7QUFDckIsUUFEQyxLQUFLLENBQUMsWUFBWSxDQUFDO0FBQUU7QUFFcEIsNERBRjZCO0FBQ2hDLElBQW1CO0FBQ2YsUUFERixLQUFLLENBQUMsU0FBUyxDQUFDO0FBQUU7QUFDYyx5REFEUjtBQUMxQixJQUF1QjtBQUV4QixRQUZHLEtBQUssQ0FBQyxhQUFhLENBQUM7QUFBRTtBQUVLLDZEQUZLO0FBRW5DLElBQXVCO0FBQWEsUUFBakMsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUFFLGtDQUFpQixZQUFZO0FBQUUsa0VBQXdCO0FBRS9FLElBUmEsb0JBQW9CLHdCQVZoQyxTQUFTLENBQUMsY0FDVCxqQ0FTTTtJQVRFLEVBQUUsY0FBYyxwQkFVakIsT0FESSxvQkFBb0IsQ0FXaEM7SUFsQkMsUUFBUSxFQUFFO21FQUtULHlWQUNGLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFhRjtBQUFDLElBREQsMkJBQUM7QUFDQSxDQURBLEFBWEQsSUFXQztBQUNELFNBWmEsb0JBQW9CO0FBQ2hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJ1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdlbW9qaS1idXR0b24nLFxuICBzdHlsZVVybHM6IFsnLi4vc3R5bGVzL2Vtb2ppLWJ1dHRvbi5zY3NzJ10sXG4gIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3M9XCJlbW9qaS1idXR0b25cIiBcbiAgICAgIChjbGljayk9XCJzZWxlY3Rpb25FbWl0dGVyLmVtaXQoZGF0YVRvRW1pdCB8fCBlbW9qaSlcIiBbaW5uZXJIVE1MXT1cImVtb2ppWzBdIHwgZW1vamlGYWxsYmFja1wiPlxuICAgIDwvYnV0dG9uPlxuICBgXG59KVxuZXhwb3J0IGNsYXNzIEVtb2ppQnV0dG9uQ29tcG9uZW50IHtcbiAgQElucHV0KCdlbW9qaScpIGVtb2ppXG4gIEBJbnB1dCgnZGF0YVRvRW1pdCcpIGRhdGFUb0VtaXRcbiAgQElucHV0KCdvcHRpb25zJykgb3B0aW9uc1xuICBASW5wdXQoJ2ZpdHpwYXRyaWNrJykgZml0enBhdHJpY2tcblxuICBAT3V0cHV0KCdzZWxlY3Rpb24nKSBzZWxlY3Rpb25FbWl0dGVyOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKVxuXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICBuZ09uQ2hhbmdlcygpIHt9XG59XG4iXX0=