import { __decorate, __metadata } from "tslib";
import { Component, EventEmitter, Output, ViewChild, ElementRef, } from "@angular/core";
import { Subject } from "rxjs";
import { takeUntil } from "rxjs/operators";
import * as ɵngcc0 from '@angular/core';

var _c0 = ["input"];
var EmojiSearchComponent = /** @class */ (function () {
    function EmojiSearchComponent() {
        var _this = this;
        this.searchEmitter = new EventEmitter();
        this._searchValue = new Subject();
        this._destroyed = new Subject();
        this._searchValue.pipe(takeUntil(this._destroyed)).subscribe(function (value) {
            _this.searchEmitter.emit(value);
        });
    }
    EmojiSearchComponent.prototype.handleInputChange = function (event) {
        this._searchValue.next(event);
    };
    EmojiSearchComponent.prototype.ngOnDestroy = function () {
        this._destroyed.next(true);
    };
    __decorate([
        Output("search"),
        __metadata("design:type", EventEmitter)
    ], EmojiSearchComponent.prototype, "searchEmitter", void 0);
    __decorate([
        ViewChild("input", { static: true }),
        __metadata("design:type", ElementRef)
    ], EmojiSearchComponent.prototype, "input", void 0);
    EmojiSearchComponent = __decorate([ __metadata("design:paramtypes", [])
    ], EmojiSearchComponent);
EmojiSearchComponent.ɵfac = function EmojiSearchComponent_Factory(t) { return new (t || EmojiSearchComponent)(); };
EmojiSearchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: EmojiSearchComponent, selectors: [["emoji-search"]], viewQuery: function EmojiSearchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, outputs: { searchEmitter: "search" }, decls: 2, vars: 0, consts: [["type", "text", "autocomplete", "off", "aria-label", "Search", "placeholder", "Search", 3, "input"], ["input", ""]], template: function EmojiSearchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("input", function EmojiSearchComponent_Template_input_input_0_listener($event) { return ctx.handleInputChange($event.target.value); });
        ɵngcc0.ɵɵelementEnd();
    } }, styles: ["input[_ngcontent-%COMP%]{width:100%;padding:5px 10px;border:1px solid #f0f0f0;outline:0;font-size:14px;font-weight:inherit;box-sizing:border-box}input[_ngcontent-%COMP%]:focus{border-color:#d7d7d7}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EmojiSearchComponent, [{
        type: Component,
        args: [{
                selector: "emoji-search",
                template: "\n    <input\n      type=\"text\"\n      autocomplete=\"off\"\n      #input\n      (input)=\"handleInputChange($event.target.value)\"\n      aria-label=\"Search\"\n      placeholder=\"Search\"\n    />\n  ",
                styles: ["input{width:100%;padding:5px 10px;border:1px solid #f0f0f0;outline:0;font-size:14px;font-weight:inherit;box-sizing:border-box}input:focus{border-color:#d7d7d7}"]
            }]
    }], function () { return []; }, { searchEmitter: [{
            type: Output,
            args: ["search"]
        }], input: [{
            type: ViewChild,
            args: ["input", { static: true }]
        }] }); })();
    return EmojiSearchComponent;
}());
export { EmojiSearchComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1vamktc2VhcmNoLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L25neC1lbW9qaS1waWNrZXIvbGliL2NvbXBvbmVudHMvZW1vamktc2VhcmNoLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUNOLFNBQVMsRUFDVCxVQUFVLEdBRVgsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFnQjNDO0FBQXdELElBT3REO0FBQ2dCLFFBRGhCLGlCQUlDO0FBQ0gsUUFYb0Isa0JBQWEsR0FBeUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUM3RSxRQUVVLGlCQUFZLEdBQW9CLElBQUksT0FBTyxFQUFFLENBQUM7QUFDeEQsUUFBVSxlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztBQUM5QyxRQUVJLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBQyxLQUFLO0FBQUksWUFDckUsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsUUFBSSxDQUFDLENBQUMsQ0FBQztBQUNQLElBQUUsQ0FBQztBQUNILElBQ0UsZ0RBQWlCLEdBQWpCLFVBQWtCLEtBQUs7QUFDekIsUUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsQyxJQUFFLENBQUM7QUFFSCxJQUFFLDBDQUFXLEdBQVg7QUFBYyxRQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQy9CLElBQUUsQ0FBQztBQUNGLElBbkJtQjtBQUFhLFFBQTlCLE1BQU0sQ0FBQyxRQUFRLENBQUM7QUFBRSxrQ0FBYyxZQUFZO0FBQUUsK0RBQTRCO0FBQzVFLElBQXVDO0FBQWEsUUFBbEQsU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUFFLGtDQUFNLFVBQVU7QUFDekQsdURBRDBEO0FBRTFELElBSmEsb0JBQW9CLHdCQWRoQyxTQUFTLENBQUMsY0FDVCxqQ0FhTTtJQWJFLEVBQUUsY0FBYyxwQkFhbUIsT0FBaEMsb0JBQW9CLENBb0JoQztJQS9CQyxRQUFRLEVBQUU7d0dBU1Q7Ozs7Z0NBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFzQkY7QUFBQyxJQURELDJCQUFDO0FBQ0EsQ0FEQSxBQXBCRCxJQW9CQztBQUNELFNBckJhLG9CQUFvQjtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxuICBFbGVtZW50UmVmLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwiZW1vamktc2VhcmNoXCIsXG4gIHN0eWxlVXJsczogW1wiLi4vc3R5bGVzL2Vtb2ppLXNlYXJjaC5zY3NzXCJdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICNpbnB1dFxuICAgICAgKGlucHV0KT1cImhhbmRsZUlucHV0Q2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXCJcbiAgICAgIGFyaWEtbGFiZWw9XCJTZWFyY2hcIlxuICAgICAgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIlxuICAgIC8+XG4gIGAsXG59KVxuZXhwb3J0IGNsYXNzIEVtb2ppU2VhcmNoQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgQE91dHB1dChcInNlYXJjaFwiKSBzZWFyY2hFbWl0dGVyOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQFZpZXdDaGlsZChcImlucHV0XCIsIHsgc3RhdGljOiB0cnVlIH0pIGlucHV0OiBFbGVtZW50UmVmO1xuXG4gIHByaXZhdGUgX3NlYXJjaFZhbHVlOiBTdWJqZWN0PHN0cmluZz4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3NlYXJjaFZhbHVlLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoRW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5fc2VhcmNoVmFsdWUubmV4dChldmVudCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95ZWQubmV4dCh0cnVlKTtcbiAgfVxufVxuIl19